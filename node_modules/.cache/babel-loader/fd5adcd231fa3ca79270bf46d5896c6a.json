{"ast":null,"code":"/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport { TRUE } from '../functions.js';\nimport { always } from '../events/condition.js';\n/**\n * @enum {string}\n */\n\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend'\n};\n/**\n * A function that takes an {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<import(\"../Feature.js\").default>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\n\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<import(\"../Feature.js\").default>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n    /**\n     * The features being translated.\n     * @type {Collection<import(\"../Feature.js\").default>}\n     * @api\n     */\n\n    this.features = features;\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n\n    this.coordinate = coordinate;\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n\n    this.startCoordinate = startCoordinate;\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n\n}\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\n\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(\n    /** @type {import(\"./Pointer.js\").Options} */\n    options);\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.on;\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.once;\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n\n    this.un;\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.lastCoordinate_ = null;\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.startCoordinate_ = null;\n    /**\n     * @type {Collection<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n\n    this.features_ = options.features !== undefined ? options.features : null;\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n\n    let layerFilter;\n\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n\n\n    this.layerFilter_ = layerFilter;\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    this.condition_ = options.condition ? options.condition : always;\n    /**\n     * @type {import(\"../Feature.js\").default}\n     * @private\n     */\n\n    this.lastFeature_ = null;\n    this.addChangeListener(InteractionProperty.ACTIVE, this.handleActiveChanged_);\n  }\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event)); // cleanup\n\n      this.startCoordinate_ = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n\n\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n      this.lastCoordinate_ = newCoordinate;\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));\n    }\n  }\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n\n\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n\n\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(pixel, function (feature, layer) {\n      if (this.filter_(feature, layer)) {\n        if (!this.features_ || this.features_.getArray().includes(feature)) {\n          return feature;\n        }\n      }\n    }.bind(this), {\n      layerFilter: this.layerFilter_,\n      hitTolerance: this.hitTolerance_\n    });\n  }\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n\n\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n\n\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n\n\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n  /**\n   * @private\n   */\n\n\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n\n\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n\n    if (!map || !active) {\n      map = map || oldMap;\n\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n\n}\n\nexport default Translate;","map":{"version":3,"names":["Collection","Event","InteractionProperty","PointerInteraction","TRUE","always","TranslateEventType","TRANSLATESTART","TRANSLATING","TRANSLATEEND","TranslateEvent","constructor","type","features","coordinate","startCoordinate","mapBrowserEvent","Translate","options","on","once","un","lastCoordinate_","startCoordinate_","features_","undefined","layerFilter","layers","layer","includes","layerFilter_","filter_","filter","hitTolerance_","hitTolerance","condition_","condition","lastFeature_","addChangeListener","ACTIVE","handleActiveChanged_","handleDownEvent","event","originalEvent","featuresAtPixel_","pixel","map","handleMoveEvent","dispatchEvent","handleUpEvent","handleDragEvent","newCoordinate","deltaX","deltaY","forEach","feature","geom","getGeometry","translate","setGeometry","elem","getViewport","classList","remove","add","forEachFeatureAtPixel","getArray","bind","getHitTolerance","setHitTolerance","setMap","oldMap","getMap","updateState_","active","getActive"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/interaction/Translate.js"],"sourcesContent":["/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport {TRUE} from '../functions.js';\nimport {always} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<import(\"../Feature.js\").default>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<import(\"../Feature.js\").default>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {import(\"../Feature.js\").default}\n     * @private\n     */\n    this.lastFeature_ = null;\n\n    this.addChangeListener(\n      InteractionProperty.ACTIVE,\n      this.handleActiveChanged_\n    );\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATESTART,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATEEND,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n\n      this.lastCoordinate_ = newCoordinate;\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATING,\n          features,\n          newCoordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(\n      pixel,\n      function (feature, layer) {\n        if (this.filter_(feature, layer)) {\n          if (!this.features_ || this.features_.getArray().includes(feature)) {\n            return feature;\n          }\n        }\n      }.bind(this),\n      {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_,\n      }\n    );\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\n\nexport default Translate;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,kBAAvB;AACA,OAAOC,KAAP,MAAkB,oBAAlB;AACA,OAAOC,mBAAP,MAAgC,eAAhC;AACA,OAAOC,kBAAP,MAA+B,cAA/B;AACA,SAAQC,IAAR,QAAmB,iBAAnB;AACA,SAAQC,MAAR,QAAqB,wBAArB;AAEA;AACA;AACA;;AACA,MAAMC,kBAAkB,GAAG;EACzB;AACF;AACA;AACA;AACA;EACEC,cAAc,EAAE,gBANS;;EAOzB;AACF;AACA;AACA;AACA;EACEC,WAAW,EAAE,aAZY;;EAazB;AACF;AACA;AACA;AACA;EACEC,YAAY,EAAE;AAlBW,CAA3B;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAN,SAA6BT,KAA7B,CAAmC;EACxC;AACF;AACA;AACA;AACA;AACA;AACA;EACEU,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiBC,UAAjB,EAA6BC,eAA7B,EAA8CC,eAA9C,EAA+D;IACxE,MAAMJ,IAAN;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,QAAL,GAAgBA,QAAhB;IAEA;AACJ;AACA;AACA;AACA;AACA;;IACI,KAAKC,UAAL,GAAkBA,UAAlB;IAEA;AACJ;AACA;AACA;AACA;AACA;;IACI,KAAKC,eAAL,GAAuBA,eAAvB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,eAAL,GAAuBA,eAAvB;EACD;;AAxCuC;AA2C1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,SAAwBd,kBAAxB,CAA2C;EACzC;AACF;AACA;EACEQ,WAAW,CAACO,OAAD,EAAU;IACnBA,OAAO,GAAGA,OAAO,GAAGA,OAAH,GAAa,EAA9B;IAEA;IAAM;IAA+CA,OAA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"},"metadata":{},"sourceType":"module"}