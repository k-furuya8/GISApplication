{"ast":null,"code":"const CRLFCRLF = '\\r\\n\\r\\n';\n/*\n * Shim for 'Object.fromEntries'\n */\n\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n\n  const obj = {};\n\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n\n  return obj;\n}\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\n\n\nfunction parseHeaders(text) {\n  const items = text.split('\\r\\n').map(line => {\n    const kv = line.split(':').map(str => str.trim());\n    kv[0] = kv[0].toLowerCase();\n    return kv;\n  });\n  return itemsToObject(items);\n}\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\n\n\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map(s => s.trim());\n  const paramsItems = rawParams.map(param => param.split('='));\n  return {\n    type,\n    params: itemsToObject(paramsItems)\n  };\n}\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\n\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return {\n    start,\n    end,\n    total\n  };\n}\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\n\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`; // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));\n\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset))); // break if we arrived at the end\n\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    } // assert that we are actually dealing with a byterange and are at the correct offset\n\n\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    } // get a substring from where we read the headers\n\n\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    } // find the double linebreak that denotes the end of the headers\n\n\n    const endOfHeaders = innerText.indexOf(CRLFCRLF); // parse the headers to get the content range size\n\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const {\n      start,\n      end,\n      total\n    } = parseContentRange(headers['content-range']); // calculate the length of the slice and the next offset\n\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total\n    });\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}","map":{"version":3,"names":["CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","key","value","toLowerCase","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","s","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","offset","decoder","TextDecoder","out","startBoundary","endBoundary","i","decode","Uint8Array","length","Error","byteLength","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","push","data","slice","fileSize"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/source/httputils.js"],"sourcesContent":["const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}