{"ast":null,"code":"/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\n\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {\n  let o, t;\n  const n = (end - offset) / stride;\n\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n\n    if (index < 0) {\n      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\n\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n\n  let coordinate;\n\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } // FIXME use O(1) search\n\n\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n\n  let lo = offset / stride;\n  let hi = end / stride;\n\n  while (lo < hi) {\n    const mid = lo + hi >> 1;\n\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  const m0 = flatCoordinates[lo * stride - 1];\n\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n\n  coordinate.push(m);\n  return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\n\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n\n  let coordinate;\n\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n\n    if (offset == end) {\n      continue;\n    }\n\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n\n    offset = end;\n  }\n\n  return null;\n}","map":{"version":3,"names":["binarySearch","lerp","interpolatePoint","flatCoordinates","offset","end","stride","fraction","dest","dimension","o","t","n","x1","y1","length","cumulativeLengths","i","x2","y2","Math","sqrt","push","target","index","Array","undefined","NaN","lineStringCoordinateAtM","m","extrapolate","coordinate","slice","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","ends","interpolate","ii"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/geom/flat/interpolate.js"],"sourcesContent":["/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n        ? flatCoordinates[o + i]\n        : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t\n      )\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,YAAR,QAA2B,gBAA3B;AACA,SAAQC,IAAR,QAAmB,eAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CACLC,eADK,EAELC,MAFK,EAGLC,GAHK,EAILC,MAJK,EAKLC,QALK,EAMLC,IANK,EAOLC,SAPK,EAQL;EACA,IAAIC,CAAJ,EAAOC,CAAP;EACA,MAAMC,CAAC,GAAG,CAACP,GAAG,GAAGD,MAAP,IAAiBE,MAA3B;;EACA,IAAIM,CAAC,KAAK,CAAV,EAAa;IACXF,CAAC,GAAGN,MAAJ;EACD,CAFD,MAEO,IAAIQ,CAAC,KAAK,CAAV,EAAa;IAClBF,CAAC,GAAGN,MAAJ;IACAO,CAAC,GAAGJ,QAAJ;EACD,CAHM,MAGA,IAAIK,CAAC,KAAK,CAAV,EAAa;IAClB,IAAIC,EAAE,GAAGV,eAAe,CAACC,MAAD,CAAxB;IACA,IAAIU,EAAE,GAAGX,eAAe,CAACC,MAAM,GAAG,CAAV,CAAxB;IACA,IAAIW,MAAM,GAAG,CAAb;IACA,MAAMC,iBAAiB,GAAG,CAAC,CAAD,CAA1B;;IACA,KAAK,IAAIC,CAAC,GAAGb,MAAM,GAAGE,MAAtB,EAA8BW,CAAC,GAAGZ,GAAlC,EAAuCY,CAAC,IAAIX,MAA5C,EAAoD;MAClD,MAAMY,EAAE,GAAGf,eAAe,CAACc,CAAD,CAA1B;MACA,MAAME,EAAE,GAAGhB,eAAe,CAACc,CAAC,GAAG,CAAL,CAA1B;MACAF,MAAM,IAAIK,IAAI,CAACC,IAAL,CAAU,CAACH,EAAE,GAAGL,EAAN,KAAaK,EAAE,GAAGL,EAAlB,IAAwB,CAACM,EAAE,GAAGL,EAAN,KAAaK,EAAE,GAAGL,EAAlB,CAAlC,CAAV;MACAE,iBAAiB,CAACM,IAAlB,CAAuBP,MAAvB;MACAF,EAAE,GAAGK,EAAL;MACAJ,EAAE,GAAGK,EAAL;IACD;;IACD,MAAMI,MAAM,GAAGhB,QAAQ,GAAGQ,MAA1B;IACA,MAAMS,KAAK,GAAGxB,YAAY,CAACgB,iBAAD,EAAoBO,MAApB,CAA1B;;IACA,IAAIC,KAAK,GAAG,CAAZ,EAAe;MACbb,CAAC,GACC,CAACY,MAAM,GAAGP,iBAAiB,CAAC,CAACQ,KAAD,GAAS,CAAV,CAA3B,KACCR,iBAAiB,CAAC,CAACQ,KAAD,GAAS,CAAV,CAAjB,GAAgCR,iBAAiB,CAAC,CAACQ,KAAD,GAAS,CAAV,CADlD,CADF;MAGAd,CAAC,GAAGN,MAAM,GAAG,CAAC,CAACoB,KAAD,GAAS,CAAV,IAAelB,MAA5B;IACD,CALD,MAKO;MACLI,CAAC,GAAGN,MAAM,GAAGoB,KAAK,GAAGlB,MAArB;IACD;EACF;;EACDG,SAAS,GAAGA,SAAS,GAAG,CAAZ,GAAgBA,SAAhB,GAA4B,CAAxC;EACAD,IAAI,GAAGA,IAAI,GAAGA,IAAH,GAAU,IAAIiB,KAAJ,CAAUhB,SAAV,CAArB;;EACA,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,SAApB,EAA+B,EAAEQ,CAAjC,EAAoC;IAClCT,IAAI,CAACS,CAAD,CAAJ,GACEP,CAAC,KAAKgB,SAAN,GACIC,GADJ,GAEIhB,CAAC,KAAKe,SAAN,GACAvB,eAAe,CAACO,CAAC,GAAGO,CAAL,CADf,GAEAhB,IAAI,CAACE,eAAe,CAACO,CAAC,GAAGO,CAAL,CAAhB,EAAyBd,eAAe,CAACO,CAAC,GAAGJ,MAAJ,GAAaW,CAAd,CAAxC,EAA0DN,CAA1D,CALV;EAMD;;EACD,OAAOH,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASoB,uBAAT,CACLzB,eADK,EAELC,MAFK,EAGLC,GAHK,EAILC,MAJK,EAKLuB,CALK,EAMLC,WANK,EAOL;EACA,IAAIzB,GAAG,IAAID,MAAX,EAAmB;IACjB,OAAO,IAAP;EACD;;EACD,IAAI2B,UAAJ;;EACA,IAAIF,CAAC,GAAG1B,eAAe,CAACC,MAAM,GAAGE,MAAT,GAAkB,CAAnB,CAAvB,EAA8C;IAC5C,IAAIwB,WAAJ,EAAiB;MACfC,UAAU,GAAG5B,eAAe,CAAC6B,KAAhB,CAAsB5B,MAAtB,EAA8BA,MAAM,GAAGE,MAAvC,CAAb;MACAyB,UAAU,CAACzB,MAAM,GAAG,CAAV,CAAV,GAAyBuB,CAAzB;MACA,OAAOE,UAAP;IACD,CAJD,MAIO;MACL,OAAO,IAAP;IACD;EACF,CARD,MAQO,IAAI5B,eAAe,CAACE,GAAG,GAAG,CAAP,CAAf,GAA2BwB,CAA/B,EAAkC;IACvC,IAAIC,WAAJ,EAAiB;MACfC,UAAU,GAAG5B,eAAe,CAAC6B,KAAhB,CAAsB3B,GAAG,GAAGC,MAA5B,EAAoCD,GAApC,CAAb;MACA0B,UAAU,CAACzB,MAAM,GAAG,CAAV,CAAV,GAAyBuB,CAAzB;MACA,OAAOE,UAAP;IACD,CAJD,MAIO;MACL,OAAO,IAAP;IACD;EACF,CArBD,CAsBA;;;EACA,IAAIF,CAAC,IAAI1B,eAAe,CAACC,MAAM,GAAGE,MAAT,GAAkB,CAAnB,CAAxB,EAA+C;IAC7C,OAAOH,eAAe,CAAC6B,KAAhB,CAAsB5B,MAAtB,EAA8BA,MAAM,GAAGE,MAAvC,CAAP;EACD;;EACD,IAAI2B,EAAE,GAAG7B,MAAM,GAAGE,MAAlB;EACA,IAAI4B,EAAE,GAAG7B,GAAG,GAAGC,MAAf;;EACA,OAAO2B,EAAE,GAAGC,EAAZ,EAAgB;IACd,MAAMC,GAAG,GAAIF,EAAE,GAAGC,EAAN,IAAa,CAAzB;;IACA,IAAIL,CAAC,GAAG1B,eAAe,CAAC,CAACgC,GAAG,GAAG,CAAP,IAAY7B,MAAZ,GAAqB,CAAtB,CAAvB,EAAiD;MAC/C4B,EAAE,GAAGC,GAAL;IACD,CAFD,MAEO;MACLF,EAAE,GAAGE,GAAG,GAAG,CAAX;IACD;EACF;;EACD,MAAMC,EAAE,GAAGjC,eAAe,CAAC8B,EAAE,GAAG3B,MAAL,GAAc,CAAf,CAA1B;;EACA,IAAIuB,CAAC,IAAIO,EAAT,EAAa;IACX,OAAOjC,eAAe,CAAC6B,KAAhB,CAAsB,CAACC,EAAE,GAAG,CAAN,IAAW3B,MAAjC,EAAyC,CAAC2B,EAAE,GAAG,CAAN,IAAW3B,MAAX,GAAoBA,MAA7D,CAAP;EACD;;EACD,MAAM+B,EAAE,GAAGlC,eAAe,CAAC,CAAC8B,EAAE,GAAG,CAAN,IAAW3B,MAAX,GAAoB,CAArB,CAA1B;EACA,MAAMK,CAAC,GAAG,CAACkB,CAAC,GAAGO,EAAL,KAAYC,EAAE,GAAGD,EAAjB,CAAV;EACAL,UAAU,GAAG,EAAb;;EACA,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,MAAM,GAAG,CAA7B,EAAgC,EAAEW,CAAlC,EAAqC;IACnCc,UAAU,CAACT,IAAX,CACErB,IAAI,CACFE,eAAe,CAAC,CAAC8B,EAAE,GAAG,CAAN,IAAW3B,MAAX,GAAoBW,CAArB,CADb,EAEFd,eAAe,CAAC8B,EAAE,GAAG3B,MAAL,GAAcW,CAAf,CAFb,EAGFN,CAHE,CADN;EAOD;;EACDoB,UAAU,CAACT,IAAX,CAAgBO,CAAhB;EACA,OAAOE,UAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,wBAAT,CACLnC,eADK,EAELC,MAFK,EAGLmC,IAHK,EAILjC,MAJK,EAKLuB,CALK,EAMLC,WANK,EAOLU,WAPK,EAQL;EACA,IAAIA,WAAJ,EAAiB;IACf,OAAOZ,uBAAuB,CAC5BzB,eAD4B,EAE5BC,MAF4B,EAG5BmC,IAAI,CAACA,IAAI,CAACxB,MAAL,GAAc,CAAf,CAHwB,EAI5BT,MAJ4B,EAK5BuB,CAL4B,EAM5BC,WAN4B,CAA9B;EAQD;;EACD,IAAIC,UAAJ;;EACA,IAAIF,CAAC,GAAG1B,eAAe,CAACG,MAAM,GAAG,CAAV,CAAvB,EAAqC;IACnC,IAAIwB,WAAJ,EAAiB;MACfC,UAAU,GAAG5B,eAAe,CAAC6B,KAAhB,CAAsB,CAAtB,EAAyB1B,MAAzB,CAAb;MACAyB,UAAU,CAACzB,MAAM,GAAG,CAAV,CAAV,GAAyBuB,CAAzB;MACA,OAAOE,UAAP;IACD,CAJD,MAIO;MACL,OAAO,IAAP;IACD;EACF;;EACD,IAAI5B,eAAe,CAACA,eAAe,CAACY,MAAhB,GAAyB,CAA1B,CAAf,GAA8Cc,CAAlD,EAAqD;IACnD,IAAIC,WAAJ,EAAiB;MACfC,UAAU,GAAG5B,eAAe,CAAC6B,KAAhB,CAAsB7B,eAAe,CAACY,MAAhB,GAAyBT,MAA/C,CAAb;MACAyB,UAAU,CAACzB,MAAM,GAAG,CAAV,CAAV,GAAyBuB,CAAzB;MACA,OAAOE,UAAP;IACD,CAJD,MAIO;MACL,OAAO,IAAP;IACD;EACF;;EACD,KAAK,IAAId,CAAC,GAAG,CAAR,EAAWwB,EAAE,GAAGF,IAAI,CAACxB,MAA1B,EAAkCE,CAAC,GAAGwB,EAAtC,EAA0C,EAAExB,CAA5C,EAA+C;IAC7C,MAAMZ,GAAG,GAAGkC,IAAI,CAACtB,CAAD,CAAhB;;IACA,IAAIb,MAAM,IAAIC,GAAd,EAAmB;MACjB;IACD;;IACD,IAAIwB,CAAC,GAAG1B,eAAe,CAACC,MAAM,GAAGE,MAAT,GAAkB,CAAnB,CAAvB,EAA8C;MAC5C,OAAO,IAAP;IACD,CAFD,MAEO,IAAIuB,CAAC,IAAI1B,eAAe,CAACE,GAAG,GAAG,CAAP,CAAxB,EAAmC;MACxC,OAAOuB,uBAAuB,CAC5BzB,eAD4B,EAE5BC,MAF4B,EAG5BC,GAH4B,EAI5BC,MAJ4B,EAK5BuB,CAL4B,EAM5B,KAN4B,CAA9B;IAQD;;IACDzB,MAAM,GAAGC,GAAT;EACD;;EACD,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}