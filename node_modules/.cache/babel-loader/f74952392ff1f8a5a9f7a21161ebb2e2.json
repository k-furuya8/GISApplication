{"ast":null,"code":"/**\n * @module ol/layer/WebGLTile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from '../layer/Property.js';\nimport WebGLTileLayerRenderer, { Attributes, Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { PALETTE_TEXTURE_ARRAY, ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n/**\n * @typedef {import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../style/expressions.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\n\nfunction parseStyle(style, bandCount) {\n  const vertexShader = `\n    attribute vec2 ${Attributes.TEXTURE_COORD};\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\n    uniform float ${Uniforms.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\n    }\n  `;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  const context = {\n    inFragmentShader: true,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n    bandCount: bandCount\n  };\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ValueTypes.COLOR);\n    pipeline.push(`color = ${color};`);\n  }\n\n  if (style.contrast !== undefined) {\n    const contrast = expressionToGlsl(context, style.contrast, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);\n  }\n\n  if (style.exposure !== undefined) {\n    const exposure = expressionToGlsl(context, style.exposure, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);\n  }\n\n  if (style.saturation !== undefined) {\n    const saturation = expressionToGlsl(context, style.saturation, ValueTypes.NUMBER);\n    pipeline.push(`\n      float saturation = ${saturation} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `);\n  }\n\n  if (style.gamma !== undefined) {\n    const gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\n  }\n\n  if (style.brightness !== undefined) {\n    const brightness = expressionToGlsl(context, style.brightness, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n\n\n  const uniforms = {};\n  const numVariables = context.variables.length;\n\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(`Missing variables in style (expected ${context.variables})`);\n  }\n\n  for (let i = 0; i < numVariables; ++i) {\n    const variableName = context.variables[i];\n\n    if (!(variableName in style.variables)) {\n      throw new Error(`Missing '${variableName}' in style variables`);\n    }\n\n    const uniformName = uniformNameForVariable(variableName);\n\n    uniforms[uniformName] = function () {\n      let value = style.variables[variableName];\n\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(context, value);\n      }\n\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n  const textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(`uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`);\n\n  if (context.paletteTextures) {\n    uniformDeclarations.push(`uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`);\n  }\n\n  const functionDefintions = Object.keys(context.functions).map(function (name) {\n    return context.functions[name];\n  });\n  const fragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\n    uniform float ${Uniforms.TRANSITION_ALPHA};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.RESOLUTION};\n    uniform float ${Uniforms.ZOOM};\n\n    ${uniformDeclarations.join('\\n')}\n\n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${Uniforms.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n\n      ${pipeline.join('\\n')}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\n    }`;\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms,\n    paletteTextures: context.paletteTextures\n  };\n}\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\n\n\nclass WebGLTileLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Tile layer options.\n   */\n  constructor(options) {\n    options = options ? Object.assign({}, options) : {};\n    const style = options.style || {};\n    delete options.style;\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n    super(options);\n    /**\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\n     * @private\n     */\n\n    this.sources_ = options.sources;\n    /**\n     * @type {SourceType|null}\n     * @private\n     */\n\n    this.renderedSource_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.renderedResolution_ = NaN;\n    /**\n     * @type {Style}\n     * @private\n     */\n\n    this.style_ = style;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.cacheSize_ = cacheSize;\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n\n    this.styleVariables_ = this.style_.variables || {};\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n\n\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    return this.sources_ ? typeof this.sources_ === 'function' ? this.sources_(extent, resolution) : this.sources_ : source ? [source] : [];\n  }\n  /**\n   * @return {SourceType} The source being rendered.\n   */\n\n\n  getRenderSource() {\n    return this.renderedSource_ || this.getSource();\n  }\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n\n\n  getSourceState() {\n    const source = this.getRenderSource();\n    return source ? source.getState() : 'undefined';\n  }\n  /**\n   * @private\n   */\n\n\n  handleSourceUpdate_() {\n    if (this.getSource()) {\n      this.setStyle(this.style_);\n    }\n  }\n  /**\n   * @private\n   * @return {number} The number of source bands.\n   */\n\n\n  getSourceBandCount_() {\n    const max = Number.MAX_SAFE_INTEGER;\n    const sources = this.getSources([-max, -max, max, max], max);\n    return sources && sources.length && 'bandCount' in sources[0] ? sources[0].bandCount : 4;\n  }\n\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.cacheSize_,\n      paletteTextures: parsedStyle.paletteTextures\n    });\n  }\n  /**\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\n   * @param {Array<SourceType>} sources Sources.\n   * @return {HTMLElement} Canvas.\n   */\n\n\n  renderSources(frameState, sources) {\n    const layerRenderer = this.getRenderer();\n    let canvas;\n\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      this.renderedSource_ = sources[i];\n\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n\n    return canvas;\n  }\n  /**\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  render(frameState, target) {\n    this.rendered = true;\n    const viewState = frameState.viewState;\n    const sources = this.getSources(frameState.extent, viewState.resolution);\n    let ready = true;\n\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      const source = sources[i];\n      const sourceState = source.getState();\n\n      if (sourceState == 'loading') {\n        const onChange = () => {\n          if (source.getState() == 'ready') {\n            source.removeEventListener('change', onChange);\n            this.changed();\n          }\n        };\n\n        source.addEventListener('change', onChange);\n      }\n\n      ready = ready && sourceState == 'ready';\n    }\n\n    const canvas = this.renderSources(frameState, sources);\n\n    if (this.getRenderer().renderComplete && ready) {\n      // Fully rendered, done.\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    } // Render sources from previously fully rendered frames\n\n\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      const altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(source => !sources.includes(source));\n\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n\n    return canvas;\n  }\n  /**\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\n   * this method may be called instead.  Note that calling this method will also replace\n   * any previously set variables, so the new style also needs to include new variables,\n   * if needed.\n   * @param {Style} style The new style.\n   */\n\n\n  setStyle(style) {\n    this.styleVariables_ = style.variables || {};\n    this.style_ = style;\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    const renderer = this.getRenderer();\n    renderer.reset({\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      paletteTextures: parsedStyle.paletteTextures\n    });\n    this.changed();\n  }\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n\n\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n}\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\n\n\nWebGLTileLayer.prototype.dispose;\nexport default WebGLTileLayer;","map":{"version":3,"names":["BaseTileLayer","LayerProperty","WebGLTileLayerRenderer","Attributes","Uniforms","PALETTE_TEXTURE_ARRAY","ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","parseStyle","style","bandCount","vertexShader","TEXTURE_COORD","TILE_TRANSFORM","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","DEPTH","context","inFragmentShader","variables","attributes","stringLiteralsMap","functions","pipeline","color","undefined","COLOR","push","contrast","NUMBER","exposure","saturation","gamma","brightness","uniforms","numVariables","length","Error","i","variableName","uniformName","value","uniformDeclarations","Object","keys","map","name","textureCount","Math","ceil","TILE_TEXTURE_ARRAY","paletteTextures","functionDefintions","fragmentShader","RENDER_EXTENT","TRANSITION_ALPHA","RESOLUTION","ZOOM","join","WebGLTileLayer","constructor","options","assign","cacheSize","sources_","sources","renderedSource_","renderedResolution_","NaN","style_","cacheSize_","styleVariables_","addChangeListener","SOURCE","handleSourceUpdate_","getSources","extent","resolution","source","getSource","getRenderSource","getSourceState","getState","setStyle","getSourceBandCount_","max","Number","MAX_SAFE_INTEGER","createRenderer","parsedStyle","renderSources","frameState","layerRenderer","getRenderer","canvas","ii","prepareFrame","renderFrame","render","target","rendered","viewState","ready","sourceState","onChange","removeEventListener","changed","addEventListener","renderComplete","altSources","filter","includes","renderer","reset","updateStyleVariables","prototype","dispose"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/layer/WebGLTile.js"],"sourcesContent":["/**\n * @module ol/layer/WebGLTile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from '../layer/Property.js';\nimport WebGLTileLayerRenderer, {\n  Attributes,\n  Uniforms,\n} from '../renderer/webgl/TileLayer.js';\nimport {\n  PALETTE_TEXTURE_ARRAY,\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  uniformNameForVariable,\n} from '../style/expressions.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../style/expressions.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style, bandCount) {\n  const vertexShader = `\n    attribute vec2 ${Attributes.TEXTURE_COORD};\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\n    uniform float ${Uniforms.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\n    }\n  `;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const context = {\n    inFragmentShader: true,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n    bandCount: bandCount,\n  };\n\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ValueTypes.COLOR);\n    pipeline.push(`color = ${color};`);\n  }\n\n  if (style.contrast !== undefined) {\n    const contrast = expressionToGlsl(\n      context,\n      style.contrast,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  if (style.exposure !== undefined) {\n    const exposure = expressionToGlsl(\n      context,\n      style.exposure,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  if (style.saturation !== undefined) {\n    const saturation = expressionToGlsl(\n      context,\n      style.saturation,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(`\n      float saturation = ${saturation} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `);\n  }\n\n  if (style.gamma !== undefined) {\n    const gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\n  }\n\n  if (style.brightness !== undefined) {\n    const brightness = expressionToGlsl(\n      context,\n      style.brightness,\n      ValueTypes.NUMBER\n    );\n    pipeline.push(\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  const numVariables = context.variables.length;\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`\n    );\n  }\n\n  for (let i = 0; i < numVariables; ++i) {\n    const variableName = context.variables[i];\n    if (!(variableName in style.variables)) {\n      throw new Error(`Missing '${variableName}' in style variables`);\n    }\n    const uniformName = uniformNameForVariable(variableName);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variableName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(context, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`\n  );\n\n  if (context.paletteTextures) {\n    uniformDeclarations.push(\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`\n    );\n  }\n\n  const functionDefintions = Object.keys(context.functions).map(function (\n    name\n  ) {\n    return context.functions[name];\n  });\n\n  const fragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\n    uniform float ${Uniforms.TRANSITION_ALPHA};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.RESOLUTION};\n    uniform float ${Uniforms.ZOOM};\n\n    ${uniformDeclarations.join('\\n')}\n\n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${\n        Uniforms.TILE_TEXTURE_ARRAY\n      }[0],  v_textureCoord);\n\n      ${pipeline.join('\\n')}\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\n    }`;\n\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms,\n    paletteTextures: context.paletteTextures,\n  };\n}\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nclass WebGLTileLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Tile layer options.\n   */\n  constructor(options) {\n    options = options ? Object.assign({}, options) : {};\n\n    const style = options.style || {};\n    delete options.style;\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    super(options);\n\n    /**\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\n     * @private\n     */\n    this.sources_ = options.sources;\n\n    /**\n     * @type {SourceType|null}\n     * @private\n     */\n    this.renderedSource_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = style;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    return this.sources_\n      ? typeof this.sources_ === 'function'\n        ? this.sources_(extent, resolution)\n        : this.sources_\n      : source\n      ? [source]\n      : [];\n  }\n\n  /**\n   * @return {SourceType} The source being rendered.\n   */\n  getRenderSource() {\n    return this.renderedSource_ || this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getRenderSource();\n    return source ? source.getState() : 'undefined';\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.getSource()) {\n      this.setStyle(this.style_);\n    }\n  }\n\n  /**\n   * @private\n   * @return {number} The number of source bands.\n   */\n  getSourceBandCount_() {\n    const max = Number.MAX_SAFE_INTEGER;\n    const sources = this.getSources([-max, -max, max, max], max);\n    return sources && sources.length && 'bandCount' in sources[0]\n      ? sources[0].bandCount\n      : 4;\n  }\n\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.cacheSize_,\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n  }\n\n  /**\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\n   * @param {Array<SourceType>} sources Sources.\n   * @return {HTMLElement} Canvas.\n   */\n  renderSources(frameState, sources) {\n    const layerRenderer = this.getRenderer();\n    let canvas;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      this.renderedSource_ = sources[i];\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    this.rendered = true;\n    const viewState = frameState.viewState;\n    const sources = this.getSources(frameState.extent, viewState.resolution);\n    let ready = true;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      const source = sources[i];\n      const sourceState = source.getState();\n      if (sourceState == 'loading') {\n        const onChange = () => {\n          if (source.getState() == 'ready') {\n            source.removeEventListener('change', onChange);\n            this.changed();\n          }\n        };\n        source.addEventListener('change', onChange);\n      }\n      ready = ready && sourceState == 'ready';\n    }\n    const canvas = this.renderSources(frameState, sources);\n    if (this.getRenderer().renderComplete && ready) {\n      // Fully rendered, done.\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    }\n    // Render sources from previously fully rendered frames\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      const altSources = this.getSources(\n        frameState.extent,\n        this.renderedResolution_\n      ).filter((source) => !sources.includes(source));\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\n   * this method may be called instead.  Note that calling this method will also replace\n   * any previously set variables, so the new style also needs to include new variables,\n   * if needed.\n   * @param {Style} style The new style.\n   */\n  setStyle(style) {\n    this.styleVariables_ = style.variables || {};\n    this.style_ = style;\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    const renderer = this.getRenderer();\n    renderer.reset({\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\nWebGLTileLayer.prototype.dispose;\n\nexport default WebGLTileLayer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}