{"ast":null,"code":"/**\n * @module ol/geom/MultiLineString\n */\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\n\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n      /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */\n      coordinates, layout);\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(layout,\n      /** @type {Array<number>} */\n      coordinates);\n      this.ends_ = ends;\n    } else {\n      let layout = this.getLayout();\n      const lineStrings =\n      /** @type {Array<LineString>} */\n      coordinates;\n      const flatCoordinates = [];\n      const ends = [];\n\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n\n\n  appendLineString(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n\n\n  clone() {\n    const multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  }\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n\n\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) {\n      return null;\n    }\n\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n  }\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n\n\n  getCoordinates() {\n    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n  }\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  getEnds() {\n    return this.ends_;\n  }\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n\n\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  }\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n\n\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n\n    const lineStrings = [];\n    let offset = 0;\n\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n\n    return lineStrings;\n  }\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  getFlatMidpoints() {\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n\n    return midpoints;\n  }\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n\n\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n\n\n  getType() {\n    return 'MultiLineString';\n  }\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  }\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n\n\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    const ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n\n}\n\nexport default MultiLineString;","map":{"version":3,"names":["LineString","SimpleGeometry","arrayMaxSquaredDelta","assignClosestArrayPoint","closestSquaredDistanceXY","deflateCoordinatesArray","douglasPeuckerArray","extend","inflateCoordinatesArray","interpolatePoint","lineStringsCoordinateAtM","intersectsLineStringArray","MultiLineString","constructor","coordinates","layout","ends","ends_","maxDelta_","maxDeltaRevision_","Array","isArray","setCoordinates","undefined","setFlatCoordinates","getLayout","lineStrings","flatCoordinates","i","ii","length","lineString","getFlatCoordinates","push","appendLineString","slice","changed","clone","multiLineString","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getCoordinateAtM","m","extrapolate","interpolate","getCoordinates","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","getType","intersectsExtent","extent","setLayout"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/geom/MultiLineString.js"],"sourcesContent":["/**\n * @module ol/geom/MultiLineString\n */\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = ends;\n    } else {\n      let layout = this.getLayout();\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}