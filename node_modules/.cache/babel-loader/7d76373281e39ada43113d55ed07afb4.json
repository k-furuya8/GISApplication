{"ast":null,"code":"/**\n * @module ol/interaction/DragAndDrop\n */\n// FIXME should handle all geo-referenced data, not just vector data\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Interaction from './Interaction.js';\nimport { TRUE } from '../functions.js';\nimport { get as getProjection, getUserProjection } from '../proj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Options\n * @property {Array<typeof import(\"../format/Feature.js\").default|import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors\n * (and/or formats pre-constructed with options).\n * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\n * all existing features will be removed and new features will be added when\n * they are dropped on the target.  If you want to add features to a vector\n * source without removing the existing features (append only), instead of\n * providing the source option listen for the \"addfeatures\" event.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\n */\n\n/**\n * @enum {string}\n */\n\nconst DragAndDropEventType = {\n  /**\n   * Triggered when features are added\n   * @event DragAndDropEvent#addfeatures\n   * @api\n   */\n  ADD_FEATURES: 'addfeatures'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n * of this type.\n */\n\nexport class DragAndDropEvent extends Event {\n  /**\n   * @param {DragAndDropEventType} type Type.\n   * @param {File} file File.\n   * @param {Array<import(\"../Feature.js\").default>} [features] Features.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   */\n  constructor(type, file, features, projection) {\n    super(type);\n    /**\n     * The features parsed from dropped data.\n     * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\n     * @api\n     */\n\n    this.features = features;\n    /**\n     * The dropped file.\n     * @type {File}\n     * @api\n     */\n\n    this.file = file;\n    /**\n     * The feature projection.\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     * @api\n     */\n\n    this.projection = projection;\n  }\n\n}\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'addfeatures', DragAndDropEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature\n */\n\n/**\n * @classdesc\n * Handles input of vector data by drag and drop.\n *\n * @api\n *\n * @fires DragAndDropEvent\n */\n\nclass DragAndDrop extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      handleEvent: TRUE\n    });\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.on;\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.once;\n    /***\n     * @type {DragAndDropOnSignature<void>}\n     */\n\n    this.un;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.readAsBuffer_ = false;\n    /**\n     * @private\n     * @type {Array<import(\"../format/Feature.js\").default>}\n     */\n\n    this.formats_ = [];\n    const formatConstructors = options.formatConstructors ? options.formatConstructors : [];\n\n    for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\n      let format = formatConstructors[i];\n\n      if (typeof format === 'function') {\n        format = new format();\n      }\n\n      this.formats_.push(format);\n      this.readAsBuffer_ = this.readAsBuffer_ || format.getType() === 'arraybuffer';\n    }\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n\n    this.projection_ = options.projection ? getProjection(options.projection) : null;\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    this.dropListenKeys_ = null;\n    /**\n     * @private\n     * @type {import(\"../source/Vector.js\").default}\n     */\n\n    this.source_ = options.source || null;\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n\n    this.target = options.target ? options.target : null;\n  }\n  /**\n   * @param {File} file File.\n   * @param {Event} event Load event.\n   * @private\n   */\n\n\n  handleResult_(file, event) {\n    const result = event.target.result;\n    const map = this.getMap();\n    let projection = this.projection_;\n\n    if (!projection) {\n      projection = getUserProjection();\n\n      if (!projection) {\n        const view = map.getView();\n        projection = view.getProjection();\n      }\n    }\n\n    let text;\n    const formats = this.formats_;\n\n    for (let i = 0, ii = formats.length; i < ii; ++i) {\n      const format = formats[i];\n      let input = result;\n\n      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {\n        if (text === undefined) {\n          text = new TextDecoder().decode(result);\n        }\n\n        input = text;\n      }\n\n      const features = this.tryReadFeatures_(format, input, {\n        featureProjection: projection\n      });\n\n      if (features && features.length > 0) {\n        if (this.source_) {\n          this.source_.clear();\n          this.source_.addFeatures(features);\n        }\n\n        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));\n        break;\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  registerListeners_() {\n    const map = this.getMap();\n\n    if (map) {\n      const dropArea = this.target ? this.target : map.getViewport();\n      this.dropListenKeys_ = [listen(dropArea, EventType.DROP, this.handleDrop, this), listen(dropArea, EventType.DRAGENTER, this.handleStop, this), listen(dropArea, EventType.DRAGOVER, this.handleStop, this), listen(dropArea, EventType.DROP, this.handleStop, this)];\n    }\n  }\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n\n\n  setActive(active) {\n    if (!this.getActive() && active) {\n      this.registerListeners_();\n    }\n\n    if (this.getActive() && !active) {\n      this.unregisterListeners_();\n    }\n\n    super.setActive(active);\n  }\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n\n\n  setMap(map) {\n    this.unregisterListeners_();\n    super.setMap(map);\n\n    if (this.getActive()) {\n      this.registerListeners_();\n    }\n  }\n  /**\n   * @param {import(\"../format/Feature.js\").default} format Format.\n   * @param {string} text Text.\n   * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\n   * @private\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n\n\n  tryReadFeatures_(format, text, options) {\n    try {\n      return (\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        format.readFeatures(text, options)\n      );\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  unregisterListeners_() {\n    if (this.dropListenKeys_) {\n      this.dropListenKeys_.forEach(unlistenByKey);\n      this.dropListenKeys_ = null;\n    }\n  }\n  /**\n   * @param {DragEvent} event Event.\n   */\n\n\n  handleDrop(event) {\n    const files = event.dataTransfer.files;\n\n    for (let i = 0, ii = files.length; i < ii; ++i) {\n      const file = files.item(i);\n      const reader = new FileReader();\n      reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));\n\n      if (this.readAsBuffer_) {\n        reader.readAsArrayBuffer(file);\n      } else {\n        reader.readAsText(file);\n      }\n    }\n  }\n  /**\n   * @param {DragEvent} event Event.\n   */\n\n\n  handleStop(event) {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n  }\n\n}\n\nexport default DragAndDrop;","map":{"version":3,"names":["Event","EventType","Interaction","TRUE","get","getProjection","getUserProjection","listen","unlistenByKey","DragAndDropEventType","ADD_FEATURES","DragAndDropEvent","constructor","type","file","features","projection","DragAndDrop","options","handleEvent","on","once","un","readAsBuffer_","formats_","formatConstructors","i","ii","length","format","push","getType","projection_","dropListenKeys_","source_","source","target","handleResult_","event","result","map","getMap","view","getView","text","formats","input","undefined","TextDecoder","decode","tryReadFeatures_","featureProjection","clear","addFeatures","dispatchEvent","registerListeners_","dropArea","getViewport","DROP","handleDrop","DRAGENTER","handleStop","DRAGOVER","setActive","active","getActive","unregisterListeners_","setMap","readFeatures","e","forEach","files","dataTransfer","item","reader","FileReader","addEventListener","LOAD","bind","readAsArrayBuffer","readAsText","stopPropagation","preventDefault","dropEffect"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/interaction/DragAndDrop.js"],"sourcesContent":["/**\n * @module ol/interaction/DragAndDrop\n */\n// FIXME should handle all geo-referenced data, not just vector data\n\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Interaction from './Interaction.js';\nimport {TRUE} from '../functions.js';\nimport {get as getProjection, getUserProjection} from '../proj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<typeof import(\"../format/Feature.js\").default|import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors\n * (and/or formats pre-constructed with options).\n * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\n * all existing features will be removed and new features will be added when\n * they are dropped on the target.  If you want to add features to a vector\n * source without removing the existing features (append only), instead of\n * providing the source option listen for the \"addfeatures\" event.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\n */\n\n/**\n * @enum {string}\n */\nconst DragAndDropEventType = {\n  /**\n   * Triggered when features are added\n   * @event DragAndDropEvent#addfeatures\n   * @api\n   */\n  ADD_FEATURES: 'addfeatures',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n * of this type.\n */\nexport class DragAndDropEvent extends Event {\n  /**\n   * @param {DragAndDropEventType} type Type.\n   * @param {File} file File.\n   * @param {Array<import(\"../Feature.js\").default>} [features] Features.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   */\n  constructor(type, file, features, projection) {\n    super(type);\n\n    /**\n     * The features parsed from dropped data.\n     * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The dropped file.\n     * @type {File}\n     * @api\n     */\n    this.file = file;\n\n    /**\n     * The feature projection.\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     * @api\n     */\n    this.projection = projection;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'addfeatures', DragAndDropEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature\n */\n\n/**\n * @classdesc\n * Handles input of vector data by drag and drop.\n *\n * @api\n *\n * @fires DragAndDropEvent\n */\nclass DragAndDrop extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      handleEvent: TRUE,\n    });\n\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragAndDropOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.readAsBuffer_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../format/Feature.js\").default>}\n     */\n    this.formats_ = [];\n    const formatConstructors = options.formatConstructors\n      ? options.formatConstructors\n      : [];\n    for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\n      let format = formatConstructors[i];\n      if (typeof format === 'function') {\n        format = new format();\n      }\n      this.formats_.push(format);\n      this.readAsBuffer_ =\n        this.readAsBuffer_ || format.getType() === 'arraybuffer';\n    }\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = options.projection\n      ? getProjection(options.projection)\n      : null;\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.dropListenKeys_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../source/Vector.js\").default}\n     */\n    this.source_ = options.source || null;\n\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    this.target = options.target ? options.target : null;\n  }\n\n  /**\n   * @param {File} file File.\n   * @param {Event} event Load event.\n   * @private\n   */\n  handleResult_(file, event) {\n    const result = event.target.result;\n    const map = this.getMap();\n    let projection = this.projection_;\n    if (!projection) {\n      projection = getUserProjection();\n      if (!projection) {\n        const view = map.getView();\n        projection = view.getProjection();\n      }\n    }\n\n    let text;\n    const formats = this.formats_;\n    for (let i = 0, ii = formats.length; i < ii; ++i) {\n      const format = formats[i];\n      let input = result;\n      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {\n        if (text === undefined) {\n          text = new TextDecoder().decode(result);\n        }\n        input = text;\n      }\n      const features = this.tryReadFeatures_(format, input, {\n        featureProjection: projection,\n      });\n      if (features && features.length > 0) {\n        if (this.source_) {\n          this.source_.clear();\n          this.source_.addFeatures(features);\n        }\n        this.dispatchEvent(\n          new DragAndDropEvent(\n            DragAndDropEventType.ADD_FEATURES,\n            file,\n            features,\n            projection\n          )\n        );\n        break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  registerListeners_() {\n    const map = this.getMap();\n    if (map) {\n      const dropArea = this.target ? this.target : map.getViewport();\n      this.dropListenKeys_ = [\n        listen(dropArea, EventType.DROP, this.handleDrop, this),\n        listen(dropArea, EventType.DRAGENTER, this.handleStop, this),\n        listen(dropArea, EventType.DRAGOVER, this.handleStop, this),\n        listen(dropArea, EventType.DROP, this.handleStop, this),\n      ];\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    if (!this.getActive() && active) {\n      this.registerListeners_();\n    }\n    if (this.getActive() && !active) {\n      this.unregisterListeners_();\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.unregisterListeners_();\n    super.setMap(map);\n    if (this.getActive()) {\n      this.registerListeners_();\n    }\n  }\n\n  /**\n   * @param {import(\"../format/Feature.js\").default} format Format.\n   * @param {string} text Text.\n   * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\n   * @private\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  tryReadFeatures_(format, text, options) {\n    try {\n      return (\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        (format.readFeatures(text, options))\n      );\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * @private\n   */\n  unregisterListeners_() {\n    if (this.dropListenKeys_) {\n      this.dropListenKeys_.forEach(unlistenByKey);\n      this.dropListenKeys_ = null;\n    }\n  }\n\n  /**\n   * @param {DragEvent} event Event.\n   */\n  handleDrop(event) {\n    const files = event.dataTransfer.files;\n    for (let i = 0, ii = files.length; i < ii; ++i) {\n      const file = files.item(i);\n      const reader = new FileReader();\n      reader.addEventListener(\n        EventType.LOAD,\n        this.handleResult_.bind(this, file)\n      );\n      if (this.readAsBuffer_) {\n        reader.readAsArrayBuffer(file);\n      } else {\n        reader.readAsText(file);\n      }\n    }\n  }\n\n  /**\n   * @param {DragEvent} event Event.\n   */\n  handleStop(event) {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n  }\n}\n\nexport default DragAndDrop;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}