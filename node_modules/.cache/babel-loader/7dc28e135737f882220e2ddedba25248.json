{"ast":null,"code":"function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n\n    count -= stride;\n  }\n\n  const copy = row.slice();\n\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[bytesPerSample * i + b] = copy[(bytesPerSample - b - 1) * wc + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n\n    let row;\n\n    if (predictor === 2) {\n      // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n          break;\n\n        case 16:\n          row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n          break;\n\n        case 32:\n          row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n          break;\n\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) {\n      // horizontal floating point\n      row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n\n  return block;\n}","map":{"version":3,"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/predictor.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}