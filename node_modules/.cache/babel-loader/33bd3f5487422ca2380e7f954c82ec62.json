{"ast":null,"code":"/**\n * @module ol/render/canvas/TextBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction from './Instruction.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { defaultFillStyle, defaultFont, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultPadding, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, registerFont } from '../canvas.js';\nimport { getUid } from '../../util.js';\nimport { intersects } from '../../extent.js';\nimport { matchingChunk } from '../../geom/flat/straightchunk.js';\n/**\n * @const\n * @enum {number}\n */\n\nexport const TEXT_ALIGN = {\n  'left': 0,\n  'end': 0,\n  'center': 0.5,\n  'right': 1,\n  'start': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1\n};\n\nclass CanvasTextBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n\n    this.labels_ = null;\n    /**\n     * @private\n     * @type {string|Array<string>}\n     */\n\n    this.text_ = '';\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetY_ = 0;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n\n    this.textRotateWithView_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textRotation_ = 0;\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n\n    this.textFillState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = {};\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n\n    this.textStrokeState_ = null;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = {};\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n\n    this.textState_ =\n    /** @type {import(\"../canvas.js\").TextState} */\n    {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.textKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.fillKey_ = '';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.strokeKey_ = '';\n    /**\n     * Data shared with an image builder for combined decluttering.\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterImageWithText}\n     */\n\n    this.declutterImageWithText_ = undefined;\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    const instructions = super.finish();\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  }\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  drawText(geometry, feature) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n\n    if (this.text_ === '' || !textState || !fillState && !strokeState) {\n      return;\n    }\n\n    const coordinates = this.coordinates;\n    let begin = coordinates.length;\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let stride = geometry.getStride();\n\n    if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n\n      if (geometryType == 'LineString') {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == 'MultiLineString') {\n        ends =\n        /** @type {import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds();\n      } else if (geometryType == 'Polygon') {\n        ends =\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getEnds().slice(0, 1);\n      } else if (geometryType == 'MultiPolygon') {\n        const endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        ends = [];\n\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n\n      this.beginGeometry(geometry, feature);\n      const textAlign = textState.textAlign; // No `justify` support for line placement.\n\n      let flatOffset = 0;\n      let flatEnd;\n\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          const range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n\n        for (let i = flatOffset; i < flatEnd; i += stride) {\n          coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n\n        const end = coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end);\n        begin = end;\n      }\n\n      this.endGeometry(feature);\n    } else {\n      let geometryWidths = textState.overflow ? null : [];\n\n      switch (geometryType) {\n        case 'Point':\n        case 'MultiPoint':\n          flatCoordinates =\n          /** @type {import(\"../../geom/MultiPoint.js\").default} */\n          geometry.getFlatCoordinates();\n          break;\n\n        case 'LineString':\n          flatCoordinates =\n          /** @type {import(\"../../geom/LineString.js\").default} */\n          geometry.getFlatMidpoint();\n          break;\n\n        case 'Circle':\n          flatCoordinates =\n          /** @type {import(\"../../geom/Circle.js\").default} */\n          geometry.getCenter();\n          break;\n\n        case 'MultiLineString':\n          flatCoordinates =\n          /** @type {import(\"../../geom/MultiLineString.js\").default} */\n          geometry.getFlatMidpoints();\n          stride = 2;\n          break;\n\n        case 'Polygon':\n          flatCoordinates =\n          /** @type {import(\"../../geom/Polygon.js\").default} */\n          geometry.getFlatInteriorPoint();\n\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n\n          stride = 3;\n          break;\n\n        case 'MultiPolygon':\n          const interiorPoints =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n          geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n\n          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i + 2] / this.resolution);\n            }\n\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n          }\n\n          if (flatCoordinates.length === 0) {\n            return;\n          }\n\n          stride = 2;\n          break;\n\n        default:\n      }\n\n      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n      if (end === begin) {\n        return;\n      }\n\n      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {\n        let beg = begin / 2;\n        geometryWidths = geometryWidths.filter((w, i) => {\n          const keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];\n\n          if (!keep) {\n            --beg;\n          }\n\n          return keep;\n        });\n      }\n\n      this.saveTextStates_();\n\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n          this.hitDetectionInstructions.push(this.createFill(this.state));\n        }\n\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n\n      this.beginGeometry(geometry, feature); // adjust padding for negative scale\n\n      let padding = textState.padding;\n\n      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {\n        let p0 = textState.padding[0];\n        let p1 = textState.padding[1];\n        let p2 = textState.padding[2];\n        let p3 = textState.padding[3];\n\n        if (textState.scale[0] < 0) {\n          p1 = -p1;\n          p3 = -p3;\n        }\n\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p2 = -p2;\n        }\n\n        padding = [p0, p1, p2, p3];\n      } // The image is unknown at this stage so we pass null; it will be computed at render time.\n      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n      // render time.\n\n\n      const pixelRatio = this.pixelRatio;\n      this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, undefined, this.declutterImageWithText_, padding == defaultPadding ? defaultPadding : padding.map(function (p) {\n        return p * pixelRatio;\n      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n      const scale = 1 / pixelRatio;\n      this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, undefined, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n      this.endGeometry(feature);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  saveTextStates_() {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n    const strokeKey = this.strokeKey_;\n\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n\n    const textKey = this.textKey_;\n\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        justify: textState.justify,\n        textBaseline: textState.textBaseline || defaultTextBaseline,\n        scale: textState.scale\n      };\n    }\n\n    const fillKey = this.fillKey_;\n\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n\n\n  drawChars_(begin, end) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const strokeKey = this.strokeKey_;\n    const textKey = this.textKey_;\n    const fillKey = this.fillKey_;\n    this.saveTextStates_();\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;\n    this.instructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n  }\n  /**\n   * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n   * @param {Object} [sharedData] Shared data.\n   */\n\n\n  setTextStyle(textStyle, sharedData) {\n    let textState, fillState, strokeState;\n\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      const textFillStyle = textStyle.getFill();\n\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n\n        if (!fillState) {\n          fillState =\n          /** @type {import(\"../canvas.js\").FillState} */\n          {};\n          this.textFillState_ = fillState;\n        }\n\n        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n\n        if (!strokeState) {\n          strokeState =\n          /** @type {import(\"../canvas.js\").StrokeState} */\n          {};\n          this.textStrokeState_ = strokeState;\n        }\n\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      registerFont(font);\n      const textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.justify = textStyle.getJustify();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? [1, 1] : textScale;\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.justify || '?') + (textState.textBaseline || '?');\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n    }\n\n    this.declutterImageWithText_ = sharedData;\n  }\n\n}\n\nexport default CanvasTextBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","asColorLike","defaultFillStyle","defaultFont","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultPadding","defaultStrokeStyle","defaultTextAlign","defaultTextBaseline","registerFont","getUid","intersects","matchingChunk","TEXT_ALIGN","CanvasTextBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","labels_","text_","textOffsetX_","textOffsetY_","textRotateWithView_","undefined","textRotation_","textFillState_","fillStates","textStrokeState_","strokeStates","textState_","textStates","textKey_","fillKey_","strokeKey_","declutterImageWithText_","finish","instructions","drawText","geometry","feature","fillState","strokeState","textState","coordinates","begin","length","geometryType","getType","flatCoordinates","stride","getStride","placement","getBufferedMaxExtent","getExtent","ends","getFlatCoordinates","getEnds","slice","endss","getEndss","i","ii","push","beginGeometry","textAlign","flatOffset","flatEnd","o","oo","range","maxAngle","end","drawChars_","endGeometry","geometryWidths","overflow","getFlatMidpoint","getCenter","getFlatMidpoints","getFlatInteriorPoint","interiorPoints","getFlatInteriorPoints","appendFlatPointCoordinates","beg","filter","w","keep","saveTextStates_","backgroundFill","backgroundStroke","setFillStrokeStyle","updateFillStyle","state","createFill","hitDetectionInstructions","updateStrokeStyle","applyStroke","createStroke","padding","scale","p0","p1","p2","p3","DRAW_IMAGE","NaN","map","p","strokeKey","strokeStyle","lineCap","lineDashOffset","lineWidth","lineJoin","miterLimit","lineDash","textKey","font","justify","textBaseline","fillKey","fillStyle","baseline","offsetY","text","strokeWidth","Math","abs","DRAW_CHARS","setTextStyle","textStyle","sharedData","textFillStyle","getFill","getColor","textStrokeStyle","getStroke","getLineDash","getLineDashOffset","getWidth","getMiterLimit","getLineCap","getLineJoin","getFont","textScale","getScaleArray","getOverflow","getMaxAngle","getPlacement","getTextAlign","getJustify","getTextBaseline","getBackgroundFill","getBackgroundStroke","getPadding","textOffsetX","getOffsetX","textOffsetY","getOffsetY","textRotateWithView","getRotateWithView","textRotation","getRotation","getText","join"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/canvas/TextBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/TextBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction from './Instruction.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {\n  defaultFillStyle,\n  defaultFont,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultPadding,\n  defaultStrokeStyle,\n  defaultTextAlign,\n  defaultTextBaseline,\n  registerFont,\n} from '../canvas.js';\nimport {getUid} from '../../util.js';\nimport {intersects} from '../../extent.js';\nimport {matchingChunk} from '../../geom/flat/straightchunk.js';\n/**\n * @const\n * @enum {number}\n */\nexport const TEXT_ALIGN = {\n  'left': 0,\n  'end': 0,\n  'center': 0.5,\n  'right': 1,\n  'start': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1,\n};\n\nclass CanvasTextBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string|Array<string>}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */ ({});\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * Data shared with an image builder for combined decluttering.\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterImageWithText}\n     */\n    this.declutterImageWithText_ = undefined;\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    const instructions = super.finish();\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawText(geometry, feature) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\n      return;\n    }\n\n    const coordinates = this.coordinates;\n    let begin = coordinates.length;\n\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let stride = geometry.getStride();\n\n    if (\n      textState.placement === 'line' &&\n      (geometryType == 'LineString' ||\n        geometryType == 'MultiLineString' ||\n        geometryType == 'Polygon' ||\n        geometryType == 'MultiPolygon')\n    ) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      if (geometryType == 'LineString') {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == 'MultiLineString') {\n        ends = /** @type {import(\"../../geom/MultiLineString.js\").default} */ (\n          geometry\n        ).getEnds();\n      } else if (geometryType == 'Polygon') {\n        ends = /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry)\n          .getEnds()\n          .slice(0, 1);\n      } else if (geometryType == 'MultiPolygon') {\n        const endss =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getEndss();\n        ends = [];\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      const textAlign = textState.textAlign;\n      // No `justify` support for line placement.\n      let flatOffset = 0;\n      let flatEnd;\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          const range = matchingChunk(\n            textState.maxAngle,\n            flatCoordinates,\n            flatOffset,\n            ends[o],\n            stride\n          );\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (let i = flatOffset; i < flatEnd; i += stride) {\n          coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        const end = coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end);\n        begin = end;\n      }\n      this.endGeometry(feature);\n    } else {\n      let geometryWidths = textState.overflow ? null : [];\n      switch (geometryType) {\n        case 'Point':\n        case 'MultiPoint':\n          flatCoordinates =\n            /** @type {import(\"../../geom/MultiPoint.js\").default} */ (\n              geometry\n            ).getFlatCoordinates();\n          break;\n        case 'LineString':\n          flatCoordinates =\n            /** @type {import(\"../../geom/LineString.js\").default} */ (\n              geometry\n            ).getFlatMidpoint();\n          break;\n        case 'Circle':\n          flatCoordinates =\n            /** @type {import(\"../../geom/Circle.js\").default} */ (\n              geometry\n            ).getCenter();\n          break;\n        case 'MultiLineString':\n          flatCoordinates =\n            /** @type {import(\"../../geom/MultiLineString.js\").default} */ (\n              geometry\n            ).getFlatMidpoints();\n          stride = 2;\n          break;\n        case 'Polygon':\n          flatCoordinates =\n            /** @type {import(\"../../geom/Polygon.js\").default} */ (\n              geometry\n            ).getFlatInteriorPoint();\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n          stride = 3;\n          break;\n        case 'MultiPolygon':\n          const interiorPoints =\n            /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n              geometry\n            ).getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i + 2] / this.resolution);\n            }\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n          }\n          if (flatCoordinates.length === 0) {\n            return;\n          }\n          stride = 2;\n          break;\n        default:\n      }\n      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n      if (end === begin) {\n        return;\n      }\n      if (\n        geometryWidths &&\n        (end - begin) / 2 !== flatCoordinates.length / stride\n      ) {\n        let beg = begin / 2;\n        geometryWidths = geometryWidths.filter((w, i) => {\n          const keep =\n            coordinates[(beg + i) * 2] === flatCoordinates[i * stride] &&\n            coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];\n          if (!keep) {\n            --beg;\n          }\n          return keep;\n        });\n      }\n\n      this.saveTextStates_();\n\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(\n          textState.backgroundFill,\n          textState.backgroundStroke\n        );\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n          this.hitDetectionInstructions.push(this.createFill(this.state));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n\n      this.beginGeometry(geometry, feature);\n\n      // adjust padding for negative scale\n      let padding = textState.padding;\n      if (\n        padding != defaultPadding &&\n        (textState.scale[0] < 0 || textState.scale[1] < 0)\n      ) {\n        let p0 = textState.padding[0];\n        let p1 = textState.padding[1];\n        let p2 = textState.padding[2];\n        let p3 = textState.padding[3];\n        if (textState.scale[0] < 0) {\n          p1 = -p1;\n          p3 = -p3;\n        }\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p2 = -p2;\n        }\n        padding = [p0, p1, p2, p3];\n      }\n\n      // The image is unknown at this stage so we pass null; it will be computed at render time.\n      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n      // render time.\n      const pixelRatio = this.pixelRatio;\n      this.instructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [1, 1],\n        NaN,\n        undefined,\n        this.declutterImageWithText_,\n        padding == defaultPadding\n          ? defaultPadding\n          : padding.map(function (p) {\n              return p * pixelRatio;\n            }),\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths,\n      ]);\n      const scale = 1 / pixelRatio;\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [scale, scale],\n        NaN,\n        undefined,\n        this.declutterImageWithText_,\n        padding,\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths,\n      ]);\n\n      this.endGeometry(feature);\n    }\n  }\n\n  /**\n   * @private\n   */\n  saveTextStates_() {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n\n    const strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash,\n        };\n      }\n    }\n    const textKey = this.textKey_;\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        justify: textState.justify,\n        textBaseline: textState.textBaseline || defaultTextBaseline,\n        scale: textState.scale,\n      };\n    }\n    const fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle,\n        };\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  drawChars_(begin, end) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n\n    const strokeKey = this.strokeKey_;\n    const textKey = this.textKey_;\n    const fillKey = this.fillKey_;\n    this.saveTextStates_();\n\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const strokeWidth = strokeState\n      ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2\n      : 0;\n\n    this.instructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey,\n      textState.maxAngle,\n      pixelRatio,\n      offsetY,\n      strokeKey,\n      strokeWidth * pixelRatio,\n      text,\n      textKey,\n      1,\n    ]);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey,\n      textState.maxAngle,\n      1,\n      offsetY,\n      strokeKey,\n      strokeWidth,\n      text,\n      textKey,\n      1 / pixelRatio,\n    ]);\n  }\n\n  /**\n   * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n   * @param {Object} [sharedData] Shared data.\n   */\n  setTextStyle(textStyle, sharedData) {\n    let textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      const textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = /** @type {import(\"../canvas.js\").FillState} */ ({});\n          this.textFillState_ = fillState;\n        }\n        fillState.fillStyle = asColorLike(\n          textFillStyle.getColor() || defaultFillStyle\n        );\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = /** @type {import(\"../canvas.js\").StrokeState} */ ({});\n          this.textStrokeState_ = strokeState;\n        }\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset =\n          lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth =\n          lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit =\n          miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(\n          textStrokeStyle.getColor() || defaultStrokeStyle\n        );\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      registerFont(font);\n      const textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.justify = textStyle.getJustify();\n      textState.textBaseline =\n        textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? [1, 1] : textScale;\n\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ =\n        textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n\n      this.strokeKey_ = strokeState\n        ? (typeof strokeState.strokeStyle == 'string'\n            ? strokeState.strokeStyle\n            : getUid(strokeState.strokeStyle)) +\n          strokeState.lineCap +\n          strokeState.lineDashOffset +\n          '|' +\n          strokeState.lineWidth +\n          strokeState.lineJoin +\n          strokeState.miterLimit +\n          '[' +\n          strokeState.lineDash.join() +\n          ']'\n        : '';\n      this.textKey_ =\n        textState.font +\n        textState.scale +\n        (textState.textAlign || '?') +\n        (textState.justify || '?') +\n        (textState.textBaseline || '?');\n      this.fillKey_ = fillState\n        ? typeof fillState.fillStyle == 'string'\n          ? fillState.fillStyle\n          : '|' + getUid(fillState.fillStyle)\n        : '';\n    }\n    this.declutterImageWithText_ = sharedData;\n  }\n}\n\nexport default CanvasTextBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}