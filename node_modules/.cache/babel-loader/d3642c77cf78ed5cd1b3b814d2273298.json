{"ast":null,"code":"/**\n * @module ol/tilegrid/WMTS\n */\nimport TileGrid from './TileGrid.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\n\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    });\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n\n    this.matrixIds_ = options.matrixIds;\n  }\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n\n\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n\n\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n\n}\n\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\n\nexport function createFromCapabilitiesMatrixSet(matrixSet, extent, matrixLimits) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n\n  const sizes = [];\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit(); // swap origin x and y coordinates if axis orientation is lat/long\n\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable; // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        } // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n\n\n        if (!elt[identifierPropName].includes(':')) {\n          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];\n        }\n\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n\n      if (switchOriginXY) {\n        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n\n      resolutions.push(resolution);\n      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes\n  });\n}","map":{"version":3,"names":["TileGrid","get","getProjection","WMTSTileGrid","constructor","options","extent","origin","origins","resolutions","tileSize","tileSizes","sizes","matrixIds_","matrixIds","getMatrixId","z","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","undefined","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","projection","metersPerUnit","getMetersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","b","forEach","elt","matrixAvailable","length","find","elt_ml","includes","push","resolution","tileWidth","tileHeight"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/tilegrid/WMTS.js"],"sourcesContent":["/**\n * @module ol/tilegrid/WMTS\n */\n\nimport TileGrid from './TileGrid.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}