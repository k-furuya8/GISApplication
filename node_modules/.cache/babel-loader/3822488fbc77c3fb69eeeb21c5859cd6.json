{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\n\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': []\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\n\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default']\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\n\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n    /** @private */\n\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n\n    this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedRotation_;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.tmpTransform_ = createTransform();\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n\n\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n\n    return render;\n  }\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n\n    const render = this.prepareTile(tile, pixelRatio, projection);\n\n    if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== 'vector') {\n      this.renderTileImage_(tile, frameState);\n    }\n\n    return super.getTile(z, x, y, frameState);\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return super.isDrawableTile(tile) && (layer.getRenderMode() === 'vector' ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n\n    return super.prepareFrame(frameState);\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n\n    builderState.dirty = false;\n\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n      const declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      const render = function (feature) {\n        let styles;\n        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          const dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this, feature);\n        }\n      }\n\n      const executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile\n\n      const replayExtent = layer.getRenderMode() !== 'vector' && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n\n    const features = {};\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n\n      const match = features[key];\n\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n\n        matches.push(features[key] = {\n          feature: feature,\n          layer: layer,\n          geometry: geometry,\n          distanceSq: distanceSq,\n          callback: callback\n        });\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n\n      return undefined;\n    };\n\n    const renderedTiles =\n    /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    let found;\n\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n\n      executorGroups.some(executorGroups => {\n        const declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(item => item.value) : null;\n\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n\n    return found;\n  }\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n\n\n  getFeatures(pixel) {\n    return new Promise(function (resolve, reject) {\n      const layer =\n      /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      let tile;\n\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n              wrapX(coordinate, projection);\n            }\n\n            break;\n          }\n\n          tile = undefined;\n        }\n      }\n\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      const features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        const tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));\n        const rotation = this.renderedRotation_;\n        const transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  }\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n\n\n  handleFontsChanged() {\n    const layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    const tiles =\n    /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n        }\n      }\n    }\n\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n    return transform;\n  }\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    const layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile =\n      /** @type {import(\"../../VectorRenderTile.js\").default} */\n      tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(group => group.hasExecutors(replayTypes));\n\n      if (executorGroups.length === 0) {\n        continue;\n      }\n\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false; // Clip mask for regions in this tile that already filled by a higher z tile\n\n      const currentClip = executorGroups[0].getClipCoords(transform);\n\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n\n            if (intersects([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n\n              context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile\n\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n      }\n\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    super.postRender(context, frameState);\n  }\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    let loading = false;\n\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup);\n    }\n\n    return loading;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n\n\n  tileImageNeedsRender_(tile) {\n    const layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  renderTileImage_(tile, frameState) {\n    const layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n\n    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n\n}\n\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"names":["CanvasBuilderGroup","CanvasExecutorGroup","CanvasTileLayerRenderer","TileState","ViewHint","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","apply","applyTransform","create","createTransform","multiply","reset","resetTransform","scale","scaleTransform","translate","translateTransform","boundingExtent","buffer","containsExtent","equals","getIntersection","getTopLeft","intersects","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","getUid","toSize","wrapX","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","constructor","layer","boundHandleStyleImageChange_","handleStyleImageChange_","bind","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","tmpTransform_","prepareTile","tile","pixelRatio","projection","render","state","getState","LOADED","ERROR","updateExecutorGroup_","tileImageNeedsRender_","getTile","z","x","y","frameState","viewState","resolution","getLayer","getSource","viewHints","hifi","ANIMATING","INTERACTING","wantedResolution","Date","now","time","getRenderMode","renderTileImage_","isDrawableTile","executorGroups","hasContext","getTileImage","getImage","prepareFrame","layerRevision","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","source","declutter","getDeclutter","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","t","tt","sourceTile","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","tmpExtent","bufferedExtent","builderGroup","declutterBuilderGroup","undefined","squaredTolerance","feature","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getGeometry","getExtent","call","executorGroupInstructions","finish","replayExtent","renderingReplayGroup","getOverlaps","push","declutterExecutorGroup","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","rotation","hitExtent","featureCallback","geometry","distanceSq","key","getId","match","splice","lastIndexOf","found","some","declutteredFeatures","declutterTree","all","map","item","value","executorGroup","pixel","Promise","resolve","reject","renderedProjection","projectionExtent","slice","getTileCoordForCoordAndResolution","toString","extent","getWrapX","canWrapX","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","animatingOrInteracting_","tileSize","getTileSize","getZForResolution","zDirection","transforms","getRenderTransform","getTileCoordCenter","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","context","alpha","globalAlpha","getOpacity","tiles","j","execute","getTileRenderTransform","center","size","width","Math","round","height","worldOffset","transform","inversePixelTransform","postRender","pixelToCoordinateTransform","renderMode","replayTypes","tileSource","clips","clipZs","ready","filter","group","hasExecutors","currentZ","contextSaved","currentClip","getClipCoords","jj","clip","save","beginPath","moveTo","lineTo","restore","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","tileResolution","getResolution","renderPixelRatio","getContext","max","getTilePixelSize","canvas","renderScale","canvasTransform","setTransform","pixelScale"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        builderExtent,\n        resolution,\n        pixelRatio\n      );\n      const declutterBuilderGroup = declutter\n        ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n        : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutterBuilderGroup\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(\n          null,\n          resolution,\n          pixelRatio,\n          source.getOverlaps(),\n          declutterBuilderGroup.finish(),\n          layer.getRenderBuffer()\n        );\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures =\n          executorGroups === declutterExecutorGroups\n            ? frameState.declutterTree.all().map((item) => item.value)\n            : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise(\n      function (resolve, reject) {\n        const layer =\n          /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n            this.getLayer()\n          );\n        const layerUid = getUid(layer);\n        const source = layer.getSource();\n        const projection = this.renderedProjection;\n        const projectionExtent = projection.getExtent();\n        const resolution = this.renderedResolution;\n        const tileGrid = source.getTileGridForProjection(projection);\n        const coordinate = applyTransform(\n          this.renderedPixelToCoordinateTransform_,\n          pixel.slice()\n        );\n        const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n          coordinate,\n          resolution\n        );\n        let tile;\n        for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n          if (\n            tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n          ) {\n            tile = this.renderedTiles[i];\n            if (tile.getState() === TileState.LOADED) {\n              const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n              if (\n                source.getWrapX() &&\n                projection.canWrapX() &&\n                !containsExtent(projectionExtent, extent)\n              ) {\n                wrapX(coordinate, projection);\n              }\n              break;\n            }\n            tile = undefined;\n          }\n        }\n        if (!tile || tile.loadingSourceTiles > 0) {\n          resolve([]);\n          return;\n        }\n        const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        const corner = getTopLeft(extent);\n        const tilePixel = [\n          (coordinate[0] - corner[0]) / resolution,\n          (corner[1] - coordinate[1]) / resolution,\n        ];\n        const features = tile\n          .getSourceTiles()\n          .reduce(function (accumulator, sourceTile) {\n            return accumulator.concat(sourceTile.getFeatures());\n          }, []);\n        let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n        if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n          const tileSize = toSize(\n            tileGrid.getTileSize(\n              tileGrid.getZForResolution(resolution, source.zDirection)\n            )\n          );\n          const rotation = this.renderedRotation_;\n          const transforms = [\n            this.getRenderTransform(\n              tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n              resolution,\n              0,\n              HIT_DETECT_RESOLUTION,\n              tileSize[0] * HIT_DETECT_RESOLUTION,\n              tileSize[1] * HIT_DETECT_RESOLUTION,\n              0\n            ),\n          ];\n          hitDetectionImageData = createHitDetectionImageData(\n            tileSize,\n            transforms,\n            features,\n            layer.getStyleFunction(),\n            tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n            tile.getReplayState(layer).renderedResolution,\n            rotation\n          );\n          tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n        }\n        resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups =\n        tile.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(\n            this.context,\n            1,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            undefined,\n            frameState.declutterTree\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset\n      )\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes)\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]]\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes\n        );\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio)\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}