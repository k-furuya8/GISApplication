{"ast":null,"code":"/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames); // config variables\n\nconst numBytesInIfd = 1000;\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map(i => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, i => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, i => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n >> 0 & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, i => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8)\n};\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, i => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n  const keys = Object.keys(ifd).filter(key => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n  let eoff = offset + 12 * keys.length + 4;\n\n  for (const key of keys) {\n    let tag = null;\n\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    } // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n\n\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n    bin.writeUint(data, offset, num);\n    offset += 4;\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, i => {\n        bin.writeUshort(data, toff + 2 * i, val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, i => {\n        bin.writeUint(data, toff + 4 * i, val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, i => {\n        bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + 8 * i + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, i => {\n        bin.writeDouble(data, toff + 8 * i, val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += dlen & 1;\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = ifds => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE; // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[0] = 77;\n  data[1] = 77; // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n\n  data[3] = 42;\n  let ifdo = 8;\n  bin.writeUint(data, offset, ifdo);\n  offset += 4;\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n\n    ifdo = noffs[1];\n\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  } // node hasn't implemented slice on Uint8Array yet\n\n\n  const result = new Uint8Array(ifdo);\n\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width],\n    // ImageWidth\n    257: [height],\n    // ImageLength\n    273: [numBytesInIfd],\n    // strips offset\n    278: [height],\n    // RowsPerStrip\n    305: 'geotiff.js' // no array for ASCII(Z)\n\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n  const img = new Uint8Array(values);\n  const samplesPerPixel = ifd[277];\n  const data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);\n  times(prfx.length, i => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n  return data.buffer;\n};\n\nconst convertToTids = input => {\n  const result = {};\n\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n\n      result[name2code[key]] = input[key];\n    }\n  }\n\n  return result;\n};\n\nconst toArray = input => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n\n  return [input];\n};\n\nconst metadataDefaults = [['Compression', 1], // no compression\n['PlanarConfiguration', 1], ['ExtraSamples', 0]];\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, rowIndex => {\n      times(width, columnIndex => {\n        times(numBands, bandIndex => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width; // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach(tag => {\n    const key = tag[0];\n\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  }); // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  } // The number of components per pixel.\n\n\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  } // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n\n\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata).filter(key => endsWith(key, 'GeoKey')).sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach(name => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach(geoKey => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  } // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n\n\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength', // synonym of ImageHeight\n  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition'].forEach(name => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n  const encodedMetadata = convertToTids(metadata);\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n  return outputImage;\n}","map":{"version":3,"names":["fieldTagNames","fieldTagTypes","fieldTypeNames","geoKeyNames","assign","endsWith","forEach","invert","times","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","data","o","oincr","readUshort","buff","p","readShort","a","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","map","i","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","n","writeUint","writeASCII","s","length","charCodeAt","Uint8Array","Float64Array","buffer","writeDouble","_writeIFD","bin","_offset","ifd","offset","keys","Object","filter","key","undefined","eoff","tag","parseInt","typeName","typeNum","Error","val","num","dlen","toff","Math","round","encodeIfds","ifds","ifdo","noffs","slice","result","encodeImage","values","width","height","metadata","hasOwnProperty","prfx","img","samplesPerPixel","value","convertToTids","input","console","error","toArray","Array","isArray","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","ImageLength","ImageWidth","rowIndex","columnIndex","bandIndex","push","BitsPerSample","PhotometricInterpretation","SamplesPerPixel","StripByteCounts","ModelPixelScale","SampleFormat","GeographicTypeGeoKey","ModelTiepoint","GeogCitationGeoKey","GTModelTypeGeoKey","geoKeys","sort","b","GeoAsciiParams","geoAsciiParams","name","code","Number","tagType","toString","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","log","encodedMetadata","outputImage"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/geotiffwriter.js"],"sourcesContent":["/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}