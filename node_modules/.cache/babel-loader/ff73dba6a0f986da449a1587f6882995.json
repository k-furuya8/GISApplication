{"ast":null,"code":"/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  let geoA = interpolate(0);\n  let geoB = interpolate(1);\n  let a = transform(geoA);\n  let b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  const geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  const stack = [b, a];\n  /** @type {Array<number>} */\n\n  const fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n\n  const fractions = {};\n  let maxIterations = 1e5;\n  let geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop(); // Add the a coordinate if it has not been added yet\n\n    key = fracA.toString();\n\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    } // Pop the b coordinate off the stack\n\n\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop(); // Find the m point between the a and b coordinates\n\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n\n    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\n\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  const geoProjection = getProjection('EPSG:4326');\n  const cosLat1 = Math.cos(toRadians(lat1));\n  const sinLat1 = Math.sin(toRadians(lat1));\n  const cosLat2 = Math.cos(toRadians(lat2));\n  const sinLat2 = Math.sin(toRadians(lat2));\n  const cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  const sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  const d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n\n    const D = frac * Math.acos(d);\n    const cosD = Math.cos(D);\n    const sinD = Math.sin(D);\n    const y = sinDeltaLon * cosLat2;\n    const x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    const theta = Math.atan2(y, x);\n    const lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    const lon = toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n  }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}","map":{"version":3,"names":["get","getProjection","getTransform","squaredSegmentDistance","toDegrees","toRadians","line","interpolate","transform","squaredTolerance","flatCoordinates","geoA","geoB","a","b","geoStack","stack","fractionStack","fractions","maxIterations","geoM","m","fracA","fracB","fracM","key","length","pop","toString","push","greatCircleArc","lon1","lat1","lon2","lat2","projection","geoProjection","cosLat1","Math","cos","sinLat1","sin","cosLat2","sinLat2","cosDeltaLon","sinDeltaLon","d","frac","D","acos","cosD","sinD","y","x","theta","atan2","lat","asin","lon","meridian","epsg4326Projection","parallel"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/geom/flat/geodesic.js"],"sourcesContent":["/**\n * @module ol/geom/flat/geodesic\n */\nimport {get as getProjection, getTransform} from '../../proj.js';\nimport {squaredSegmentDistance, toDegrees, toRadians} from '../../math.js';\n\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n\n  let geoA = interpolate(0);\n  let geoB = interpolate(1);\n\n  let a = transform(geoA);\n  let b = transform(geoB);\n\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const stack = [b, a];\n  /** @type {Array<number>} */\n  const fractionStack = [1, 0];\n\n  /** @type {!Object<string, boolean>} */\n  const fractions = {};\n\n  let maxIterations = 1e5;\n  let geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop();\n    // Add the a coordinate if it has not been added yet\n    key = fracA.toString();\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    }\n    // Pop the b coordinate off the stack\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop();\n    // Find the m point between the a and b coordinates\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n    if (\n      squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\n      squaredTolerance\n    ) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(\n  lon1,\n  lat1,\n  lon2,\n  lat2,\n  projection,\n  squaredTolerance\n) {\n  const geoProjection = getProjection('EPSG:4326');\n\n  const cosLat1 = Math.cos(toRadians(lat1));\n  const sinLat1 = Math.sin(toRadians(lat1));\n  const cosLat2 = Math.cos(toRadians(lat2));\n  const sinLat2 = Math.sin(toRadians(lat2));\n  const cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  const sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  const d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      if (1 <= d) {\n        return [lon2, lat2];\n      }\n      const D = frac * Math.acos(d);\n      const cosD = Math.cos(D);\n      const sinD = Math.sin(D);\n      const y = sinDeltaLon * cosLat2;\n      const x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n      const theta = Math.atan2(y, x);\n      const lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n      const lon =\n        toRadians(lon1) +\n        Math.atan2(\n          Math.sin(theta) * sinD * cosLat1,\n          cosD - sinLat1 * Math.sin(lat)\n        );\n      return [toDegrees(lon), toDegrees(lat)];\n    },\n    getTransform(geoProjection, projection),\n    squaredTolerance\n  );\n}\n\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon, lat1 + (lat2 - lat1) * frac];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance\n  );\n}\n\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon1 + (lon2 - lon1) * frac, lat];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}