{"ast":null,"code":"/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\n\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  addUniform(name) {\n    this.uniforms.push(name);\n    return this;\n  }\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  addAttribute(name) {\n    this.attributes.push(name);\n    return this;\n  }\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  addVarying(name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  }\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setSizeExpression(expression) {\n    this.sizeExpression = expression;\n    return this;\n  }\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setRotationExpression(expression) {\n    this.rotationExpression = expression;\n    return this;\n  }\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setSymbolOffsetExpression(expression) {\n    this.offsetExpression = expression;\n    return this;\n  }\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setColorExpression(expression) {\n    this.colorExpression = expression;\n    return this;\n  }\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  }\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression = expression;\n    return this;\n  }\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  setSymbolRotateWithView(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  }\n  /**\n   * @return {string} Previously set size expression\n   */\n\n\n  getSizeExpression() {\n    return this.sizeExpression;\n  }\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n\n\n  getOffsetExpression() {\n    return this.offsetExpression;\n  }\n  /**\n   * @return {string} Previously set color expression\n   */\n\n\n  getColorExpression() {\n    return this.colorExpression;\n  }\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n\n\n  getTextureCoordinateExpression() {\n    return this.texCoordExpression;\n  }\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n\n\n  getFragmentDiscardExpression() {\n    return this.discardExpression;\n  }\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  getSymbolVertexShader(forHitDetection) {\n    const offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    let attributes = this.attributes;\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\n${attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n')}\n}`;\n  }\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  getSymbolFragmentShader(forHitDetection) {\n    const hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${hitDetectionBypass}\n}`;\n  }\n\n}\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\n\nexport function parseLiteralStyle(style) {\n  const symbStyle = style.symbol;\n  const size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  const color = symbStyle.color || 'white';\n  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  const offset = symbStyle.offset || [0, 0];\n  const opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  const rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {}\n  };\n  const parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  const parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  const parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  const parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {}\n  };\n  const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  const parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  let opacityFilter = '1.0';\n  const visibleSize = `vec2(${expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER)}).x`;\n\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n\n    case 'circle':\n      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n      break;\n\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  const builder = new ShaderBuilder().setSizeExpression(`vec2(${parsedSize})`).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(`vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n\n\n  const uniforms = {}; // define one uniform per variable\n\n  fragContext.variables.forEach(function (varName) {\n    const uniformName = uniformNameForVariable(varName);\n    builder.addUniform(`float ${uniformName}`);\n\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(`The following variable is missing from the style: ${varName}`);\n      }\n\n      let value = style.variables[varName];\n\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin = symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  } // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n\n\n  fragContext.attributes.forEach(function (attrName) {\n    if (!vertContext.attributes.includes(attrName)) {\n      vertContext.attributes.push(attrName);\n    }\n\n    builder.addVarying(`v_${attrName}`, 'float', `a_${attrName}`);\n  }); // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(`float a_${attrName}`);\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          let value = props[attributeName];\n\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","ShaderBuilder","constructor","uniforms","attributes","varyings","sizeExpression","rotationExpression","offsetExpression","colorExpression","texCoordExpression","discardExpression","rotateWithView","addUniform","name","push","addAttribute","addVarying","type","expression","setSizeExpression","setRotationExpression","setSymbolOffsetExpression","setColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","setSymbolRotateWithView","getSizeExpression","getOffsetExpression","getColorExpression","getTextureCoordinateExpression","getFragmentDiscardExpression","getSymbolVertexShader","forHitDetection","offsetMatrix","concat","map","uniform","join","attribute","varying","getSymbolFragmentShader","hitDetectionBypass","parseLiteralStyle","style","symbStyle","symbol","size","undefined","color","texCoord","textureCoord","offset","opacity","rotation","vertContext","inFragmentShader","variables","stringLiteralsMap","functions","parsedSize","NUMBER_ARRAY","NUMBER","parsedOffset","parsedTexCoord","parsedRotation","fragContext","parsedColor","COLOR","parsedOpacity","opacityFilter","visibleSize","symbolType","st","a","Error","builder","filter","parsedFilter","BOOLEAN","forEach","varName","uniformName","value","src","texture","Image","crossOrigin","attrName","includes","attributeName","callback","feature","props"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/webgl/ShaderBuilder.js"],"sourcesContent":["/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\n\nimport {\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  uniformNameForVariable,\n} from '../style/expressions.js';\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression,\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSizeExpression(expression) {\n    this.sizeExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setRotationExpression(expression) {\n    this.rotationExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.offsetExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setColorExpression(expression) {\n    this.colorExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @return {string} Previously set size expression\n   */\n  getSizeExpression() {\n    return this.sizeExpression;\n  }\n\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n  getOffsetExpression() {\n    return this.offsetExpression;\n  }\n\n  /**\n   * @return {string} Previously set color expression\n   */\n  getColorExpression() {\n    return this.colorExpression;\n  }\n\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n  getTextureCoordinateExpression() {\n    return this.texCoordExpression;\n  }\n\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression;\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolVertexShader(forHitDetection) {\n    const offsetMatrix = this.rotateWithView\n      ? 'u_offsetScaleMatrix * u_offsetRotateMatrix'\n      : 'u_offsetScaleMatrix';\n\n    let attributes = this.attributes;\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\n${attributes\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${varyings\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolFragmentShader(forHitDetection) {\n    const hitDetectionBypass = forHitDetection\n      ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;'\n      : '';\n\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${hitDetectionBypass}\n}`;\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  const symbStyle = style.symbol;\n  const size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  const color = symbStyle.color || 'white';\n  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  const offset = symbStyle.offset || [0, 0];\n  const opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  const rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n  };\n  const parsedSize = expressionToGlsl(\n    vertContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  );\n  const parsedOffset = expressionToGlsl(\n    vertContext,\n    offset,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedTexCoord = expressionToGlsl(\n    vertContext,\n    texCoord,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedRotation = expressionToGlsl(\n    vertContext,\n    rotation,\n    ValueTypes.NUMBER\n  );\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {},\n  };\n  const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  const parsedOpacity = expressionToGlsl(\n    fragContext,\n    opacity,\n    ValueTypes.NUMBER\n  );\n\n  let opacityFilter = '1.0';\n  const visibleSize = `vec2(${expressionToGlsl(\n    fragContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  )}).x`;\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n      break;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  const builder = new ShaderBuilder()\n    .setSizeExpression(`vec2(${parsedSize})`)\n    .setRotationExpression(parsedRotation)\n    .setSymbolOffsetExpression(parsedOffset)\n    .setTextureCoordinateExpression(parsedTexCoord)\n    .setSymbolRotateWithView(!!symbStyle.rotateWithView)\n    .setColorExpression(\n      `vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`\n    );\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      ValueTypes.BOOLEAN\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    const uniformName = uniformNameForVariable(varName);\n    builder.addUniform(`float ${uniformName}`);\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\n          `The following variable is missing from the style: ${varName}`\n        );\n      }\n      let value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin =\n      symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder\n      .addUniform('sampler2D u_texture')\n      .setColorExpression(\n        builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)'\n      );\n    uniforms['u_texture'] = texture;\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (!vertContext.attributes.includes(attrName)) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(`v_${attrName}`, 'float', `a_${attrName}`);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(`float a_${attrName}`);\n  });\n\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          let value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        },\n      };\n    }),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,SACEA,UADF,EAEEC,gBAFF,EAGEC,yBAHF,EAIEC,sBAJF,QAKO,yBALP;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAN,CAAoB;EACzBC,WAAW,GAAG;IACZ;AACJ;AACA;AACA;AACA;IACI,KAAKC,QAAL,GAAgB,EAAhB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,UAAL,GAAkB,EAAlB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,QAAL,GAAgB,EAAhB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,cAAL,GAAsB,WAAtB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,kBAAL,GAA0B,KAA1B;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,gBAAL,GAAwB,WAAxB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,eAAL,GAAuB,WAAvB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,kBAAL,GAA0B,0BAA1B;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,iBAAL,GAAyB,OAAzB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,cAAL,GAAsB,KAAtB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,UAAU,CAACC,IAAD,EAAO;IACf,KAAKX,QAAL,CAAcY,IAAd,CAAmBD,IAAnB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEE,YAAY,CAACF,IAAD,EAAO;IACjB,KAAKV,UAAL,CAAgBW,IAAhB,CAAqBD,IAArB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEG,UAAU,CAACH,IAAD,EAAOI,IAAP,EAAaC,UAAb,EAAyB;IACjC,KAAKd,QAAL,CAAcU,IAAd,CAAmB;MACjBD,IAAI,EAAEA,IADW;MAEjBI,IAAI,EAAEA,IAFW;MAGjBC,UAAU,EAAEA;IAHK,CAAnB;IAKA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEC,iBAAiB,CAACD,UAAD,EAAa;IAC5B,KAAKb,cAAL,GAAsBa,UAAtB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEE,qBAAqB,CAACF,UAAD,EAAa;IAChC,KAAKZ,kBAAL,GAA0BY,UAA1B;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEG,yBAAyB,CAACH,UAAD,EAAa;IACpC,KAAKX,gBAAL,GAAwBW,UAAxB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEI,kBAAkB,CAACJ,UAAD,EAAa;IAC7B,KAAKV,eAAL,GAAuBU,UAAvB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEK,8BAA8B,CAACL,UAAD,EAAa;IACzC,KAAKT,kBAAL,GAA0BS,UAA1B;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEM,4BAA4B,CAACN,UAAD,EAAa;IACvC,KAAKR,iBAAL,GAAyBQ,UAAzB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEO,uBAAuB,CAACd,cAAD,EAAiB;IACtC,KAAKA,cAAL,GAAsBA,cAAtB;IACA,OAAO,IAAP;EACD;EAED;AACF;AACA;;;EACEe,iBAAiB,GAAG;IAClB,OAAO,KAAKrB,cAAZ;EACD;EAED;AACF;AACA;;;EACEsB,mBAAmB,GAAG;IACpB,OAAO,KAAKpB,gBAAZ;EACD;EAED;AACF;AACA;;;EACEqB,kBAAkB,GAAG;IACnB,OAAO,KAAKpB,eAAZ;EACD;EAED;AACF;AACA;;;EACEqB,8BAA8B,GAAG;IAC/B,OAAO,KAAKpB,kBAAZ;EACD;EAED;AACF;AACA;;;EACEqB,4BAA4B,GAAG;IAC7B,OAAO,KAAKpB,iBAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;A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"},"metadata":{},"sourceType":"module"}