{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */\n      evt.element\n    );\n  }\n}\n\nconst tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\n\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n\n    this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n\n    this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n\n    this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this)\n    };\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        const segments =\n        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        [];\n        segmenter(segments, geometry);\n\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map(s => boundingExtent(s));\n          const segmentsData = segments.map(segment => ({\n            feature: feature,\n            segment: segment\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  }\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  }\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n\n\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return super.handleEvent(evt);\n  }\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n\n\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n\n\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  handleFeatureChange_(evt) {\n    const feature =\n    /** @type {import(\"../Feature.js\").default} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  }\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n\n\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features =\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n\n\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    const upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach(vertex => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n\n      const result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate,\n          /** @type {import(\"../geom/Circle.js\").default} */\n          circleGeometry), projection);\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment; // points have only one coordinate\n\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n\n    if (userProjection) {\n      circleGeometry =\n      /** @type {import(\"../geom/Circle.js\").default} */\n      circleGeometry.clone().transform(userProjection, projection);\n    }\n\n    const polygon = fromCircle(circleGeometry);\n\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n\n    const coordinates = polygon.getCoordinates()[0];\n\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach(point => {\n      segments.push([point]);\n    });\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n}\n\nexport default Snap;","map":{"version":3,"names":["CollectionEventType","EventType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","constructor","options","pointerOptions","handleDownEvent","stopDown","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","bind","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","addFeature","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","slice","vertexPixel","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","Object","values","forEach","unlisten","unregister","extent","rBush","nodesToRemove","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","getInExtent","segmentsLength","projection","getView","getProjection","projectedCoordinate","closestVertex","minSquaredDistance","Infinity","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","segmentData","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/interaction/Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_,\n    ]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    const segments = this.rBush_.getInExtent(box);\n\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(\n            closestOnCircle(\n              projectedCoordinate,\n              /** @type {import(\"../geom/Circle.js\").default} */ (\n                circleGeometry\n              )\n            ),\n            projection\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}