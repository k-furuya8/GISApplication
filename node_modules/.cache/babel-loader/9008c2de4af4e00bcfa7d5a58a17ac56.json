{"ast":null,"code":"import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n\n\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    } // otherwise make a single request for each slice\n\n\n    return Promise.all(slices.map(slice => this.fetchSlice(slice, signal)));\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: { ...this.headers,\n        Range: `bytes=${slices.map(_ref => {\n          let {\n            offset,\n            length\n          } = _ref;\n          return `${offset}-${offset + length}`;\n        }).join(',')}`\n      },\n      signal\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const {\n        type,\n        params\n      } = parseContentType(response.getHeader('content-type'));\n\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n      const {\n        start,\n        end,\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map(slice => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const {\n      offset,\n      length\n    } = slice;\n    const response = await this.client.request({\n      headers: { ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`\n      },\n      signal\n    }); // check the response was okay and if the server actually understands range requests\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n      const {\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n\n}\n\nfunction maybeWrapInBlockedSource(source, _ref2) {\n  let {\n    blockSize,\n    cacheSize\n  } = _ref2;\n\n  if (blockSize === null) {\n    return source;\n  }\n\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url) {\n  let {\n    headers = {},\n    credentials,\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url) {\n  let {\n    headers = {},\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url) {\n  let {\n    headers = {},\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n/**\n *\n * @param {string} url\n * @param {object} options\n */\n\nexport function makeRemoteSource(url) {\n  let {\n    forceXHR = false,\n    ...clientOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","constructor","client","headers","maxRanges","allowFullFile","_fileSize","fetch","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","response","request","Range","offset","join","ok","Error","status","type","params","getHeader","byteRanges","getData","boundary","fileSize","data","start","end","total","first","others","concat","byteLength","maybeWrapInBlockedSource","source","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","XMLHttpRequest"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/source/remote.js"],"sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}