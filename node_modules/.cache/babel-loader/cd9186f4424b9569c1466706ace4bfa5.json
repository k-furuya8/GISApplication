{"ast":null,"code":"/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { inflateEnds } from '../geom/flat/orient.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { transform2D } from '../geom/flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\n\nconst tmpTransform = createTransform();\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\n\nclass RenderFeature {\n  /**\n   * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n\n    this.extent_;\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n\n    this.id_ = id;\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").Type}\n     */\n\n    this.type_ = type;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatCoordinates_ = flatCoordinates;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatMidpoints_ = null;\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n\n    this.ends_ = ends;\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n\n    this.properties_ = properties;\n  }\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n\n\n  get(key) {\n    return this.properties_[key];\n  }\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === 'Point' ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n\n    return this.extent_;\n  }\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0,\n      /** @type {Array<number>} */\n      this.ends_, 2, flatCenter, 0);\n    }\n\n    return this.flatInteriorPoints_;\n  }\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0,\n      /** @type {Array<Array<number>>} */\n      this.ends_, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0,\n      /** @type {Array<Array<number>>} */\n      this.ends_, 2, flatCenters);\n    }\n\n    return this.flatInteriorPoints_;\n  }\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n\n\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n\n    return this.flatMidpoints_;\n  }\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends =\n      /** @type {Array<number>} */\n      this.ends_;\n\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n\n    return this.flatMidpoints_;\n  }\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n\n\n  getId() {\n    return this.id_;\n  }\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n\n\n  getGeometry() {\n    return this;\n  }\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n\n\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n\n\n  getProperties() {\n    return this.properties_;\n  }\n  /**\n   * @return {number} Stride.\n   */\n\n\n  getStride() {\n    return 2;\n  }\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n\n\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/Geometry.js\").Type} Geometry type.\n   * @api\n   */\n\n\n  getType() {\n    return this.type_;\n  }\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n\n\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    }\n  }\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n\n\n  getEnds() {\n    return this.ends_;\n  }\n\n}\n\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n/**\n * @return {Array<number>} Flat coordinates.\n */\n\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\n\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n\n    case 'MultiLineString':\n      return new MultiLineString(renderFeature.getFlatCoordinates(), 'XY',\n      /** @type {Array<number>} */\n      renderFeature.getEnds());\n\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends =\n      /** @type {Array<number>} */\n      renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1 ? new MultiPolygon(flatCoordinates, 'XY', endss) : new Polygon(flatCoordinates, 'XY', ends);\n\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\n\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n\n  feature.setGeometry(geometry);\n\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n\n  feature.setProperties(properties, true);\n  return feature;\n}\nexport default RenderFeature;","map":{"version":3,"names":["Feature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","compose","composeTransform","create","createTransform","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","getCenter","getHeight","extend","getInteriorPointOfArray","getInteriorPointsOfMultiArray","get","getProjection","inflateEnds","interpolatePoint","linearRingss","linearRingssCenter","transform2D","tmpTransform","RenderFeature","constructor","type","flatCoordinates","ends","properties","id","styleFunction","extent_","id_","type_","flatCoordinates_","flatInteriorPoints_","flatMidpoints_","ends_","properties_","key","getExtent","length","getFlatInteriorPoint","flatCenter","getFlatInteriorPoints","flatCenters","getFlatMidpoint","getFlatMidpoints","offset","i","ii","end","midpoint","getId","getOrientedFlatCoordinates","getGeometry","getSimplifiedGeometry","squaredTolerance","simplifyTransformed","transform","getProperties","getStride","getStyleFunction","getType","projection","pixelExtent","projectedExtent","getWorldExtent","scale","getEnds","prototype","getEndss","getFlatCoordinates","toGeometry","renderFeature","geometryType","endss","Error","toFeature","geometryName","geometry","feature","undefined","setGeometryName","setGeometry","setId","setProperties"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/Feature.js"],"sourcesContent":["/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {extend} from '../array.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {get as getProjection} from '../proj.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {transform2D} from '../geom/flat/transform.js';\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|Array<Array<number>>}\n     */\n    this.ends_ = ends;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<number>} */ (this.ends_),\n        2,\n        flatCenter,\n        0\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<Array<number>>} */ (this.ends_),\n        2\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<Array<number>>} */ (this.ends_),\n        2,\n        flatCenters\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return 2;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {import(\"../geom/Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_\n      );\n    }\n  }\n  /**\n   * @return {Array<number>|Array<Array<number>>} Ends or endss.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n}\n\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds())\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = /** @type {Array<number>} */ (renderFeature.getEnds());\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}