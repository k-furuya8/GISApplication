{"ast":null,"code":"/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n\n      break;\n\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n\n      break;\n\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n\n        case 64:\n          return new Float64Array(size);\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize); // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip; // let sampleBitOffset = 0;\n\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample; // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    } // Bits per line rounds up to next byte boundary.\n\n\n    let bitsPerLine = tileWidth * pixelBitSkip;\n\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + i * bitsPerSample;\n          const outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          } // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n\n        } // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n/**\n * GeoTIFF sub-file image.\n */\n\n\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n\n\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n\n\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n\n\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n\n\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n\n\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n\n\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n\n\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - y * this.getTileHeight();\n    }\n  }\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n\n\n  getBytesPerPixel() {\n    let bytes = 0;\n\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n\n    switch (format) {\n      case 1:\n        // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n\n        break;\n\n      case 2:\n        // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n\n        break;\n\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n\n          case 32:\n            return DataView.prototype.getFloat32;\n\n          case 64:\n            return DataView.prototype.getFloat64;\n\n          default:\n            break;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat() {\n    let sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample() {\n    let sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n\n\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const {\n      tiles\n    } = this;\n\n    if (this.planarConfiguration === 1) {\n      index = y * numTilesPerRow + x;\n    } else if (this.planarConfiguration === 2) {\n      index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n    }\n\n    let offset;\n    let byteCount;\n\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n\n    const slice = (await this.source.fetch([{\n      offset,\n      length: byteCount\n    }], signal))[0];\n    let request;\n\n    if (tiles === null || !tiles[index]) {\n      // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));\n        }\n\n        return data;\n      })(); // set the cache\n\n\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    } // cache the tile request\n\n\n    return {\n      x,\n      y,\n      sample,\n      data: await request\n    };\n  }\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n\n\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n    const windowWidth = imageWindow[2] - imageWindow[0];\n    let bytesPerPixel = this.getBytesPerPixel();\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const {\n      littleEndian\n    } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then(tile => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                let windowCoordinate;\n\n                if (interleave) {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n\n    await Promise.all(promises);\n\n    if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {\n      let resampled;\n\n      if (interleave) {\n        resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n      } else {\n        resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n      }\n\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n    return valueArrays;\n  }\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n\n\n  async readRasters() {\n    let {\n      window: wnd,\n      samples = [],\n      interleave,\n      pool = null,\n      width,\n      height,\n      resampleMethod,\n      fillValue,\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n\n    let valueArrays;\n\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || (await getDecoder(this.fileDirectory));\n    const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n    return result;\n  }\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n\n\n  async readRGB() {\n    let {\n      window,\n      interleave = true,\n      pool = null,\n      width,\n      height,\n      resampleMethod,\n      enableAlpha = false,\n      signal\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n\n      if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n        s = [];\n\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal\n      });\n    }\n\n    let samples;\n\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal\n    };\n    const {\n      fileDirectory\n    } = this;\n    const raster = await this.readRasters(subOptions);\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    } // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n\n\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n\n\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5]\n      });\n    }\n\n    return tiePoints;\n  }\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n\n\n  getGDALMetadata() {\n    let sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const metadata = {};\n\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_METADATA;\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter(item => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter(item => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n\n    return metadata;\n  }\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n\n\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n\n\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (tiePoints && tiePoints.length === 6) {\n      return [tiePoints[3], tiePoints[4], tiePoints[5]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n\n\n  getResolution() {\n    let referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n    }\n\n    if (modelTransformation) {\n      return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n\n\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n\n\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n    const x1 = origin[0];\n    const y1 = origin[1];\n    const x2 = x1 + resolution[0] * this.getWidth();\n    const y2 = y1 + resolution[1] * this.getHeight();\n    return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n  }\n\n}\n\nexport default GeoTIFFImage;","map":{"version":3,"names":["getFloat16","getAttribute","findTagsByName","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","constructor","fileDirectory","geoKeys","dataView","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","min","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","length","getSampleByteSize","RangeError","ceil","getReaderForSample","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","slice","fetch","request","data","decode","sampleFormat","_readRaster","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","imageWidth","imageHeight","minXTile","max","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","push","promises","yTile","xTile","si","promise","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","value","call","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","valueArray","Array","isArray","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","raster","ColorMap","red","green","blue","j","getTiePoints","ModelTiepoint","tiePoints","k","z","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","undefined","Number","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/geotiffimage.js"],"sourcesContent":["/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}