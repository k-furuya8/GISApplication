{"ast":null,"code":"/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n\n    this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n\n    this.state =\n    /** @type {import(\"../canvas.js\").FillStrokeState} */\n    {};\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n\n\n  appendFlatPointCoordinates(flatCoordinates, stride) {\n    const extent = this.getBufferedMaxExtent();\n    const tmpCoord = this.tmpCoordinate_;\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n\n    return myEnd;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n    let i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n\n    return myEnd;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n\n\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n\n    return offset;\n  }\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n\n\n  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        const endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        offset = 0;\n\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          const myEnds = [];\n          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n        break;\n\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates = type == 'Polygon' ?\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n        break;\n\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        break;\n\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        }\n\n        break;\n\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n        break;\n\n      default:\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  }\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n\n\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n\n\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  createStroke(state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n\n\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  }\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n\n\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        const width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  }\n\n}\n\nexport default CanvasBuilder;","map":{"version":3,"names":["CanvasInstruction","Relationship","VectorContext","asColorLike","buffer","clone","containsCoordinate","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","applyPixelRatio","dashArray","map","dash","appendFlatPointCoordinates","flatCoordinates","stride","extent","getBufferedMaxExtent","tmpCoord","myEnd","length","i","ii","appendFlatLineCoordinates","offset","end","closed","skipFirst","lastXCoord","lastYCoord","nextCoord","skipped","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","builderEnd","push","drawCustom","geometry","feature","renderer","hitDetectionRenderer","beginGeometry","type","getType","getStride","builderBegin","builderEndss","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","getFlatCoordinates","getEnds","endGeometry","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","undefined","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","call","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/canvas/Builder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {\n  buffer,\n  clone,\n  containsCoordinate,\n  coordinateRelationship,\n} from '../../extent.js';\nimport {\n  defaultFillStyle,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultStrokeStyle,\n} from '../canvas.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {\n  inflateCoordinates,\n  inflateCoordinatesArray,\n  inflateMultiCoordinatesArray,\n} from '../../geom/flat/inflate.js';\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1\n      ? dashArray\n      : dashArray.map(function (dash) {\n          return dash * pixelRatio;\n        });\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n  appendFlatPointCoordinates(flatCoordinates, stride) {\n    const extent = this.getBufferedMaxExtent();\n    const tmpCoord = this.tmpCoordinate_;\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  appendFlatLineCoordinates(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    closed,\n    skipFirst\n  ) {\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n\n    let i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        false,\n        false\n      );\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getOrientedFlatCoordinates();\n        builderEndss = [];\n        const endss =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getEndss();\n        offset = 0;\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          const myEnds = [];\n          offset = this.drawCustomCoordinates_(\n            flatCoordinates,\n            offset,\n            endss[i],\n            stride,\n            myEnds\n          );\n          builderEndss.push(myEnds);\n        }\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          renderer,\n          inflateMultiCoordinatesArray,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateMultiCoordinatesArray,\n        ]);\n        break;\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates =\n          type == 'Polygon'\n            ? /** @type {import(\"../../geom/Polygon.js\").default} */ (\n                geometry\n              ).getOrientedFlatCoordinates()\n            : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(\n          flatCoordinates,\n          0,\n          /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (\n            geometry\n          ).getEnds(),\n          stride,\n          builderEnds\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          renderer,\n          inflateCoordinatesArray,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinatesArray,\n        ]);\n        break;\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(\n          flatCoordinates,\n          0,\n          flatCoordinates.length,\n          stride,\n          false,\n          false\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n          inflateCoordinates,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinates,\n        ]);\n        break;\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            renderer,\n            inflateCoordinates,\n          ]);\n          this.hitDetectionInstructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            hitDetectionRenderer || renderer,\n            inflateCoordinates,\n          ]);\n        }\n        break;\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n        ]);\n        break;\n      default:\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n    ];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n    ];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates,\n    };\n  }\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(\n        fillStyleColor ? fillStyleColor : defaultFillStyle\n      );\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(\n        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle\n      );\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap =\n        strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash\n        ? strokeStyleLineDash.slice()\n        : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset\n        ? strokeStyleLineDashOffset\n        : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin =\n        strokeStyleLineJoin !== undefined\n          ? strokeStyleLineJoin\n          : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth =\n        strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit =\n        strokeStyleMiterLimit !== undefined\n          ? strokeStyleMiterLimit\n          : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  createStroke(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth * this.pixelRatio,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      this.applyPixelRatio(state.lineDash),\n      state.lineDashOffset * this.pixelRatio,\n    ];\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n    if (\n      state.currentStrokeStyle != strokeStyle ||\n      state.currentLineCap != lineCap ||\n      (lineDash != state.currentLineDash &&\n        !equals(state.currentLineDash, lineDash)) ||\n      state.currentLineDashOffset != lineDashOffset ||\n      state.currentLineJoin != lineJoin ||\n      state.currentLineWidth != lineWidth ||\n      state.currentMiterLimit != miterLimit\n    ) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  }\n}\n\nexport default CanvasBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}