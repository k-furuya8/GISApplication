{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\n\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    return offset;\n  }\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n\n\n  drawCircle(circleGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  drawPolygon(polygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0,\n    /** @type {Array<number>} */\n    ends, stride);\n    this.endGeometry(feature);\n  }\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  drawMultiPolygon(multiPolygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(feature);\n  }\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    const tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n\n    return super.finish();\n  }\n  /**\n   * @private\n   */\n\n\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n\n}\n\nexport default CanvasPolygonBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","beginPathInstruction","closePathInstruction","fillInstruction","strokeInstruction","defaultFillStyle","snap","CanvasPolygonBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/canvas/PolygonBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, {\n  beginPathInstruction,\n  closePathInstruction,\n  fillInstruction,\n  strokeInstruction,\n} from './Instruction.js';\nimport {defaultFillStyle} from '../canvas.js';\nimport {snap} from '../../geom/flat/simplify.js';\n\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        true,\n        !stroke\n      );\n      const moveToLineToInstruction = [\n        CanvasInstruction.MOVE_TO_LINE_TO,\n        myBegin,\n        myEnd,\n      ];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n  drawCircle(circleGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride,\n      false,\n      false\n    );\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawPolygon(polygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(\n      flatCoordinates,\n      0,\n      /** @type {Array<number>} */ (ends),\n      stride\n    );\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(\n        flatCoordinates,\n        offset,\n        endss[i],\n        stride\n      );\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return super.finish();\n  }\n\n  /**\n   * @private\n   */\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\n\nexport default CanvasPolygonBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}