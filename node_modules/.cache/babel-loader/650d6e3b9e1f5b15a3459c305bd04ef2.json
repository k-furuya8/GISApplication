{"ast":null,"code":"/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\n\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n    options = options || {};\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.inversePixelTransform_ = createTransform();\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.pixelContext_ = null;\n    /**\n     * @private\n     */\n\n    this.postProcesses_ = options.postProcesses;\n    /**\n     * @private\n     */\n\n    this.uniforms_ = options.uniforms;\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n\n    this.helper;\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n\n\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n  /**\n   * @protected\n   */\n\n\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n\n        const layerClassName = layer.getClassName();\n\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n\n        className = layerClassName;\n\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n  /**\n   * @protected\n   */\n\n\n  afterHelperCreated() {}\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n\n\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n\n    if (layer.hasListener(type)) {\n      composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n      const event = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n}\n\nexport default WebGLLayerRenderer;","map":{"version":3,"names":["LayerProperty","LayerRenderer","RenderEvent","RenderEventType","WebGLHelper","compose","composeTransform","create","createTransform","WebGLLayerRenderer","constructor","layer","options","inversePixelTransform_","pixelContext_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","bind","dispatchPreComposeEvent","dispatchPostComposeEvent","context","frameState","getLayer","hasListener","PRECOMPOSE","event","undefined","dispatchEvent","POSTCOMPOSE","reset","setUniforms","dispose","prepareFrame","getRenderSource","incrementGroup","groupNumber","className","i","ii","layerStatesArray","length","renderer","getRenderer","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","disposeInternal","dispatchRenderEvent_","type","pixelRatio","size","preRender","PRERENDER","postRender","POSTRENDER"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/renderer/webgl/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}