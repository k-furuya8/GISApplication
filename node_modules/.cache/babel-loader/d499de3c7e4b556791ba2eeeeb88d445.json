{"ast":null,"code":"/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { WebGLWorkerMessageType } from '../../render/webgl/constants.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, translate as translateTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals, getWidth } from '../../extent.js';\nimport { colorDecodeId, colorEncodeId } from '../../render/webgl/utils.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\n\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    });\n    this.ready = false;\n    this.sourceRevision_ = -1;\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n    /**\n     * @private\n     */\n\n    this.vertexShader_ = options.vertexShader;\n    /**\n     * @private\n     */\n\n    this.fragmentShader_ = options.fragmentShader;\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n\n    this.program_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;\n    /**\n     * @private\n     */\n\n    this.hitVertexShader_ = options.hitVertexShader;\n    /**\n     * @private\n     */\n\n    this.hitFragmentShader_ = options.hitFragmentShader;\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n\n    this.hitProgram_;\n    const customAttributes = options.attributes ? options.attributes.map(function (attribute) {\n      return {\n        name: 'a_' + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n\n    this.attributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n\n    this.hitDetectionAttributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_hitColor',\n      size: 4,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_featureUid',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    this.customAttributes = options.attributes ? options.attributes : [];\n    this.previousExtent_ = createEmpty();\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    this.currentTransform_ = projectionMatrixTransform;\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    this.renderTransform_ = createTransform();\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    this.invertRenderTransform_ = createTransform();\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n\n    this.renderInstructions_ = new Float32Array(0);\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n\n    this.hitRenderInstructions_ = new Float32Array(0);\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n\n    this.hitRenderTarget_;\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n\n    this.generateBuffersRun_ = 0;\n    /**\n     * @private\n     */\n\n    this.worker_ = createWebGLWorker();\n    this.worker_.addEventListener('message',\n    /**\n     * @param {*} event Event.\n     * @this {WebGLPointsLayerRenderer}\n     */\n    function (event) {\n      const received = event.data;\n\n      if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n        const projectionTransform = received.projectionTransform;\n\n        if (received.hitDetection) {\n          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.hitVerticesBuffer_);\n        } else {\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n        }\n\n        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        this.helper.flushBufferData(this.indicesBuffer_);\n        this.renderTransform_ = projectionTransform;\n        makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n\n        if (received.hitDetection) {\n          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n        } else {\n          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n\n          if (received.generateBuffersRun === this.generateBuffersRun_) {\n            this.ready = true;\n          }\n        }\n\n        this.getLayer().changed();\n      }\n    }.bind(this));\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n\n    this.featureCache_ = {};\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n\n    this.featureCount_ = 0;\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, this.handleSourceFeatureAdded_, this), listen(source, VectorEventType.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), listen(source, VectorEventType.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), listen(source, VectorEventType.CLEAR, this.handleSourceFeatureClear_, this)];\n    source.forEachFeature(function (feature) {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      this.featureCount_++;\n    }.bind(this));\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n\n    if (this.hitDetectionEnabled_) {\n      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n    this.featureCount_++;\n  }\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n  }\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n  /**\n   * @private\n   */\n\n\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const projection = frameState.viewState.projection;\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource(); // FIXME fix hit detection isn't reliable when rendering multiple worlds\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;\n    const startWorld = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;\n    let world = startWorld;\n    const renderCount = this.indicesBuffer_.getSize();\n\n    do {\n      // apply the current projection transform with the invert of the one used to fill buffers\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n      const renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState); // write new data\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    return true;\n  }\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform); // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n\n    const totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n\n    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n\n      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n      }\n    } // loop on features to fill the buffer\n\n\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry =\n      /** @type {import(\"../../geom\").Point} */\n      featureCache.geometry;\n\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1]; // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      } // pushing custom attributes\n\n\n      let value;\n\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n        this.renderInstructions_[renderIndex++] = value;\n\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n\n\n    const message = {\n      id: 0,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length\n    }; // additional properties will be sent back as-is by the worker\n\n    message['projectionTransform'] = projectionTransform;\n    message['generateBuffersRun'] = ++this.generateBuffersRun_;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        id: 0,\n        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [this.hitRenderInstructions_.buffer]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    assert(this.hitDetectionEnabled_, 66);\n\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n\n    return undefined;\n  }\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n\n\n  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    let world = startWorld;\n    this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n    this.helper.useProgram(this.hitProgram_, frameState);\n    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n}\n\nexport default WebGLPointsLayerRenderer;","map":{"version":3,"names":["BaseVector","VectorEventType","ViewHint","WebGLArrayBuffer","WebGLLayerRenderer","WebGLRenderTarget","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","AttributeType","DefaultUniform","WebGLWorkerMessageType","apply","applyTransform","create","createTransform","makeInverse","makeInverseTransform","multiply","multiplyTransform","translate","translateTransform","assert","buffer","createEmpty","equals","getWidth","colorDecodeId","colorEncodeId","createWebGLWorker","getUid","listen","unlistenByKey","WebGLPointsLayerRenderer","constructor","layer","options","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","postProcesses","ready","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","map","attribute","name","size","type","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","addEventListener","event","received","data","GENERATE_POINT_BUFFERS","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","helper","flushBufferData","indexBuffer","renderInstructions","generateBuffersRun","getLayer","changed","bind","featureCache_","featureCount_","source","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","properties","getProperties","geometry","getGeometry","afterHelperCreated","getProgram","renderFrame","frameState","gl","getGL","preRender","projection","viewState","vectorSource","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","startWorld","floor","world","renderCount","getSize","makeProjectionTransform","applyUniforms","drawElements","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","renderHitDetection","clearCachedData","postRender","prepareFrameInternal","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","useProgram","prepareDraw","bindBuffer","enableAttributes","totalInstructionsCount","length","totalHitInstructionsCount","featureCache","tmpCoords","tmpColor","renderIndex","hitIndex","hitColor","featureUid","getType","getFlatCoordinates","Number","value","j","callback","message","id","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","undefined","pixel","coordinateToPixelTransform","readPixel","color","index","opacity","uid","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","disposeInternal","terminate","layer_","forEach","key"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.ready = false;\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ =\n      options.hitFragmentShader && options.hitVertexShader ? true : false;\n\n    /**\n     * @private\n     */\n    this.hitVertexShader_ = options.hitVertexShader;\n\n    /**\n     * @private\n     */\n    this.hitFragmentShader_ = options.hitFragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.hitProgram_;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.hitDetectionAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    this.hitRenderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.generateBuffersRun_ = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       * @this {WebGLPointsLayerRenderer}\n       */\n      function (event) {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          if (received.hitDetection) {\n            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.hitVerticesBuffer_);\n          } else {\n            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.verticesBuffer_);\n          }\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          if (received.hitDetection) {\n            this.hitRenderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          } else {\n            this.renderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n            if (received.generateBuffersRun === this.generateBuffersRun_) {\n              this.ready = true;\n            }\n          }\n\n          this.getLayer().changed();\n        }\n      }.bind(this)\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature(\n      function (feature) {\n        this.featureCache_[getUid(feature)] = {\n          feature: feature,\n          properties: feature.getProperties(),\n          geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n      }.bind(this)\n    );\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitProgram_ = this.helper.getProgram(\n        this.hitFragmentShader_,\n        this.hitVertexShader_\n      );\n\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const projection = frameState.viewState.projection;\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    // FIXME fix hit detection isn't reliable when rendering multiple worlds\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n\n    const startWorld = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    let world = startWorld;\n    const renderCount = this.indicesBuffer_.getSize();\n\n    do {\n      // apply the current projection transform with the invert of the one used to fill buffers\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalInstructionsCount\n    ) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount =\n        (7 + this.customAttributes.length) * this.featureCount_;\n      if (\n        !this.hitRenderInstructions_ ||\n        this.hitRenderInstructions_.length !== totalHitInstructionsCount\n      ) {\n        this.hitRenderInstructions_ = new Float32Array(\n          totalHitInstructionsCount\n        );\n      }\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      let value;\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: 0,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    message['generateBuffersRun'] = ++this.generateBuffersRun_;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        id: 0,\n        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length,\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer,\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    let world = startWorld;\n\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2),\n    ]);\n\n    this.helper.useProgram(this.hitProgram_, frameState);\n    this.helper.prepareDrawToRenderTarget(\n      frameState,\n      this.hitRenderTarget_,\n      true\n    );\n\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,2BAAvB;AACA,OAAOC,eAAP,MAA4B,iCAA5B;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,OAAOC,gBAAP,MAA6B,uBAA7B;AACA,OAAOC,kBAAP,MAA+B,YAA/B;AACA,OAAOC,iBAAP,MAA8B,6BAA9B;AACA,SAAQC,YAAR,EAAsBC,YAAtB,EAAoCC,oBAApC,QAA+D,gBAA/D;AACA,SAAQC,aAAR,EAAuBC,cAAvB,QAA4C,uBAA5C;AACA,SAAQC,sBAAR,QAAqC,iCAArC;AACA,SACEC,KAAK,IAAIC,cADX,EAEEC,MAAM,IAAIC,eAFZ,EAGEC,WAAW,IAAIC,oBAHjB,EAIEC,QAAQ,IAAIC,iBAJd,EAKEC,SAAS,IAAIC,kBALf,QAMO,oBANP;AAOA,SAAQC,MAAR,QAAqB,kBAArB;AACA,SAAQC,MAAR,EAAgBC,WAAhB,EAA6BC,MAA7B,EAAqCC,QAArC,QAAoD,iBAApD;AACA,SAAQC,aAAR,EAAuBC,aAAvB,QAA2C,6BAA3C;AACA,SAAQd,MAAM,IAAIe,iBAAlB,QAA0C,uBAA1C;AACA,SAAQC,MAAR,QAAqB,eAArB;AACA,SAAQC,MAAR,EAAgBC,aAAhB,QAAoC,iBAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,wBAAN,SAAuC7B,kBAAvC,CAA0D;EACxD;AACF;AACA;AACA;EACE8B,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiB;IAC1B,MAAMC,QAAQ,GAAGD,OAAO,CAACC,QAAR,IAAoB,EAArC;IACA,MAAMC,yBAAyB,GAAGvB,eAAe,EAAjD;IACAsB,QAAQ,CAAC3B,cAAc,CAAC6B,iBAAhB,CAAR,GAA6CD,yBAA7C;IAEA,MAAMH,KAAN,EAAa;MACXE,QAAQ,EAAEA,QADC;MAEXG,aAAa,EAAEJ,OAAO,CAACI;IAFZ,CAAb;IAKA,KAAKC,KAAL,GAAa,KAAb;IAEA,KAAKC,eAAL,GAAuB,CAAC,CAAxB;IAEA,KAAKC,eAAL,GAAuB,IAAIxC,gBAAJ,CAAqBG,YAArB,EAAmCC,YAAnC,CAAvB;IACA,KAAKqC,kBAAL,GAA0B,IAAIzC,gBAAJ,CAAqBG,YAArB,EAAmCC,YAAnC,CAA1B;IACA,KAAKsC,cAAL,GAAsB,IAAI1C,gBAAJ,CACpBK,oBADoB,EAEpBD,YAFoB,CAAtB;IAKA;AACJ;AACA;;IACI,KAAKuC,aAAL,GAAqBV,OAAO,CAACW,YAA7B;IAEA;AACJ;AACA;;IACI,KAAKC,eAAL,GAAuBZ,OAAO,CAACa,cAA/B;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,QAAL;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,oBAAL,GACEf,OAAO,CAACgB,iBAAR,IAA6BhB,OAAO,CAACiB,eAArC,GAAuD,IAAvD,GAA8D,KADhE;IAGA;AACJ;AACA;;IACI,KAAKC,gBAAL,GAAwBlB,OAAO,CAACiB,eAAhC;IAEA;AACJ;AACA;;IACI,KAAKE,kBAAL,GAA0BnB,OAAO,CAACgB,iBAAlC;IAEA;AACJ;AACA;AACA;;IACI,KAAKI,WAAL;IAEA,MAAMC,gBAAgB,GAAGrB,OAAO,CAACsB,UAAR,GACrBtB,OAAO,CAACsB,UAAR,CAAmBC,GAAnB,CAAuB,UAAUC,SAAV,EAAqB;MAC1C,OAAO;QACLC,IAAI,EAAE,OAAOD,SAAS,CAACC,IADlB;QAELC,IAAI,EAAE,CAFD;QAGLC,IAAI,EAAEtD,aAAa,CAACuD;MAHf,CAAP;IAKD,CAND,CADqB,GAQrB,EARJ;IAUA;AACJ;AACA;AACA;AACA;;IACI,KAAKN,UAAL,GAAkB,CAChB;MACEG,IAAI,EAAE,YADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CADgB,EAMhB;MACEH,IAAI,EAAE,SADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CANgB,EAWhBC,MAXgB,CAWTR,gBAXS,CAAlB;IAaA;AACJ;AACA;AACA;;IACI,KAAKS,sBAAL,GAA8B,CAC5B;MACEL,IAAI,EAAE,YADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CAD4B,EAM5B;MACEH,IAAI,EAAE,SADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CAN4B,EAW5B;MACEH,IAAI,EAAE,YADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CAX4B,EAgB5B;MACEH,IAAI,EAAE,cADR;MAEEC,IAAI,EAAE,CAFR;MAGEC,IAAI,EAAEtD,aAAa,CAACuD;IAHtB,CAhB4B,EAqB5BC,MArB4B,CAqBrBR,gBArBqB,CAA9B;IAuBA,KAAKA,gBAAL,GAAwBrB,OAAO,CAACsB,UAAR,GAAqBtB,OAAO,CAACsB,UAA7B,GAA0C,EAAlE;IAEA,KAAKS,eAAL,GAAuB3C,WAAW,EAAlC;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;IACI,KAAK4C,iBAAL,GAAyB9B,yBAAzB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAK+B,gBAAL,GAAwBtD,eAAe,EAAvC;IAEA;AACJ;AACA;AACA;;IACI,KAAKuD,sBAAL,GAA8BvD,eAAe,EAA7C;IAEA;AACJ;AACA;AACA;;IACI,KAAKwD,mBAAL,GAA2B,IAAIC,YAAJ,CAAiB,CAAjB,CAA3B;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,sBAAL,GAA8B,IAAID,YAAJ,CAAiB,CAAjB,CAA9B;IAEA;AACJ;AACA;AACA;;IACI,KAAKE,gBAAL;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,mBAAL,GAA2B,CAA3B;IAEA;AACJ;AACA;;IACI,KAAKC,OAAL,GAAe/C,iBAAiB,EAAhC;IAEA,KAAK+C,OAAL,CAAaC,gBAAb,CACE,SADF;IAEE;AACN;AACA;AACA;IACM,UAAUC,KAAV,EAAiB;MACf,MAAMC,QAAQ,GAAGD,KAAK,CAACE,IAAvB;;MACA,IAAID,QAAQ,CAAChB,IAAT,KAAkBpD,sBAAsB,CAACsE,sBAA7C,EAAqE;QACnE,MAAMC,mBAAmB,GAAGH,QAAQ,CAACG,mBAArC;;QACA,IAAIH,QAAQ,CAACI,YAAb,EAA2B;UACzB,KAAKvC,kBAAL,CAAwBwC,eAAxB,CAAwCL,QAAQ,CAACM,YAAjD;UACA,KAAKC,MAAL,CAAYC,eAAZ,CAA4B,KAAK3C,kBAAjC;QACD,CAHD,MAGO;UACL,KAAKD,eAAL,CAAqByC,eAArB,CAAqCL,QAAQ,CAACM,YAA9C;UACA,KAAKC,MAAL,CAAYC,eAAZ,CAA4B,KAAK5C,eAAjC;QACD;;QACD,KAAKE,cAAL,CAAoBuC,eAApB,CAAoCL,QAAQ,CAACS,WAA7C;QACA,KAAKF,MAAL,CAAYC,eAAZ,CAA4B,KAAK1C,cAAjC;QAEA,KAAKwB,gBAAL,GAAwBa,mBAAxB;QACAjE,oBAAoB,CAClB,KAAKqD,sBADa,EAElB,KAAKD,gBAFa,CAApB;;QAIA,IAAIU,QAAQ,CAACI,YAAb,EAA2B;UACzB,KAAKV,sBAAL,GAA8B,IAAID,YAAJ,CAC5BM,KAAK,CAACE,IAAN,CAAWS,kBADiB,CAA9B;QAGD,CAJD,MAIO;UACL,KAAKlB,mBAAL,GAA2B,IAAIC,YAAJ,CACzBM,KAAK,CAACE,IAAN,CAAWS,kBADc,CAA3B;;UAGA,IAAIV,QAAQ,CAACW,kBAAT,KAAgC,KAAKf,mBAAzC,EAA8D;YAC5D,KAAKlC,KAAL,GAAa,IAAb;UACD;QACF;;QAED,KAAKkD,QAAL,GAAgBC,OAAhB;MACD;IACF,CAlCD,CAkCEC,IAlCF,CAkCO,IAlCP,CANF;IA2CA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,aAAL,GAAqB,EAArB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,aAAL,GAAqB,CAArB;IAEA,MAAMC,MAAM,GAAG,KAAKL,QAAL,GAAgBM,SAAhB,EAAf;IACA,KAAKC,iBAAL,GAAyB,CACvBnE,MAAM,CACJiE,MADI,EAEJ/F,eAAe,CAACkG,UAFZ,EAGJ,KAAKC,yBAHD,EAIJ,IAJI,CADiB,EAOvBrE,MAAM,CACJiE,MADI,EAEJ/F,eAAe,CAACoG,aAFZ,EAGJ,KAAKC,2BAHD,EAIJ,IAJI,CAPiB,EAavBvE,MAAM,CACJiE,MADI,EAEJ/F,eAAe,CAACsG,aAFZ,EAGJ,KAAKC,0BAHD,EAIJ,IAJI,CAbiB,EAmBvBzE,MAAM,CACJiE,MADI,EAEJ/F,eAAe,CAACwG,KAFZ,EAGJ,KAAKC,yBAHD,EAIJ,IAJI,CAnBiB,CAAzB;IA0BAV,MAAM,CAACW,cAAP,CACE,UAAUC,OAAV,EAAmB;MACjB,KAAKd,aAAL,CAAmBhE,MAAM,CAAC8E,OAAD,CAAzB,IAAsC;QACpCA,OAAO,EAAEA,OAD2B;QAEpCC,UAAU,EAAED,OAAO,CAACE,aAAR,EAFwB;QAGpCC,QAAQ,EAAEH,OAAO,CAACI,WAAR;MAH0B,CAAtC;MAKA,KAAKjB,aAAL;IACD,CAPD,CAOEF,IAPF,CAOO,IAPP,CADF;EAUD;;EAEDoB,kBAAkB,GAAG;IACnB,KAAK/D,QAAL,GAAgB,KAAKoC,MAAL,CAAY4B,UAAZ,CACd,KAAKlE,eADS,EAEd,KAAKF,aAFS,CAAhB;;IAKA,IAAI,KAAKK,oBAAT,EAA+B;MAC7B,KAAKK,WAAL,GAAmB,KAAK8B,MAAL,CAAY4B,UAAZ,CACjB,KAAK3D,kBADY,EAEjB,KAAKD,gBAFY,CAAnB;MAKA,KAAKoB,gBAAL,GAAwB,IAAIrE,iBAAJ,CAAsB,KAAKiF,MAA3B,CAAxB;IACD;EACF;EAED;AACF;AACA;AACA;;;EACEc,yBAAyB,CAACtB,KAAD,EAAQ;IAC/B,MAAM8B,OAAO,GAAG9B,KAAK,CAAC8B,OAAtB;IACA,KAAKd,aAAL,CAAmBhE,MAAM,CAAC8E,OAAD,CAAzB,IAAsC;MACpCA,OAAO,EAAEA,OAD2B;MAEpCC,UAAU,EAAED,OAAO,CAACE,aAAR,EAFwB;MAGpCC,QAAQ,EAAEH,OAAO,CAACI,WAAR;IAH0B,CAAtC;IAKA,KAAKjB,aAAL;EACD;EAED;AACF;AACA;AACA;;;EACEO,2BAA2B,CAACxB,KAAD,EAAQ;IACjC,MAAM8B,OAAO,GAAG9B,KAAK,CAAC8B,OAAtB;IACA,KAAKd,aAAL,CAAmBhE,MAAM,CAAC8E,OAAD,CAAzB,IAAsC;MACpCA,OAAO,EAAEA,OAD2B;MAEpCC,UAAU,EAAED,OAAO,CAACE,aAAR,EAFwB;MAGpCC,QAAQ,EAAEH,OAAO,CAACI,WAAR;IAH0B,CAAtC;EAKD;EAED;AACF;AACA;AACA;;;EACER,0BAA0B,CAAC1B,KAAD,EAAQ;IAChC,MAAM8B,OAAO,GAAG9B,KAAK,CAAC8B,OAAtB;IACA,OAAO,KAAKd,aAAL,CAAmBhE,MAAM,CAAC8E,OAAD,CAAzB,CAAP;IACA,KAAKb,aAAL;EACD;EAED;AACF;AACA;;;EACEW,yBAAyB,GAAG;IAC1B,KAAKZ,aAAL,GAAqB,EAArB;IACA,KAAKC,aAAL,GAAqB,CAArB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEoB,WAAW,CAACC,UAAD,EAAa;IACtB,MAAMC,EAAE,GAAG,KAAK/B,MAAL,CAAYgC,KAAZ,EAAX;IACA,KAAKC,SAAL,CAAeF,EAAf,EAAmBD,UAAnB;IAEA,MAAMI,UAAU,GAAGJ,UAAU,CAACK,SAAX,CAAqBD,UAAxC;IACA,MAAMrF,KAAK,GAAG,KAAKwD,QAAL,EAAd;IACA,MAAM+B,YAAY,GAAGvF,KAAK,CAAC8D,SAAN,EAArB,CANsB,CAOtB;;IACA,MAAM0B,UAAU,GAAGD,YAAY,CAACE,QAAb,MAA2BJ,UAAU,CAACK,QAAX,EAA9C;IACA,MAAMC,gBAAgB,GAAGN,UAAU,CAACO,SAAX,EAAzB;IAEA,MAAMC,MAAM,GAAGZ,UAAU,CAACY,MAA1B;IACA,MAAMC,UAAU,GAAGN,UAAU,GAAGjG,QAAQ,CAACoG,gBAAD,CAAX,GAAgC,IAA7D;IACA,MAAMI,QAAQ,GAAGP,UAAU,GACvBQ,IAAI,CAACC,IAAL,CAAU,CAACJ,MAAM,CAAC,CAAD,CAAN,GAAYF,gBAAgB,CAAC,CAAD,CAA7B,IAAoCG,UAA9C,IAA4D,CADrC,GAEvB,CAFJ;IAIA,MAAMI,UAAU,GAAGV,UAAU,GACzBQ,IAAI,CAACG,KAAL,CAAW,CAACN,MAAM,CAAC,CAAD,CAAN,GAAYF,gBAAgB,CAAC,CAAD,CAA7B,IAAoCG,UAA/C,CADyB,GAEzB,CAFJ;IAIA,IAAIM,KAAK,GAAGF,UAAZ;IACA,MAAMG,WAAW,GAAG,KAAK3F,cAAL,CAAoB4F,OAApB,EAApB;;IAEA,GAAG;MACD;MACA,KAAKnD,MAAL,CAAYoD,uBAAZ,CAAoCtB,UAApC,EAAgD,KAAKhD,iBAArD;MACA/C,kBAAkB,CAAC,KAAK+C,iBAAN,EAAyBmE,KAAK,GAAGN,UAAjC,EAA6C,CAA7C,CAAlB;MACA9G,iBAAiB,CAAC,KAAKiD,iBAAN,EAAyB,KAAKE,sBAA9B,CAAjB;MACA,KAAKgB,MAAL,CAAYqD,aAAZ,CAA0BvB,UAA1B;MAEA,KAAK9B,MAAL,CAAYsD,YAAZ,CAAyB,CAAzB,EAA4BJ,WAA5B;IACD,CARD,QAQS,EAAED,KAAF,GAAUL,QARnB;;IAUA,KAAK5C,MAAL,CAAYuD,YAAZ,CACEzB,UADF,EAEE,KAAK0B,uBAFP,EAGE,KAAKC,wBAHP;IAKA,MAAMC,MAAM,GAAG,KAAK1D,MAAL,CAAY2D,SAAZ,EAAf;;IAEA,IAAI,KAAK9F,oBAAT,EAA+B;MAC7B,KAAK+F,kBAAL,CAAwB9B,UAAxB,EAAoCiB,UAApC,EAAgDH,QAAhD,EAA0DD,UAA1D;MACA,KAAKvD,gBAAL,CAAsByE,eAAtB;IACD;;IAED,KAAKC,UAAL,CAAgB/B,EAAhB,EAAoBD,UAApB;IAEA,OAAO4B,MAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEK,oBAAoB,CAACjC,UAAD,EAAa;IAC/B,MAAMjF,KAAK,GAAG,KAAKwD,QAAL,EAAd;IACA,MAAM+B,YAAY,GAAGvF,KAAK,CAAC8D,SAAN,EAArB;IACA,MAAMwB,SAAS,GAAGL,UAAU,CAACK,SAA7B;IACA,MAAM6B,aAAa,GACjB,CAAClC,UAAU,CAACmC,SAAX,CAAqBrJ,QAAQ,CAACsJ,SAA9B,CAAD,IACA,CAACpC,UAAU,CAACmC,SAAX,CAAqBrJ,QAAQ,CAACuJ,WAA9B,CAFH;IAGA,MAAMC,aAAa,GAAG,CAACjI,MAAM,CAAC,KAAK0C,eAAN,EAAuBiD,UAAU,CAACY,MAAlC,CAA7B;IACA,MAAM2B,aAAa,GAAG,KAAKjH,eAAL,GAAuBgF,YAAY,CAACkC,WAAb,EAA7C;;IAEA,IAAID,aAAJ,EAAmB;MACjB,KAAKjH,eAAL,GAAuBgF,YAAY,CAACkC,WAAb,EAAvB;IACD;;IAED,IAAIN,aAAa,KAAKI,aAAa,IAAIC,aAAtB,CAAjB,EAAuD;MACrD,MAAMnC,UAAU,GAAGC,SAAS,CAACD,UAA7B;MACA,MAAMqC,UAAU,GAAGpC,SAAS,CAACoC,UAA7B;MAEA,MAAMC,YAAY,GAChB3H,KAAK,YAAYnC,UAAjB,GAA8BmC,KAAK,CAAC4H,eAAN,EAA9B,GAAwD,CAD1D;MAEA,MAAM/B,MAAM,GAAGzG,MAAM,CAAC6F,UAAU,CAACY,MAAZ,EAAoB8B,YAAY,GAAGD,UAAnC,CAArB;MACAnC,YAAY,CAACsC,YAAb,CAA0BhC,MAA1B,EAAkC6B,UAAlC,EAA8CrC,UAA9C;MAEA,KAAKyC,eAAL,CAAqB7C,UAArB;MACA,KAAKjD,eAAL,GAAuBiD,UAAU,CAACY,MAAX,CAAkBkC,KAAlB,EAAvB;IACD;;IAED,KAAK5E,MAAL,CAAY6E,UAAZ,CAAuB,KAAKjH,QAA5B,EAAsCkE,UAAtC;IACA,KAAK9B,MAAL,CAAY8E,WAAZ,CAAwBhD,UAAxB,EA5B+B,CA8B/B;;IACA,KAAK9B,MAAL,CAAY+E,UAAZ,CAAuB,KAAK1H,eAA5B;IACA,KAAK2C,MAAL,CAAY+E,UAAZ,CAAuB,KAAKxH,cAA5B;IACA,KAAKyC,MAAL,CAAYgF,gBAAZ,CAA6B,KAAK5G,UAAlC;IAEA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEuG,eAAe,CAAC7C,UAAD,EAAa;IAC1B;IACA,MAAMlC,mBAAmB,GAAGnE,eAAe,EAA3C;IACA,KAAKuE,MAAL,CAAYoD,uBAAZ,CAAoCtB,UAApC,EAAgDlC,mBAAhD,EAH0B,CAK1B;IACA;IACA;IACA;;IACA,MAAMqF,sBAAsB,GAC1B,CAAC,IAAI,KAAK9G,gBAAL,CAAsB+G,MAA3B,IAAqC,KAAKzE,aAD5C;;IAEA,IACE,CAAC,KAAKxB,mBAAN,IACA,KAAKA,mBAAL,CAAyBiG,MAAzB,KAAoCD,sBAFtC,EAGE;MACA,KAAKhG,mBAAL,GAA2B,IAAIC,YAAJ,CAAiB+F,sBAAjB,CAA3B;IACD;;IACD,IAAI,KAAKpH,oBAAT,EAA+B;MAC7B,MAAMsH,yBAAyB,GAC7B,CAAC,IAAI,KAAKhH,gBAAL,CAAsB+G,MAA3B,IAAqC,KAAKzE,aAD5C;;MAEA,IACE,CAAC,KAAKtB,sBAAN,IACA,KAAKA,sBAAL,CAA4B+F,MAA5B,KAAuCC,yBAFzC,EAGE;QACA,KAAKhG,sBAAL,GAA8B,IAAID,YAAJ,CAC5BiG,yBAD4B,CAA9B;MAGD;IACF,CA5ByB,CA8B1B;;;IACA,IAAIC,YAAJ,EAAkB3D,QAAlB;IACA,MAAM4D,SAAS,GAAG,EAAlB;IACA,MAAMC,QAAQ,GAAG,EAAjB;IACA,IAAIC,WAAW,GAAG,CAAlB;IACA,IAAIC,QAAQ,GAAG,CAAf;IACA,IAAIC,QAAJ;;IACA,KAAK,MAAMC,UAAX,IAAyB,KAAKlF,aAA9B,EAA6C;MAC3C4E,YAAY,GAAG,KAAK5E,aAAL,CAAmBkF,UAAnB,CAAf;MACAjE,QAAQ;MAAG;MACT2D,YAAY,CAAC3D,QADf;;MAGA,IAAI,CAACA,QAAD,IAAaA,QAAQ,CAACkE,OAAT,OAAuB,OAAxC,EAAiD;QAC/C;MACD;;MAEDN,SAAS,CAAC,CAAD,CAAT,GAAe5D,QAAQ,CAACmE,kBAAT,GAA8B,CAA9B,CAAf;MACAP,SAAS,CAAC,CAAD,CAAT,GAAe5D,QAAQ,CAACmE,kBAAT,GAA8B,CAA9B,CAAf;MACArK,cAAc,CAACqE,mBAAD,EAAsByF,SAAtB,CAAd;MAEAI,QAAQ,GAAGnJ,aAAa,CAACkJ,QAAQ,GAAG,CAAZ,EAAeF,QAAf,CAAxB;MAEA,KAAKrG,mBAAL,CAAyBsG,WAAW,EAApC,IAA0CF,SAAS,CAAC,CAAD,CAAnD;MACA,KAAKpG,mBAAL,CAAyBsG,WAAW,EAApC,IAA0CF,SAAS,CAAC,CAAD,CAAnD,CAhB2C,CAkB3C;MACA;;MACA,IAAI,KAAKxH,oBAAT,EAA+B;QAC7B,KAAKsB,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CH,SAAS,CAAC,CAAD,CAAnD;QACA,KAAKlG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CH,SAAS,CAAC,CAAD,CAAnD;QACA,KAAKlG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CC,QAAQ,CAAC,CAAD,CAAlD;QACA,KAAKtG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CC,QAAQ,CAAC,CAAD,CAAlD;QACA,KAAKtG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CC,QAAQ,CAAC,CAAD,CAAlD;QACA,KAAKtG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CC,QAAQ,CAAC,CAAD,CAAlD;QACA,KAAKtG,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CK,MAAM,CAACH,UAAD,CAAhD;MACD,CA5B0C,CA8B3C;;;MACA,IAAII,KAAJ;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5H,gBAAL,CAAsB+G,MAA1C,EAAkDa,CAAC,EAAnD,EAAuD;QACrDD,KAAK,GAAG,KAAK3H,gBAAL,CAAsB4H,CAAtB,EAAyBC,QAAzB,CACNZ,YAAY,CAAC9D,OADP,EAEN8D,YAAY,CAAC7D,UAFP,CAAR;QAIA,KAAKtC,mBAAL,CAAyBsG,WAAW,EAApC,IAA0CO,KAA1C;;QACA,IAAI,KAAKjI,oBAAT,EAA+B;UAC7B,KAAKsB,sBAAL,CAA4BqG,QAAQ,EAApC,IAA0CM,KAA1C;QACD;MACF;IACF;IAED;;;IACA,MAAMG,OAAO,GAAG;MACdC,EAAE,EAAE,CADU;MAEdzH,IAAI,EAAEpD,sBAAsB,CAACsE,sBAFf;MAGdQ,kBAAkB,EAAE,KAAKlB,mBAAL,CAAyBhD,MAH/B;MAIdkK,qBAAqB,EAAE,KAAKhI,gBAAL,CAAsB+G;IAJ/B,CAAhB,CAlF0B,CAwF1B;;IACAe,OAAO,CAAC,qBAAD,CAAP,GAAiCrG,mBAAjC;IACAqG,OAAO,CAAC,oBAAD,CAAP,GAAgC,EAAE,KAAK5G,mBAAvC;IACA,KAAKlC,KAAL,GAAa,KAAb;IACA,KAAKmC,OAAL,CAAa8G,WAAb,CAAyBH,OAAzB,EAAkC,CAAC,KAAKhH,mBAAL,CAAyBhD,MAA1B,CAAlC;IACA,KAAKgD,mBAAL,GAA2B,IAA3B;IAEA;;IACA,IAAI,KAAKpB,oBAAT,EAA+B;MAC7B,MAAMwI,UAAU,GAAG;QACjBH,EAAE,EAAE,CADa;QAEjBzH,IAAI,EAAEpD,sBAAsB,CAACsE,sBAFZ;QAGjBQ,kBAAkB,EAAE,KAAKhB,sBAAL,CAA4BlD,MAH/B;QAIjBkK,qBAAqB,EAAE,IAAI,KAAKhI,gBAAL,CAAsB+G;MAJhC,CAAnB;MAMAmB,UAAU,CAAC,qBAAD,CAAV,GAAoCzG,mBAApC;MACAyG,UAAU,CAAC,cAAD,CAAV,GAA6B,IAA7B;MACA,KAAK/G,OAAL,CAAa8G,WAAb,CAAyBC,UAAzB,EAAqC,CACnC,KAAKlH,sBAAL,CAA4BlD,MADO,CAArC;MAGA,KAAKkD,sBAAL,GAA8B,IAA9B;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEmH,0BAA0B,CACxBC,UADwB,EAExBzE,UAFwB,EAGxB0E,YAHwB,EAIxBR,QAJwB,EAKxBS,OALwB,EAMxB;IACAzK,MAAM,CAAC,KAAK6B,oBAAN,EAA4B,EAA5B,CAAN;;IACA,IAAI,CAAC,KAAKsB,sBAAV,EAAkC;MAChC,OAAOuH,SAAP;IACD;;IAED,MAAMC,KAAK,GAAGpL,cAAc,CAC1BuG,UAAU,CAAC8E,0BADe,EAE1BL,UAAU,CAAC3B,KAAX,EAF0B,CAA5B;IAKA,MAAMlF,IAAI,GAAG,KAAKN,gBAAL,CAAsByH,SAAtB,CAAgCF,KAAK,CAAC,CAAD,CAAL,GAAW,CAA3C,EAA8CA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAzD,CAAb;IACA,MAAMG,KAAK,GAAG,CAACpH,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAX,EAAgBA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAA1B,EAA+BA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAzC,EAA8CA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAxD,CAAd;IACA,MAAMqH,KAAK,GAAG1K,aAAa,CAACyK,KAAD,CAA3B;IACA,MAAME,OAAO,GAAG,KAAK7H,sBAAL,CAA4B4H,KAA5B,CAAhB;IACA,MAAME,GAAG,GAAGpE,IAAI,CAACG,KAAL,CAAWgE,OAAX,EAAoBE,QAApB,EAAZ;IAEA,MAAMxG,MAAM,GAAG,KAAKL,QAAL,GAAgBM,SAAhB,EAAf;IACA,MAAMW,OAAO,GAAGZ,MAAM,CAACyG,eAAP,CAAuBF,GAAvB,CAAhB;;IACA,IAAI3F,OAAJ,EAAa;MACX,OAAO0E,QAAQ,CAAC1E,OAAD,EAAU,KAAKjB,QAAL,EAAV,EAA2B,IAA3B,CAAf;IACD;;IACD,OAAOqG,SAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACE9C,kBAAkB,CAAC9B,UAAD,EAAaiB,UAAb,EAAyBH,QAAzB,EAAmCD,UAAnC,EAA+C;IAC/D;IACA,IAAI,CAAC,KAAKrF,kBAAL,CAAwB6F,OAAxB,EAAL,EAAwC;MACtC;IACD;;IAED,IAAIF,KAAK,GAAGF,UAAZ;IAEA,KAAK3D,gBAAL,CAAsBgI,OAAtB,CAA8B,CAC5BvE,IAAI,CAACG,KAAL,CAAWlB,UAAU,CAACtD,IAAX,CAAgB,CAAhB,IAAqB,CAAhC,CAD4B,EAE5BqE,IAAI,CAACG,KAAL,CAAWlB,UAAU,CAACtD,IAAX,CAAgB,CAAhB,IAAqB,CAAhC,CAF4B,CAA9B;IAKA,KAAKwB,MAAL,CAAY6E,UAAZ,CAAuB,KAAK3G,WAA5B,EAAyC4D,UAAzC;IACA,KAAK9B,MAAL,CAAYqH,yBAAZ,CACEvF,UADF,EAEE,KAAK1C,gBAFP,EAGE,IAHF;IAMA,KAAKY,MAAL,CAAY+E,UAAZ,CAAuB,KAAKzH,kBAA5B;IACA,KAAK0C,MAAL,CAAY+E,UAAZ,CAAuB,KAAKxH,cAA5B;IACA,KAAKyC,MAAL,CAAYgF,gBAAZ,CAA6B,KAAKpG,sBAAlC;;IAEA,GAAG;MACD,KAAKoB,MAAL,CAAYoD,uBAAZ,CAAoCtB,UAApC,EAAgD,KAAKhD,iBAArD;MACA/C,kBAAkB,CAAC,KAAK+C,iBAAN,EAAyBmE,KAAK,GAAGN,UAAjC,EAA6C,CAA7C,CAAlB;MACA9G,iBAAiB,CAAC,KAAKiD,iBAAN,EAAyB,KAAKE,sBAA9B,CAAjB;MACA,KAAKgB,MAAL,CAAYqD,aAAZ,CAA0BvB,UAA1B;MAEA,MAAMoB,WAAW,GAAG,KAAK3F,cAAL,CAAoB4F,OAApB,EAApB;MACA,KAAKnD,MAAL,CAAYsD,YAAZ,CAAyB,CAAzB,EAA4BJ,WAA5B;IACD,CARD,QAQS,EAAED,KAAF,GAAUL,QARnB;EASD;EAED;AACF;AACA;;;EACE0E,eAAe,GAAG;IAChB,KAAKhI,OAAL,CAAaiI,SAAb;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAK5G,iBAAL,CAAuB6G,OAAvB,CAA+B,UAAUC,GAAV,EAAe;MAC5ChL,aAAa,CAACgL,GAAD,CAAb;IACD,CAFD;IAGA,KAAK9G,iBAAL,GAAyB,IAAzB;IACA,MAAM0G,eAAN;EACD;;AAnoBuD;;AAsoB1D,eAAe3K,wBAAf"},"metadata":{},"sourceType":"module"}