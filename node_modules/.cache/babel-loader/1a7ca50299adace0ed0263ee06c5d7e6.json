{"ast":null,"code":"/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\n\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n\n  return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\n\n\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    const fileDirectory = image.fileDirectory;\n    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\n\n\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\n\n\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth, referenceImage.fileDirectory.ImageHeight / image.fileDirectory.ImageHeight];\n  }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\n\n\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (geoKeys.ProjectedCSTypeGeoKey) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n\n    return Promise.all(requests);\n  });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForSource(source, options) {\n  let request;\n\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n\n  return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\n\n\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n\n    return;\n  }\n\n  got =\n  /** @type {number} */\n  got;\n\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\n\n\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n\n  return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\n\n\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n\n  return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\n\n\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    });\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n\n    this.sourceInfo_ = options.sources;\n    const numSources = this.sourceInfo_.length;\n    /**\n     * @type {Object}\n     * @private\n     */\n\n    this.sourceOptions_ = options.sourceOptions;\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n\n    this.sourceImagery_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.resolutionFactors_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.samplesPerPixel_;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n\n    this.nodataValues_;\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n\n    this.metadata_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.normalize_ = options.normalize !== false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.addAlpha_ = false;\n    /**\n     * @type {Error}\n     * @private\n     */\n\n    this.error_ = null;\n    /**\n     * @type {'readRasters' | 'readRGB'}\n     */\n\n    this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n    this.setKey(this.sourceInfo_.map(source => source.url).join(','));\n    const self = this;\n    const requests = new Array(numSources);\n\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(this.sourceInfo_[i], this.sourceOptions_);\n    }\n\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    }).catch(function (error) {\n      console.error(error); // eslint-disable-line no-console\n\n      self.error_ = error;\n      self.setState('error');\n    });\n  }\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n\n\n  getError() {\n    return this.error_;\n  }\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n\n\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n    const sourceCount = sources.length;\n\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = sources[sourceIndex];\n      const imageCount = images.length;\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n        sourceTileSizes[level] = sourceTileSize;\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n\n        const resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(resolution => resolution *= resolutionFactor);\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this.viewRejector);\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      const firstSource = sources[0];\n\n      for (let i = firstSource.length - 1; i >= 0; --i) {\n        const image = firstSource[i];\n        const projection = getProjection(image);\n\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata; // decide if we need to add an alpha band to handle nodata\n\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex]; // option 2: check image metadata for limited bands\n\n      const bands = this.sourceInfo_[sourceIndex].bands;\n\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n\n        continue;\n      } // option 3: check image metadata for all bands\n\n\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    const additionalBands = this.addAlpha_ ? 1 : 0;\n    this.bandCount = samplesPerPixel.reduce((accumulator, value) => {\n      accumulator += value;\n      return accumulator;\n    }, 0) + additionalBands;\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes\n    });\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n    this.viewResolver({\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: 0\n    });\n  }\n\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount);\n    const addAlpha = this.addAlpha_;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n      /** @type {number|Array<number>} */\n\n\n      let fillValue;\n\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      requests[sourceIndex] = image[this.readMethod_]({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: getWorkerPool(),\n        interleave: false\n      });\n    }\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n    const normalize = this.normalize_;\n    const metadata = this.metadata_;\n    return Promise.all(requests).then(function (sourceSamples) {\n      /** @type {Uint8Array|Float32Array} */\n      let data;\n\n      if (normalize) {\n        data = new Uint8Array(dataLength);\n      } else {\n        data = new Float32Array(dataLength);\n      }\n\n      let dataIndex = 0;\n\n      for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n        let transparent = addAlpha;\n\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n          const source = sourceInfo[sourceIndex];\n          let min = source.min;\n          let max = source.max;\n          let gain, bias;\n\n          if (normalize) {\n            const stats = metadata[sourceIndex][0];\n\n            if (min === undefined) {\n              if (stats && STATISTICS_MINIMUM in stats) {\n                min = parseFloat(stats[STATISTICS_MINIMUM]);\n              } else {\n                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            if (max === undefined) {\n              if (stats && STATISTICS_MAXIMUM in stats) {\n                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n              } else {\n                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            gain = 255 / (max - min);\n            bias = -min * gain;\n          }\n\n          for (let sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n            const sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n            let value;\n\n            if (normalize) {\n              value = clamp(gain * sourceValue + bias, 0, 255);\n            } else {\n              value = sourceValue;\n            }\n\n            if (!addAlpha) {\n              data[dataIndex] = value;\n            } else {\n              let nodata = source.nodata;\n\n              if (nodata === undefined) {\n                let bandIndex;\n\n                if (source.bands) {\n                  bandIndex = source.bands[sampleIndex] - 1;\n                } else {\n                  bandIndex = sampleIndex;\n                }\n\n                nodata = nodataValues[sourceIndex][bandIndex];\n              }\n\n              const nodataIsNaN = isNaN(nodata);\n\n              if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {\n                transparent = false;\n                data[dataIndex] = value;\n              }\n            }\n\n            dataIndex++;\n          }\n        }\n\n        if (addAlpha) {\n          if (!transparent) {\n            data[dataIndex] = 255;\n          }\n\n          dataIndex++;\n        }\n      }\n\n      return data;\n    }).catch(function (error) {\n      // output then rethrow\n      console.error(error); // eslint-disable-line no-console\n\n      throw error;\n    });\n  }\n\n}\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\n\n\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"names":["DataTile","TileGrid","Pool","fromBlob","tiffFromBlob","fromUrl","tiffFromUrl","fromUrls","tiffFromUrls","Projection","get","getCachedProjection","toUserCoordinate","toUserExtent","clamp","getCenter","getIntersection","fromCode","unitsFromCode","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","workerPool","getWorkerPool","getBoundingBox","image","_","fileDirectory","ImageWidth","ImageLength","getOrigin","slice","getResolutions","referenceImage","getResolution","ImageHeight","getProjection","geoKeys","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","Array","i","getImage","Promise","all","getImagesForSource","source","options","request","blob","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","length","error","Error","Math","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","GeoTIFFSource","constructor","state","tileGrid","opaque","transition","interpolate","wrapX","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","readMethod_","convertToRGB","setKey","map","join","self","configure_","catch","console","setState","getError","extent","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","wantedSamples","bands","getSamplesPerPixel","level","imageResolutions","sourceTileSize","getTileWidth","getTileHeight","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","undefined","firstSource","outer","nodata","values","additionalBands","bandCount","reduce","accumulator","value","tileSizes","setTileSizes","setLoader","loadTile_","bind","viewResolver","center","zoom","z","x","y","getTileSize","addAlpha","sourceInfo","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","window","width","height","pool","interleave","pixelCount","dataLength","sourceSamples","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","parseFloat","sourceValue","bandIndex","nodataIsNaN","isNaN","prototype","getView"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/source/GeoTIFF.js"],"sourcesContent":["/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  Pool,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n} from 'geotiff';\nimport {\n  Projection,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {clamp} from '../math.js';\nimport {getCenter, getIntersection} from '../extent.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    const fileDirectory = image.fileDirectory;\n    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.fileDirectory.ImageLength];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [\n      referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth,\n      referenceImage.fileDirectory.ImageHeight /\n        image.fileDirectory.ImageHeight,\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (geoKeys.ProjectedCSTypeGeoKey) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {'readRasters' | 'readRGB'}\n     */\n    this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        console.error(error); // eslint-disable-line no-console\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = sources[sourceIndex];\n      const imageCount = images.length;\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor)\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      const firstSource = sources[0];\n      for (let i = firstSource.length - 1; i >= 0; --i) {\n        const image = firstSource[i];\n        const projection = getProjection(image);\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    const additionalBands = this.addAlpha_ ? 1 : 0;\n    this.bandCount =\n      samplesPerPixel.reduce((accumulator, value) => {\n        accumulator += value;\n        return accumulator;\n      }, 0) + additionalBands;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n    this.viewResolver({\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: 0,\n    });\n  }\n\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount);\n    const addAlpha = this.addAlpha_;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      requests[sourceIndex] = image[this.readMethod_]({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: getWorkerPool(),\n        interleave: false,\n      });\n    }\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n    const normalize = this.normalize_;\n    const metadata = this.metadata_;\n\n    return Promise.all(requests)\n      .then(function (sourceSamples) {\n        /** @type {Uint8Array|Float32Array} */\n        let data;\n        if (normalize) {\n          data = new Uint8Array(dataLength);\n        } else {\n          data = new Float32Array(dataLength);\n        }\n\n        let dataIndex = 0;\n        for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n          let transparent = addAlpha;\n          for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            const source = sourceInfo[sourceIndex];\n\n            let min = source.min;\n            let max = source.max;\n            let gain, bias;\n            if (normalize) {\n              const stats = metadata[sourceIndex][0];\n              if (min === undefined) {\n                if (stats && STATISTICS_MINIMUM in stats) {\n                  min = parseFloat(stats[STATISTICS_MINIMUM]);\n                } else {\n                  min = getMinForDataType(sourceSamples[sourceIndex][0]);\n                }\n              }\n              if (max === undefined) {\n                if (stats && STATISTICS_MAXIMUM in stats) {\n                  max = parseFloat(stats[STATISTICS_MAXIMUM]);\n                } else {\n                  max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n                }\n              }\n\n              gain = 255 / (max - min);\n              bias = -min * gain;\n            }\n\n            for (\n              let sampleIndex = 0;\n              sampleIndex < samplesPerPixel[sourceIndex];\n              ++sampleIndex\n            ) {\n              const sourceValue =\n                sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n              let value;\n              if (normalize) {\n                value = clamp(gain * sourceValue + bias, 0, 255);\n              } else {\n                value = sourceValue;\n              }\n\n              if (!addAlpha) {\n                data[dataIndex] = value;\n              } else {\n                let nodata = source.nodata;\n                if (nodata === undefined) {\n                  let bandIndex;\n                  if (source.bands) {\n                    bandIndex = source.bands[sampleIndex] - 1;\n                  } else {\n                    bandIndex = sampleIndex;\n                  }\n                  nodata = nodataValues[sourceIndex][bandIndex];\n                }\n\n                const nodataIsNaN = isNaN(nodata);\n                if (\n                  (!nodataIsNaN && sourceValue !== nodata) ||\n                  (nodataIsNaN && !isNaN(sourceValue))\n                ) {\n                  transparent = false;\n                  data[dataIndex] = value;\n                }\n              }\n              dataIndex++;\n            }\n          }\n          if (addAlpha) {\n            if (!transparent) {\n              data[dataIndex] = 255;\n            }\n            dataIndex++;\n          }\n        }\n\n        return data;\n      })\n      .catch(function (error) {\n        // output then rethrow\n        console.error(error); // eslint-disable-line no-console\n        throw error;\n      });\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}