{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate); // Keep text upright\n\n  let reverse;\n\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  let previousAngle; // All on the same segment\n\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  } // rendering across line segments\n\n\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii;) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    const iStart = i;\n    let charLength = 0;\n\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n\n      charLength += len;\n    }\n\n    if (i === iStart) {\n      continue;\n    }\n\n    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n\n  return result;\n}","map":{"version":3,"names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","reverse","flat","PI","result","singleSegment","previousAngle","atan2","x","y","replace","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation\n) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate =\n    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii; ) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (\n        offset + stride < end &&\n        segmentM + segmentLength < startM + charLength + len / 2\n      ) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse\n      ? text.substring(ii - iStart, ii - i)\n      : text.substring(iStart, i);\n    interpolate =\n      segmentLength === 0\n        ? 0\n        : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}