{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextAlign, defaultTextBaseline, drawImageOrLabel, getTextDimensions, measureAndCacheTextWidth } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\n\nconst tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nconst p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nconst p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nconst p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nconst p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\n\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nconst rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {CanvasTextAlign} align Alignment.\n * @return {number} Text alignment.\n */\n\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n\n  return TEXT_ALIGN[align];\n}\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\n\n\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n\n  acc.push(line, '');\n  return acc;\n}\n\nclass Executor {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  constructor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n\n    this.labels_ = {};\n  }\n  /**\n   * @param {string|Array<string>} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n\n\n  createLabel(text, textKey, fillKey, strokeKey) {\n    const key = text + textKey + fillKey + strokeKey;\n\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\n    const textState = this.textStates[textKey];\n    const pixelRatio = this.pixelRatio;\n    const scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    const textIsArray = Array.isArray(text);\n    const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    const chunks = textIsArray ? text : text.split('\\n').reduce(createTextChunks, []);\n    const {\n      width,\n      height,\n      widths,\n      heights,\n      lineWidths\n    } = getTextDimensions(textState, chunks);\n    const renderWidth = width + strokeWidth;\n    const contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors\n\n    const w = (renderWidth + 2) * scale[0];\n    const h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n\n    const label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      contextInstructions.push('setLineDash', [strokeState.lineDash]);\n      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n    }\n\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    const leftRight = 0.5 - align;\n    let x = align * renderWidth + leftRight * strokeWidth;\n    const strokeInstructions = [];\n    const fillInstructions = [];\n    let lineHeight = 0;\n    let lineOffset = 0;\n    let widthHeightIndex = 0;\n    let lineWidthIndex = 0;\n    let previousFont;\n\n    for (let i = 0, ii = chunks.length; i < ii; i += 2) {\n      const text = chunks[i];\n\n      if (text === '\\n') {\n        lineOffset += lineHeight;\n        lineHeight = 0;\n        x = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n\n      const font = chunks[i + 1] || textState.font;\n\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push('font', font);\n        }\n\n        if (fillKey) {\n          fillInstructions.push('font', font);\n        }\n\n        previousFont = font;\n      }\n\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n      const fillStrokeArgs = [text, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];\n      x += widths[widthHeightIndex];\n\n      if (strokeKey) {\n        strokeInstructions.push('strokeText', fillStrokeArgs);\n      }\n\n      if (fillKey) {\n        fillInstructions.push('fillText', fillStrokeArgs);\n      }\n\n      ++widthHeightIndex;\n    }\n\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ =\n      /** @type {boolean} */\n      fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context,\n      /** @type {Array<*>} */\n      strokeInstruction);\n      context.stroke();\n    }\n  }\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n\n\n  calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    let x = centerX - anchorX;\n    let y = centerY - anchorY;\n    const w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    const h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    const boxW = padding[3] + w * scale[0] + padding[1];\n    const boxH = padding[0] + h * scale[1] + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    let transform;\n\n    if (rotation !== 0) {\n      transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature\n      },\n      canvasTransform: transform,\n      scale: scale\n    };\n  }\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n\n\n  replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n    const fillStroke = !!(fillInstruction || strokeInstruction);\n    const box = dimensions.declutterBox;\n    const canvas = context.canvas;\n    const strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n    const intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n        /** @type {Array<*>} */\n        fillInstruction,\n        /** @type {Array<*>} */\n        strokeInstruction);\n      }\n\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n\n    return true;\n  }\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  fill_(context) {\n    if (this.alignFill_) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.restore();\n    }\n  }\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  setStrokeStyle_(context, instruction) {\n    context['strokeStyle'] =\n    /** @type {import(\"../../colorlike.js\").ColorLike} */\n    instruction[1];\n    context.lineWidth =\n    /** @type {number} */\n    instruction[2];\n    context.lineCap =\n    /** @type {CanvasLineCap} */\n    instruction[3];\n    context.lineJoin =\n    /** @type {CanvasLineJoin} */\n    instruction[4];\n    context.miterLimit =\n    /** @type {number} */\n    instruction[5];\n    context.lineDashOffset =\n    /** @type {number} */\n    instruction[7];\n    context.setLineDash(\n    /** @type {Array<number>} */\n    instruction[6]);\n  }\n  /**\n   * @private\n   * @param {string|Array<string>} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n\n\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n    const textState = this.textStates[textKey];\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\n    const strokeState = this.strokeStates[strokeKey];\n    const pixelRatio = this.pixelRatio;\n    const align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor\n\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  }\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    let i = 0; // instruction index\n\n    const ii = instructions.length; // end of instructions\n\n    let d = 0; // data index\n\n    let dd; // end of per-instruction data\n\n    let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n    const viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    const state =\n    /** @type {import(\"../../render.js\").State} */\n    {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    let\n    /** @type {import(\"../../Feature.js\").FeatureLike} */\n    feature;\n    let x, y, currentGeometry;\n\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type =\n      /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature =\n          /** @type {import(\"../../Feature.js\").FeatureLike} */\n          instruction[1];\n          currentGeometry = instruction[3];\n\n          if (!feature.getGeometry()) {\n            i =\n            /** @type {number} */\n            instruction[2];\n          } else if (hitExtent !== undefined && !intersects(hitExtent, currentGeometry.getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd = instruction[2];\n          const geometry =\n          /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n          instruction[3];\n          const renderer = instruction[4];\n          const fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          const coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          image =\n          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX =\n          /** @type {number} */\n          instruction[4];\n          anchorY =\n          /** @type {number} */\n          instruction[5];\n          let height =\n          /** @type {number} */\n          instruction[6];\n          const opacity =\n          /** @type {number} */\n          instruction[7];\n          const originX =\n          /** @type {number} */\n          instruction[8];\n          const originY =\n          /** @type {number} */\n          instruction[9];\n          const rotateWithView =\n          /** @type {boolean} */\n          instruction[10];\n          let rotation =\n          /** @type {number} */\n          instruction[11];\n          const scale =\n          /** @type {import(\"../../size.js\").Size} */\n          instruction[12];\n          let width =\n          /** @type {number} */\n          instruction[13];\n          const declutterMode =\n          /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */\n          instruction[14];\n          const declutterImageWithText =\n          /** @type {import(\"../canvas.js\").DeclutterImageWithText} */\n          instruction[15];\n\n          if (!image && instruction.length >= 20) {\n            // create label images\n            text =\n            /** @type {string} */\n            instruction[19];\n            textKey =\n            /** @type {string} */\n            instruction[20];\n            strokeKey =\n            /** @type {string} */\n            instruction[21];\n            fillKey =\n            /** @type {string} */\n            instruction[22];\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            const textOffsetX =\n            /** @type {number} */\n            instruction[23];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            const textOffsetY =\n            /** @type {number} */\n            instruction[24];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          let geometryWidths;\n\n          if (instruction.length > 25) {\n            geometryWidths =\n            /** @type {number} */\n            instruction[25];\n          }\n\n          let padding, backgroundFill, backgroundStroke;\n\n          if (instruction.length > 17) {\n            padding =\n            /** @type {Array<number>} */\n            instruction[16];\n            backgroundFill =\n            /** @type {boolean} */\n            instruction[17];\n            backgroundStroke =\n            /** @type {boolean} */\n            instruction[18];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n\n          let widthIndex = 0;\n\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n\n            const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n            /** @type {ReplayImageOrLabelArgs} */\n\n            const args = [context, contextScale, image, dimensions, opacity, backgroundFill ?\n            /** @type {Array<*>} */\n            lastFillInstruction : null, backgroundStroke ?\n            /** @type {Array<*>} */\n            lastStrokeInstruction : null];\n\n            if (declutterTree) {\n              if (declutterMode === 'none') {\n                // not rendered in declutter group\n                continue;\n              } else if (declutterMode === 'obstacle') {\n                // will always be drawn, thus no collision detection, but insert as obstacle\n                declutterTree.insert(dimensions.declutterBox);\n                continue;\n              } else {\n                let imageArgs;\n                let imageDeclutterBox;\n\n                if (declutterImageWithText) {\n                  const index = dd - d;\n\n                  if (!declutterImageWithText[index]) {\n                    // We now have the image for an image+text combination.\n                    declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.\n\n                    continue;\n                  }\n\n                  imageArgs = declutterImageWithText[index];\n                  delete declutterImageWithText[index];\n                  imageDeclutterBox = getDeclutterBox(imageArgs);\n\n                  if (declutterTree.collides(imageDeclutterBox)) {\n                    continue;\n                  }\n                }\n\n                if (declutterTree.collides(dimensions.declutterBox)) {\n                  continue;\n                }\n\n                if (imageArgs) {\n                  // We now have image and text for an image+text combination.\n                  declutterTree.insert(imageDeclutterBox); // Render the image before we render the text.\n\n                  this.replayImageOrLabel_.apply(this, imageArgs);\n                }\n\n                declutterTree.insert(dimensions.declutterBox);\n              }\n            }\n\n            this.replayImageOrLabel_.apply(this, args);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          const begin =\n          /** @type {number} */\n          instruction[1];\n          const end =\n          /** @type {number} */\n          instruction[2];\n          const baseline =\n          /** @type {number} */\n          instruction[3];\n          const overflow =\n          /** @type {number} */\n          instruction[4];\n          fillKey =\n          /** @type {string} */\n          instruction[5];\n          const maxAngle =\n          /** @type {number} */\n          instruction[6];\n          const measurePixelRatio =\n          /** @type {number} */\n          instruction[7];\n          const offsetY =\n          /** @type {number} */\n          instruction[8];\n          strokeKey =\n          /** @type {string} */\n          instruction[9];\n          const strokeWidth =\n          /** @type {number} */\n          instruction[10];\n          text =\n          /** @type {string} */\n          instruction[11];\n          textKey =\n          /** @type {string} */\n          instruction[12];\n          const pixelRatioScale = [\n          /** @type {number} */\n          instruction[13],\n          /** @type {number} */\n          instruction[13]];\n          const textState = this.textStates[textKey];\n          const font = textState.font;\n          const textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          let cachedWidths;\n\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n\n          if (overflow || textLength <= pathLength) {\n            const textAlign = this.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            const parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              const replayImageOrLabelArgs = [];\n              let c, cc, chars, label, part;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX =\n                  /** @type {number} */\n                  part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (declutterTree) {\n                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n\n              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);\n              }\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature =\n            /** @type {import(\"../../Feature.js\").FeatureLike} */\n            instruction[1];\n            const result = featureCallback(feature, currentGeometry);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n          /** @type {import(\"../../colorlike.js\").ColorLike} */\n          instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context,\n          /** @type {Array<*>} */\n          instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          // consume the instruction anyway, to avoid an infinite loop\n          ++i;\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n\n\n  execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);\n  }\n\n}\n\nexport default Executor;","map":{"version":3,"names":["CanvasInstruction","TEXT_ALIGN","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","intersects","defaultPadding","defaultTextAlign","defaultTextBaseline","drawImageOrLabel","getTextDimensions","measureAndCacheTextWidth","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","p1","p2","p3","p4","getDeclutterBox","replayImageOrLabelArgs","declutterBox","rtlRegEx","RegExp","String","fromCharCode","horizontalTextAlign","text","align","test","createTextChunks","acc","line","i","push","Executor","constructor","resolution","pixelRatio","overlaps","instructions","alignFill_","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","createLabel","textKey","fillKey","strokeKey","key","strokeState","fillState","textState","scale","textIsArray","Array","isArray","justify","textAlign","strokeWidth","lineWidth","chunks","split","reduce","width","height","widths","heights","lineWidths","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","strokeStyle","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","fillStyle","leftRight","x","strokeInstructions","fillInstructions","lineHeight","lineOffset","widthHeightIndex","lineWidthIndex","previousFont","ii","length","font","max","fillStrokeArgs","prototype","replayTextBackground_","context","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","calculateImageOrLabelDimensions_","sheetWidth","sheetHeight","centerX","centerY","anchorX","anchorY","originX","originY","rotation","snapToPixel","padding","fillStroke","feature","y","boxW","boxH","boxX","boxY","transform","min","round","drawImageX","drawImageY","drawImageW","drawImageH","minX","minY","maxX","maxY","value","canvasTransform","replayImageOrLabel_","contextScale","imageOrLabel","dimensions","opacity","box","canvas","strokePadding","origin","repeatSize","save","translate","rotate","fill","restore","instruction","setLineDash","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","featureCallback","hitExtent","declutterTree","pixelCoordinates","d","dd","prevX","prevY","roundX","roundY","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","currentGeometry","type","BEGIN_GEOMETRY","getGeometry","undefined","getExtent","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","declutterMode","declutterImageWithText","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","args","insert","imageArgs","imageDeclutterBox","index","collides","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","drawChars","c","cc","chars","part","load","map","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/canvas/Executor.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport {TEXT_ALIGN} from './TextBuilder.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  setFromArray as transformSetFromArray,\n} from '../../transform.js';\nimport {createEmpty, createOrUpdate, intersects} from '../../extent.js';\nimport {\n  defaultPadding,\n  defaultTextAlign,\n  defaultTextBaseline,\n  drawImageOrLabel,\n  getTextDimensions,\n  measureAndCacheTextWidth,\n} from '../canvas.js';\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\nimport {equals} from '../../array.js';\nimport {lineStringLength} from '../../geom/flat/length.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nconst tmpExtent = createEmpty();\n\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p4 = [];\n\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nconst rtlRegEx = new RegExp(\n  /* eslint-disable prettier/prettier */\n  '[' +\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\n  ']'\n  /* eslint-enable prettier/prettier */\n);\n\n/**\n * @param {string} text Text.\n * @param {CanvasTextAlign} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n  return TEXT_ALIGN[align];\n}\n\n/**\n * @param {Array<string>} acc Accumulator.\n * @param {string} line Line of text.\n * @param {number} i Index\n * @return {Array<string>} Accumulator.\n */\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n  acc.push(line, '');\n  return acc;\n}\n\nclass Executor {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  constructor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n\n  /**\n   * @param {string|Array<string>} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  createLabel(text, textKey, fillKey, strokeKey) {\n    const key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\n    const textState = this.textStates[textKey];\n    const pixelRatio = this.pixelRatio;\n    const scale = [\n      textState.scale[0] * pixelRatio,\n      textState.scale[1] * pixelRatio,\n    ];\n    const textIsArray = Array.isArray(text);\n    const align = textState.justify\n      ? TEXT_ALIGN[textState.justify]\n      : horizontalTextAlign(\n          Array.isArray(text) ? text[0] : text,\n          textState.textAlign || defaultTextAlign\n        );\n    const strokeWidth =\n      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    const chunks = textIsArray\n      ? text\n      : text.split('\\n').reduce(createTextChunks, []);\n\n    const {width, height, widths, heights, lineWidths} = getTextDimensions(\n      textState,\n      chunks\n    );\n    const renderWidth = width + strokeWidth;\n    const contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    const w = (renderWidth + 2) * scale[0];\n    const h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    const label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions,\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      contextInstructions.push('setLineDash', [strokeState.lineDash]);\n      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    const leftRight = 0.5 - align;\n    let x = align * renderWidth + leftRight * strokeWidth;\n    const strokeInstructions = [];\n    const fillInstructions = [];\n    let lineHeight = 0;\n    let lineOffset = 0;\n    let widthHeightIndex = 0;\n    let lineWidthIndex = 0;\n    let previousFont;\n    for (let i = 0, ii = chunks.length; i < ii; i += 2) {\n      const text = chunks[i];\n      if (text === '\\n') {\n        lineOffset += lineHeight;\n        lineHeight = 0;\n        x = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n      const font = chunks[i + 1] || textState.font;\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push('font', font);\n        }\n        if (fillKey) {\n          fillInstructions.push('font', font);\n        }\n        previousFont = font;\n      }\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n      const fillStrokeArgs = [\n        text,\n        x +\n          leftRight * widths[widthHeightIndex] +\n          align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),\n        0.5 * (strokeWidth + lineHeight) + lineOffset,\n      ];\n      x += widths[widthHeightIndex];\n      if (strokeKey) {\n        strokeInstructions.push('strokeText', fillStrokeArgs);\n      }\n      if (fillKey) {\n        fillInstructions.push('fillText', fillStrokeArgs);\n      }\n      ++widthHeightIndex;\n    }\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  replayTextBackground_(\n    context,\n    p1,\n    p2,\n    p3,\n    p4,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(\n        context,\n        /** @type {Array<*>} */ (strokeInstruction)\n      );\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n  calculateImageOrLabelDimensions_(\n    sheetWidth,\n    sheetHeight,\n    centerX,\n    centerY,\n    width,\n    height,\n    anchorX,\n    anchorY,\n    originX,\n    originY,\n    rotation,\n    scale,\n    snapToPixel,\n    padding,\n    fillStroke,\n    feature\n  ) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    let x = centerX - anchorX;\n    let y = centerY - anchorY;\n\n    const w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    const h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    const boxW = padding[3] + w * scale[0] + padding[1];\n    const boxH = padding[0] + h * scale[1] + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    let transform;\n    if (rotation !== 0) {\n      transform = composeTransform(\n        createTransform(),\n        centerX,\n        centerY,\n        1,\n        1,\n        rotation,\n        -centerX,\n        -centerY\n      );\n\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(\n        Math.min(p1[0], p2[0], p3[0], p4[0]),\n        Math.min(p1[1], p2[1], p3[1], p4[1]),\n        Math.max(p1[0], p2[0], p3[0], p4[0]),\n        Math.max(p1[1], p2[1], p3[1], p4[1]),\n        tmpExtent\n      );\n    } else {\n      createOrUpdate(\n        Math.min(boxX, boxX + boxW),\n        Math.min(boxY, boxY + boxH),\n        Math.max(boxX, boxX + boxW),\n        Math.max(boxY, boxY + boxH),\n        tmpExtent\n      );\n    }\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature,\n      },\n      canvasTransform: transform,\n      scale: scale,\n    };\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n  replayImageOrLabel_(\n    context,\n    contextScale,\n    imageOrLabel,\n    dimensions,\n    opacity,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    const fillStroke = !!(fillInstruction || strokeInstruction);\n\n    const box = dimensions.declutterBox;\n    const canvas = context.canvas;\n    const strokePadding = strokeInstruction\n      ? (strokeInstruction[2] * dimensions.scale[0]) / 2\n      : 0;\n    const intersects =\n      box.minX - strokePadding <= canvas.width / contextScale &&\n      box.maxX + strokePadding >= 0 &&\n      box.minY - strokePadding <= canvas.height / contextScale &&\n      box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(\n          context,\n          p1,\n          p2,\n          p3,\n          p4,\n          /** @type {Array<*>} */ (fillInstruction),\n          /** @type {Array<*>} */ (strokeInstruction)\n        );\n      }\n      drawImageOrLabel(\n        context,\n        dimensions.canvasTransform,\n        opacity,\n        imageOrLabel,\n        dimensions.originX,\n        dimensions.originY,\n        dimensions.drawImageW,\n        dimensions.drawImageH,\n        dimensions.drawImageX,\n        dimensions.drawImageY,\n        dimensions.scale\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  fill_(context) {\n    if (this.alignFill_) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  setStrokeStyle_(context, instruction) {\n    context['strokeStyle'] =\n      /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    context.lineDashOffset = /** @type {number} */ (instruction[7]);\n    context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n  }\n\n  /**\n   * @private\n   * @param {string|Array<string>} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n    const textState = this.textStates[textKey];\n\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\n\n    const strokeState = this.strokeStates[strokeKey];\n    const pixelRatio = this.pixelRatio;\n    const align = horizontalTextAlign(\n      Array.isArray(text) ? text[0] : text,\n      textState.textAlign || defaultTextAlign\n    );\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    const strokeWidth =\n      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    const anchorY =\n      (baseline * label.height) / pixelRatio +\n      2 * (0.5 - baseline) * strokeWidth;\n\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY,\n    };\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  execute_(\n    context,\n    contextScale,\n    transform,\n    instructions,\n    snapToPixel,\n    featureCallback,\n    hitExtent,\n    declutterTree\n  ) {\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(\n        this.coordinates,\n        0,\n        this.coordinates.length,\n        2,\n        transform,\n        this.pixelCoordinates_\n      );\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    let i = 0; // instruction index\n    const ii = instructions.length; // end of instructions\n    let d = 0; // data index\n    let dd; // end of per-instruction data\n    let anchorX,\n      anchorY,\n      prevX,\n      prevY,\n      roundX,\n      roundY,\n      image,\n      text,\n      textKey,\n      strokeKey,\n      fillKey;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n    const viewRotationFromTransform =\n      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n\n    const state = /** @type {import(\"../../render.js\").State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation,\n    });\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    const batchSize =\n      this.instructions != instructions || this.overlaps ? 0 : 200;\n    let /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n    let x, y, currentGeometry;\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type = /** @type {import(\"./Instruction.js\").default} */ (\n        instruction[0]\n      );\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\n            instruction[1]\n          );\n          currentGeometry = instruction[3];\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (\n            hitExtent !== undefined &&\n            !intersects(hitExtent, currentGeometry.getExtent())\n          ) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          const geometry =\n            /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (\n              instruction[3]\n            );\n          const renderer = instruction[4];\n          const fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          const coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image =\n            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (\n              instruction[3]\n            );\n\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          let height = /** @type {number} */ (instruction[6]);\n          const opacity = /** @type {number} */ (instruction[7]);\n          const originX = /** @type {number} */ (instruction[8]);\n          const originY = /** @type {number} */ (instruction[9]);\n          const rotateWithView = /** @type {boolean} */ (instruction[10]);\n          let rotation = /** @type {number} */ (instruction[11]);\n          const scale = /** @type {import(\"../../size.js\").Size} */ (\n            instruction[12]\n          );\n          let width = /** @type {number} */ (instruction[13]);\n          const declutterMode =\n            /** @type {\"declutter\"|\"obstacle\"|\"none\"|undefined} */ (\n              instruction[14]\n            );\n          const declutterImageWithText =\n            /** @type {import(\"../canvas.js\").DeclutterImageWithText} */ (\n              instruction[15]\n            );\n\n          if (!image && instruction.length >= 20) {\n            // create label images\n            text = /** @type {string} */ (instruction[19]);\n            textKey = /** @type {string} */ (instruction[20]);\n            strokeKey = /** @type {string} */ (instruction[21]);\n            fillKey = /** @type {string} */ (instruction[22]);\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(\n              text,\n              textKey,\n              strokeKey,\n              fillKey\n            );\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            const textOffsetX = /** @type {number} */ (instruction[23]);\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            const textOffsetY = /** @type {number} */ (instruction[24]);\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          let geometryWidths;\n          if (instruction.length > 25) {\n            geometryWidths = /** @type {number} */ (instruction[25]);\n          }\n\n          let padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 17) {\n            padding = /** @type {Array<number>} */ (instruction[16]);\n            backgroundFill = /** @type {boolean} */ (instruction[17]);\n            backgroundStroke = /** @type {boolean} */ (instruction[18]);\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          let widthIndex = 0;\n          for (; d < dd; d += 2) {\n            if (\n              geometryWidths &&\n              geometryWidths[widthIndex++] < width / this.pixelRatio\n            ) {\n              continue;\n            }\n            const dimensions = this.calculateImageOrLabelDimensions_(\n              image.width,\n              image.height,\n              pixelCoordinates[d],\n              pixelCoordinates[d + 1],\n              width,\n              height,\n              anchorX,\n              anchorY,\n              originX,\n              originY,\n              rotation,\n              scale,\n              snapToPixel,\n              padding,\n              backgroundFill || backgroundStroke,\n              feature\n            );\n            /** @type {ReplayImageOrLabelArgs} */\n            const args = [\n              context,\n              contextScale,\n              image,\n              dimensions,\n              opacity,\n              backgroundFill\n                ? /** @type {Array<*>} */ (lastFillInstruction)\n                : null,\n              backgroundStroke\n                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                : null,\n            ];\n            if (declutterTree) {\n              if (declutterMode === 'none') {\n                // not rendered in declutter group\n                continue;\n              } else if (declutterMode === 'obstacle') {\n                // will always be drawn, thus no collision detection, but insert as obstacle\n                declutterTree.insert(dimensions.declutterBox);\n                continue;\n              } else {\n                let imageArgs;\n                let imageDeclutterBox;\n                if (declutterImageWithText) {\n                  const index = dd - d;\n                  if (!declutterImageWithText[index]) {\n                    // We now have the image for an image+text combination.\n                    declutterImageWithText[index] = args;\n                    // Don't render anything for now, wait for the text.\n                    continue;\n                  }\n                  imageArgs = declutterImageWithText[index];\n                  delete declutterImageWithText[index];\n                  imageDeclutterBox = getDeclutterBox(imageArgs);\n                  if (declutterTree.collides(imageDeclutterBox)) {\n                    continue;\n                  }\n                }\n                if (declutterTree.collides(dimensions.declutterBox)) {\n                  continue;\n                }\n                if (imageArgs) {\n                  // We now have image and text for an image+text combination.\n                  declutterTree.insert(imageDeclutterBox);\n                  // Render the image before we render the text.\n                  this.replayImageOrLabel_.apply(this, imageArgs);\n                }\n                declutterTree.insert(dimensions.declutterBox);\n              }\n            }\n            this.replayImageOrLabel_.apply(this, args);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          const begin = /** @type {number} */ (instruction[1]);\n          const end = /** @type {number} */ (instruction[2]);\n          const baseline = /** @type {number} */ (instruction[3]);\n          const overflow = /** @type {number} */ (instruction[4]);\n          fillKey = /** @type {string} */ (instruction[5]);\n          const maxAngle = /** @type {number} */ (instruction[6]);\n          const measurePixelRatio = /** @type {number} */ (instruction[7]);\n          const offsetY = /** @type {number} */ (instruction[8]);\n          strokeKey = /** @type {string} */ (instruction[9]);\n          const strokeWidth = /** @type {number} */ (instruction[10]);\n          text = /** @type {string} */ (instruction[11]);\n          textKey = /** @type {string} */ (instruction[12]);\n          const pixelRatioScale = [\n            /** @type {number} */ (instruction[13]),\n            /** @type {number} */ (instruction[13]),\n          ];\n\n          const textState = this.textStates[textKey];\n          const font = textState.font;\n          const textScale = [\n            textState.scale[0] * measurePixelRatio,\n            textState.scale[1] * measurePixelRatio,\n          ];\n\n          let cachedWidths;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength =\n            Math.abs(textScale[0]) *\n            measureAndCacheTextWidth(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            const textAlign = this.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            const parts = drawTextOnPath(\n              pixelCoordinates,\n              begin,\n              end,\n              2,\n              text,\n              startM,\n              maxAngle,\n              Math.abs(textScale[0]),\n              measureAndCacheTextWidth,\n              font,\n              cachedWidths,\n              viewRotationFromTransform ? 0 : this.viewRotation_\n            );\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              const replayImageOrLabelArgs = [];\n              let c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                    /** @type {number} */ (part[2]) +\n                    (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY =\n                    baseline * label.height +\n                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                      textScale[0] -\n                    offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(\n                    label.width,\n                    label.height,\n                    part[0],\n                    part[1],\n                    label.width,\n                    label.height,\n                    anchorX,\n                    anchorY,\n                    0,\n                    0,\n                    part[3],\n                    pixelRatioScale,\n                    false,\n                    defaultPadding,\n                    false,\n                    feature\n                  );\n                  if (\n                    declutterTree &&\n                    declutterTree.collides(dimensions.declutterBox)\n                  ) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([\n                    context,\n                    contextScale,\n                    label,\n                    dimensions,\n                    1,\n                    null,\n                    null,\n                  ]);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(\n                    label.width,\n                    label.height,\n                    part[0],\n                    part[1],\n                    label.width,\n                    label.height,\n                    anchorX,\n                    anchorY,\n                    0,\n                    0,\n                    part[3],\n                    pixelRatioScale,\n                    false,\n                    defaultPadding,\n                    false,\n                    feature\n                  );\n                  if (\n                    declutterTree &&\n                    declutterTree.collides(dimensions.declutterBox)\n                  ) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([\n                    context,\n                    contextScale,\n                    label,\n                    dimensions,\n                    1,\n                    null,\n                    null,\n                  ]);\n                }\n              }\n              if (declutterTree) {\n                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);\n              }\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\n              instruction[1]\n            );\n            const result = featureCallback(feature, currentGeometry);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n            /** @type {import(\"../../colorlike.js\").ColorLike} */ (\n              instruction[1]\n            );\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default: // consume the instruction anyway, to avoid an infinite loop\n          ++i;\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  execute(\n    context,\n    contextScale,\n    transform,\n    viewRotation,\n    snapToPixel,\n    declutterTree\n  ) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(\n      context,\n      contextScale,\n      transform,\n      this.instructions,\n      snapToPixel,\n      undefined,\n      undefined,\n      declutterTree\n    );\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  executeHitDetection(\n    context,\n    transform,\n    viewRotation,\n    featureCallback,\n    hitExtent\n  ) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(\n      context,\n      1,\n      transform,\n      this.hitDetectionInstructions,\n      true,\n      featureCallback,\n      hitExtent\n    );\n  }\n}\n\nexport default Executor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}