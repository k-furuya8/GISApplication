{"ast":null,"code":"/**\n * @module resample\n */\nfunction copyNewSize(array, width, height) {\n  let samplesPerPixel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[cy * inWidth + cx];\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n} // simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\n\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\n\n\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n        const ll = array[yl * inWidth + xl];\n        const hl = array[yl * inWidth + xh];\n        const lh = array[yh * inWidth + xl];\n        const hh = array[yh * inWidth + xh];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth + x] = value;\n      }\n    }\n\n    return newArray;\n  });\n}\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\n\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  let method = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'nearest';\n\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[cy * inWidth * samples + cx * samples + i];\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\n\nexport function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[yl * inWidth * samples + xl * samples + i];\n        const hl = valueArray[yl * inWidth * samples + xh * samples + i];\n        const lh = valueArray[yh * inWidth * samples + xl * samples + i];\n        const hh = valueArray[yh * inWidth * samples + xh * samples + i];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n\n  return newArray;\n}\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\n\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  let method = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'nearest';\n\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}","map":{"version":3,"names":["copyNewSize","array","width","height","samplesPerPixel","Object","getPrototypeOf","constructor","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","y","cy","Math","min","round","x","cx","value","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","Error","resampleNearestInterleaved","valueArray","samples","i","resampleBilinearInterleaved","resampleInterleaved"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/geotiff/dist-module/resample.js"],"sourcesContent":["/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAASA,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmCC,MAAnC,EAAgE;EAAA,IAArBC,eAAqB,uEAAH,CAAG;EAC9D,OAAO,KAAKC,MAAM,CAACC,cAAP,CAAsBL,KAAtB,EAA6BM,WAAlC,EAA+CL,KAAK,GAAGC,MAAR,GAAiBC,eAAhE,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASI,eAAT,CAAyBC,WAAzB,EAAsCC,OAAtC,EAA+CC,QAA/C,EAAyDC,QAAzD,EAAmEC,SAAnE,EAA8E;EACnF,MAAMC,IAAI,GAAGJ,OAAO,GAAGE,QAAvB;EACA,MAAMG,IAAI,GAAGJ,QAAQ,GAAGE,SAAxB;EACA,OAAOJ,WAAW,CAACO,GAAZ,CAAiBf,KAAD,IAAW;IAChC,MAAMgB,QAAQ,GAAGjB,WAAW,CAACC,KAAD,EAAQW,QAAR,EAAkBC,SAAlB,CAA5B;;IACA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+B,EAAEK,CAAjC,EAAoC;MAClC,MAAMC,EAAE,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWP,IAAI,GAAGG,CAAlB,CAAT,EAA+BP,QAAQ,GAAG,CAA1C,CAAX;;MACA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAApB,EAA8B,EAAEW,CAAhC,EAAmC;QACjC,MAAMC,EAAE,GAAGJ,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWR,IAAI,GAAGS,CAAlB,CAAT,EAA+Bb,OAAO,GAAG,CAAzC,CAAX;QACA,MAAMe,KAAK,GAAGxB,KAAK,CAAEkB,EAAE,GAAGT,OAAN,GAAiBc,EAAlB,CAAnB;QACAP,QAAQ,CAAEC,CAAC,GAAGN,QAAL,GAAiBW,CAAlB,CAAR,GAA+BE,KAA/B;MACD;IACF;;IACD,OAAOR,QAAP;EACD,CAXM,CAAP;AAYD,C,CAED;AACA;;AACA,SAASS,IAAT,CAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,CAAtB,EAAyB;EACvB,OAAQ,CAAC,IAAIA,CAAL,IAAUF,EAAX,GAAkBE,CAAC,GAAGD,EAA7B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASE,gBAAT,CAA0BrB,WAA1B,EAAuCC,OAAvC,EAAgDC,QAAhD,EAA0DC,QAA1D,EAAoEC,SAApE,EAA+E;EACpF,MAAMC,IAAI,GAAGJ,OAAO,GAAGE,QAAvB;EACA,MAAMG,IAAI,GAAGJ,QAAQ,GAAGE,SAAxB;EAEA,OAAOJ,WAAW,CAACO,GAAZ,CAAiBf,KAAD,IAAW;IAChC,MAAMgB,QAAQ,GAAGjB,WAAW,CAACC,KAAD,EAAQW,QAAR,EAAkBC,SAAlB,CAA5B;;IACA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+B,EAAEK,CAAjC,EAAoC;MAClC,MAAMa,IAAI,GAAGhB,IAAI,GAAGG,CAApB;MAEA,MAAMc,EAAE,GAAGZ,IAAI,CAACa,KAAL,CAAWF,IAAX,CAAX;MACA,MAAMG,EAAE,GAAGd,IAAI,CAACC,GAAL,CAASD,IAAI,CAACe,IAAL,CAAUJ,IAAV,CAAT,EAA2BpB,QAAQ,GAAG,CAAtC,CAAX;;MAEA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAApB,EAA8B,EAAEW,CAAhC,EAAmC;QACjC,MAAMa,IAAI,GAAGtB,IAAI,GAAGS,CAApB;QACA,MAAMc,EAAE,GAAGD,IAAI,GAAG,CAAlB;QAEA,MAAME,EAAE,GAAGlB,IAAI,CAACa,KAAL,CAAWG,IAAX,CAAX;QACA,MAAMG,EAAE,GAAGnB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACe,IAAL,CAAUC,IAAV,CAAT,EAA2B1B,OAAO,GAAG,CAArC,CAAX;QAEA,MAAM8B,EAAE,GAAGvC,KAAK,CAAE+B,EAAE,GAAGtB,OAAN,GAAiB4B,EAAlB,CAAhB;QACA,MAAMG,EAAE,GAAGxC,KAAK,CAAE+B,EAAE,GAAGtB,OAAN,GAAiB6B,EAAlB,CAAhB;QACA,MAAMG,EAAE,GAAGzC,KAAK,CAAEiC,EAAE,GAAGxB,OAAN,GAAiB4B,EAAlB,CAAhB;QACA,MAAMK,EAAE,GAAG1C,KAAK,CAAEiC,EAAE,GAAGxB,OAAN,GAAiB6B,EAAlB,CAAhB;QAEA,MAAMd,KAAK,GAAGC,IAAI,CAChBA,IAAI,CAACc,EAAD,EAAKC,EAAL,EAASJ,EAAT,CADY,EAEhBX,IAAI,CAACgB,EAAD,EAAKC,EAAL,EAASN,EAAT,CAFY,EAGhBN,IAAI,GAAG,CAHS,CAAlB;QAKAd,QAAQ,CAAEC,CAAC,GAAGN,QAAL,GAAiBW,CAAlB,CAAR,GAA+BE,KAA/B;MACD;IACF;;IACD,OAAOR,QAAP;EACD,CA7BM,CAAP;AA8BD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS2B,QAAT,CAAkBnC,WAAlB,EAA+BC,OAA/B,EAAwCC,QAAxC,EAAkDC,QAAlD,EAA4DC,SAA5D,EAA2F;EAAA,IAApBgC,MAAoB,uEAAX,SAAW;;EAChG,QAAQA,MAAM,CAACC,WAAP,EAAR;IACE,KAAK,SAAL;MACE,OAAOtC,eAAe,CAACC,WAAD,EAAcC,OAAd,EAAuBC,QAAvB,EAAiCC,QAAjC,EAA2CC,SAA3C,CAAtB;;IACF,KAAK,UAAL;IACA,KAAK,QAAL;MACE,OAAOiB,gBAAgB,CAACrB,WAAD,EAAcC,OAAd,EAAuBC,QAAvB,EAAiCC,QAAjC,EAA2CC,SAA3C,CAAvB;;IACF;MACE,MAAM,IAAIkC,KAAJ,CAAW,mCAAkCF,MAAO,GAApD,CAAN;EAPJ;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,0BAAT,CACLC,UADK,EACOvC,OADP,EACgBC,QADhB,EAC0BC,QAD1B,EACoCC,SADpC,EAC+CqC,OAD/C,EACwD;EAC7D,MAAMpC,IAAI,GAAGJ,OAAO,GAAGE,QAAvB;EACA,MAAMG,IAAI,GAAGJ,QAAQ,GAAGE,SAAxB;EAEA,MAAMI,QAAQ,GAAGjB,WAAW,CAACiD,UAAD,EAAarC,QAAb,EAAuBC,SAAvB,EAAkCqC,OAAlC,CAA5B;;EACA,KAAK,IAAIhC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+B,EAAEK,CAAjC,EAAoC;IAClC,MAAMC,EAAE,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWP,IAAI,GAAGG,CAAlB,CAAT,EAA+BP,QAAQ,GAAG,CAA1C,CAAX;;IACA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAApB,EAA8B,EAAEW,CAAhC,EAAmC;MACjC,MAAMC,EAAE,GAAGJ,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWR,IAAI,GAAGS,CAAlB,CAAT,EAA+Bb,OAAO,GAAG,CAAzC,CAAX;;MACA,KAAK,IAAIyC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAApB,EAA6B,EAAEC,CAA/B,EAAkC;QAChC,MAAM1B,KAAK,GAAGwB,UAAU,CAAE9B,EAAE,GAAGT,OAAL,GAAewC,OAAhB,GAA4B1B,EAAE,GAAG0B,OAAjC,GAA4CC,CAA7C,CAAxB;QACAlC,QAAQ,CAAEC,CAAC,GAAGN,QAAJ,GAAesC,OAAhB,GAA4B3B,CAAC,GAAG2B,OAAhC,GAA2CC,CAA5C,CAAR,GAAyD1B,KAAzD;MACD;IACF;EACF;;EACD,OAAOR,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASmC,2BAAT,CACLH,UADK,EACOvC,OADP,EACgBC,QADhB,EAC0BC,QAD1B,EACoCC,SADpC,EAC+CqC,OAD/C,EACwD;EAC7D,MAAMpC,IAAI,GAAGJ,OAAO,GAAGE,QAAvB;EACA,MAAMG,IAAI,GAAGJ,QAAQ,GAAGE,SAAxB;EACA,MAAMI,QAAQ,GAAGjB,WAAW,CAACiD,UAAD,EAAarC,QAAb,EAAuBC,SAAvB,EAAkCqC,OAAlC,CAA5B;;EACA,KAAK,IAAIhC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+B,EAAEK,CAAjC,EAAoC;IAClC,MAAMa,IAAI,GAAGhB,IAAI,GAAGG,CAApB;IAEA,MAAMc,EAAE,GAAGZ,IAAI,CAACa,KAAL,CAAWF,IAAX,CAAX;IACA,MAAMG,EAAE,GAAGd,IAAI,CAACC,GAAL,CAASD,IAAI,CAACe,IAAL,CAAUJ,IAAV,CAAT,EAA2BpB,QAAQ,GAAG,CAAtC,CAAX;;IAEA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAApB,EAA8B,EAAEW,CAAhC,EAAmC;MACjC,MAAMa,IAAI,GAAGtB,IAAI,GAAGS,CAApB;MACA,MAAMc,EAAE,GAAGD,IAAI,GAAG,CAAlB;MAEA,MAAME,EAAE,GAAGlB,IAAI,CAACa,KAAL,CAAWG,IAAX,CAAX;MACA,MAAMG,EAAE,GAAGnB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACe,IAAL,CAAUC,IAAV,CAAT,EAA2B1B,OAAO,GAAG,CAArC,CAAX;;MAEA,KAAK,IAAIyC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAApB,EAA6B,EAAEC,CAA/B,EAAkC;QAChC,MAAMX,EAAE,GAAGS,UAAU,CAAEjB,EAAE,GAAGtB,OAAL,GAAewC,OAAhB,GAA4BZ,EAAE,GAAGY,OAAjC,GAA4CC,CAA7C,CAArB;QACA,MAAMV,EAAE,GAAGQ,UAAU,CAAEjB,EAAE,GAAGtB,OAAL,GAAewC,OAAhB,GAA4BX,EAAE,GAAGW,OAAjC,GAA4CC,CAA7C,CAArB;QACA,MAAMT,EAAE,GAAGO,UAAU,CAAEf,EAAE,GAAGxB,OAAL,GAAewC,OAAhB,GAA4BZ,EAAE,GAAGY,OAAjC,GAA4CC,CAA7C,CAArB;QACA,MAAMR,EAAE,GAAGM,UAAU,CAAEf,EAAE,GAAGxB,OAAL,GAAewC,OAAhB,GAA4BX,EAAE,GAAGW,OAAjC,GAA4CC,CAA7C,CAArB;QAEA,MAAM1B,KAAK,GAAGC,IAAI,CAChBA,IAAI,CAACc,EAAD,EAAKC,EAAL,EAASJ,EAAT,CADY,EAEhBX,IAAI,CAACgB,EAAD,EAAKC,EAAL,EAASN,EAAT,CAFY,EAGhBN,IAAI,GAAG,CAHS,CAAlB;QAKAd,QAAQ,CAAEC,CAAC,GAAGN,QAAJ,GAAesC,OAAhB,GAA4B3B,CAAC,GAAG2B,OAAhC,GAA2CC,CAA5C,CAAR,GAAyD1B,KAAzD;MACD;IACF;EACF;;EACD,OAAOR,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASoC,mBAAT,CAA6BJ,UAA7B,EAAyCvC,OAAzC,EAAkDC,QAAlD,EAA4DC,QAA5D,EAAsEC,SAAtE,EAAiFqC,OAAjF,EAA8G;EAAA,IAApBL,MAAoB,uEAAX,SAAW;;EACnH,QAAQA,MAAM,CAACC,WAAP,EAAR;IACE,KAAK,SAAL;MACE,OAAOE,0BAA0B,CAC/BC,UAD+B,EACnBvC,OADmB,EACVC,QADU,EACAC,QADA,EACUC,SADV,EACqBqC,OADrB,CAAjC;;IAGF,KAAK,UAAL;IACA,KAAK,QAAL;MACE,OAAOE,2BAA2B,CAChCH,UADgC,EACpBvC,OADoB,EACXC,QADW,EACDC,QADC,EACSC,SADT,EACoBqC,OADpB,CAAlC;;IAGF;MACE,MAAM,IAAIH,KAAJ,CAAW,mCAAkCF,MAAO,GAApD,CAAN;EAXJ;AAaD"},"metadata":{},"sourceType":"module"}