{"ast":null,"code":"/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { containsCoordinate, containsExtent, getHeight, getIntersection, getWidth, intersects as intersectsExtent, isEmpty } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\n\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n\n    this.image_ = null;\n  }\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n\n\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n    const imageSource = this.getLayer().getSource();\n    const hints = frameState.viewHints;\n    let renderedExtent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));\n    }\n\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n\n\n  getData(pixel) {\n    const frameState = this.frameState;\n\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));\n\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));\n\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation; // desired dimensions of the canvas in pixels\n\n    const width = Math.round(getWidth(extent) / resolution * pixelRatio);\n    const height = Math.round(getHeight(extent) / resolution * pixelRatio); // set forward and inverse pixel transforms\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    } // clipped rendering if layer extent is set\n\n\n    let clipped = false;\n    let render = true;\n\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(layerState.extent, viewState.projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n    const transform = composeTransform(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n}\n\nexport default CanvasImageLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ImageState","ViewHint","apply","applyTransform","compose","composeTransform","makeInverse","toString","toTransformString","containsCoordinate","containsExtent","getHeight","getIntersection","getWidth","intersects","intersectsExtent","isEmpty","fromUserExtent","CanvasImageLayerRenderer","constructor","imageLayer","image_","getImage","prepareFrame","frameState","layerState","layerStatesArray","layerIndex","pixelRatio","viewState","viewResolution","resolution","imageSource","getLayer","getSource","hints","viewHints","renderedExtent","extent","undefined","projection","ANIMATING","INTERACTING","image","loadImage","getState","EMPTY","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","imageExtent","img","imageMapWidth","col","Math","floor","width","imageMapHeight","row","height","getImageData","renderFrame","target","imageResolution","getResolution","imagePixelRatio","getPixelRatio","viewCenter","center","scale","rotation","round","pixelTransform","size","inversePixelTransform","canvasTransform","useContainer","getBackground","context","canvas","containerReused","clearRect","clipped","render","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","previousAlpha","globalAlpha","drawImage","postRender","restore","style","container"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/renderer/canvas/ImageLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,mBAAP,MAAgC,YAAhC;AACA,OAAOC,UAAP,MAAuB,qBAAvB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,SACEC,KAAK,IAAIC,cADX,EAEEC,OAAO,IAAIC,gBAFb,EAGEC,WAHF,EAIEC,QAAQ,IAAIC,iBAJd,QAKO,oBALP;AAMA,SACEC,kBADF,EAEEC,cAFF,EAGEC,SAHF,EAIEC,eAJF,EAKEC,QALF,EAMEC,UAAU,IAAIC,gBANhB,EAOEC,OAPF,QAQO,iBARP;AASA,SAAQC,cAAR,QAA6B,eAA7B;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,wBAAN,SAAuCnB,mBAAvC,CAA2D;EACzD;AACF;AACA;EACEoB,WAAW,CAACC,UAAD,EAAa;IACtB,MAAMA,UAAN;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,MAAL,GAAc,IAAd;EACD;EAED;AACF;AACA;;;EACEC,QAAQ,GAAG;IACT,OAAO,CAAC,KAAKD,MAAN,GAAe,IAAf,GAAsB,KAAKA,MAAL,CAAYC,QAAZ,EAA7B;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEC,YAAY,CAACC,UAAD,EAAa;IACvB,MAAMC,UAAU,GAAGD,UAAU,CAACE,gBAAX,CAA4BF,UAAU,CAACG,UAAvC,CAAnB;IACA,MAAMC,UAAU,GAAGJ,UAAU,CAACI,UAA9B;IACA,MAAMC,SAAS,GAAGL,UAAU,CAACK,SAA7B;IACA,MAAMC,cAAc,GAAGD,SAAS,CAACE,UAAjC;IAEA,MAAMC,WAAW,GAAG,KAAKC,QAAL,GAAgBC,SAAhB,EAApB;IAEA,MAAMC,KAAK,GAAGX,UAAU,CAACY,SAAzB;IAEA,IAAIC,cAAc,GAAGb,UAAU,CAACc,MAAhC;;IACA,IAAIb,UAAU,CAACa,MAAX,KAAsBC,SAA1B,EAAqC;MACnCF,cAAc,GAAGzB,eAAe,CAC9ByB,cAD8B,EAE9BpB,cAAc,CAACQ,UAAU,CAACa,MAAZ,EAAoBT,SAAS,CAACW,UAA9B,CAFgB,CAAhC;IAID;;IAED,IACE,CAACL,KAAK,CAAClC,QAAQ,CAACwC,SAAV,CAAN,IACA,CAACN,KAAK,CAAClC,QAAQ,CAACyC,WAAV,CADN,IAEA,CAAC1B,OAAO,CAACqB,cAAD,CAHV,EAIE;MACA,IAAIL,WAAJ,EAAiB;QACf,MAAMQ,UAAU,GAAGX,SAAS,CAACW,UAA7B;QACA,MAAMG,KAAK,GAAGX,WAAW,CAACV,QAAZ,CACZe,cADY,EAEZP,cAFY,EAGZF,UAHY,EAIZY,UAJY,CAAd;;QAMA,IAAIG,KAAJ,EAAW;UACT,IAAI,KAAKC,SAAL,CAAeD,KAAf,CAAJ,EAA2B;YACzB,KAAKtB,MAAL,GAAcsB,KAAd;UACD,CAFD,MAEO,IAAIA,KAAK,CAACE,QAAN,OAAqB7C,UAAU,CAAC8C,KAApC,EAA2C;YAChD,KAAKzB,MAAL,GAAc,IAAd;UACD;QACF;MACF,CAfD,MAeO;QACL,KAAKA,MAAL,GAAc,IAAd;MACD;IACF;;IAED,OAAO,CAAC,CAAC,KAAKA,MAAd;EACD;EAED;AACF;AACA;AACA;;;EACE0B,OAAO,CAACC,KAAD,EAAQ;IACb,MAAMxB,UAAU,GAAG,KAAKA,UAAxB;;IACA,IAAI,CAACA,UAAL,EAAiB;MACf,OAAO,IAAP;IACD;;IAED,MAAMyB,KAAK,GAAG,KAAKhB,QAAL,EAAd;IACA,MAAMiB,UAAU,GAAG/C,cAAc,CAC/BqB,UAAU,CAAC2B,0BADoB,EAE/BH,KAAK,CAACI,KAAN,EAF+B,CAAjC;IAKA,MAAMC,WAAW,GAAGJ,KAAK,CAACK,SAAN,EAApB;;IACA,IAAID,WAAJ,EAAiB;MACf,IAAI,CAAC5C,kBAAkB,CAAC4C,WAAD,EAAcH,UAAd,CAAvB,EAAkD;QAChD,OAAO,IAAP;MACD;IACF;;IAED,MAAMK,WAAW,GAAG,KAAKlC,MAAL,CAAYiC,SAAZ,EAApB;IACA,MAAME,GAAG,GAAG,KAAKnC,MAAL,CAAYC,QAAZ,EAAZ;IAEA,MAAMmC,aAAa,GAAG5C,QAAQ,CAAC0C,WAAD,CAA9B;IACA,MAAMG,GAAG,GAAGC,IAAI,CAACC,KAAL,CACVJ,GAAG,CAACK,KAAJ,IAAa,CAACX,UAAU,CAAC,CAAD,CAAV,GAAgBK,WAAW,CAAC,CAAD,CAA5B,IAAmCE,aAAhD,CADU,CAAZ;;IAGA,IAAIC,GAAG,GAAG,CAAN,IAAWA,GAAG,IAAIF,GAAG,CAACK,KAA1B,EAAiC;MAC/B,OAAO,IAAP;IACD;;IAED,MAAMC,cAAc,GAAGnD,SAAS,CAAC4C,WAAD,CAAhC;IACA,MAAMQ,GAAG,GAAGJ,IAAI,CAACC,KAAL,CACVJ,GAAG,CAACQ,MAAJ,IAAc,CAACT,WAAW,CAAC,CAAD,CAAX,GAAiBL,UAAU,CAAC,CAAD,CAA5B,IAAmCY,cAAjD,CADU,CAAZ;;IAGA,IAAIC,GAAG,GAAG,CAAN,IAAWA,GAAG,IAAIP,GAAG,CAACQ,MAA1B,EAAkC;MAChC,OAAO,IAAP;IACD;;IAED,OAAO,KAAKC,YAAL,CAAkBT,GAAlB,EAAuBE,GAAvB,EAA4BK,GAA5B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEG,WAAW,CAAC1C,UAAD,EAAa2C,MAAb,EAAqB;IAC9B,MAAMxB,KAAK,GAAG,KAAKtB,MAAnB;IACA,MAAMkC,WAAW,GAAGZ,KAAK,CAACW,SAAN,EAApB;IACA,MAAMc,eAAe,GAAGzB,KAAK,CAAC0B,aAAN,EAAxB;IACA,MAAMC,eAAe,GAAG3B,KAAK,CAAC4B,aAAN,EAAxB;IACA,MAAM9C,UAAU,GAAGD,UAAU,CAACE,gBAAX,CAA4BF,UAAU,CAACG,UAAvC,CAAnB;IACA,MAAMC,UAAU,GAAGJ,UAAU,CAACI,UAA9B;IACA,MAAMC,SAAS,GAAGL,UAAU,CAACK,SAA7B;IACA,MAAM2C,UAAU,GAAG3C,SAAS,CAAC4C,MAA7B;IACA,MAAM3C,cAAc,GAAGD,SAAS,CAACE,UAAjC;IACA,MAAM2C,KAAK,GACR9C,UAAU,GAAGwC,eAAd,IAAkCtC,cAAc,GAAGwC,eAAnD,CADF;IAGA,MAAMhC,MAAM,GAAGd,UAAU,CAACc,MAA1B;IACA,MAAMP,UAAU,GAAGF,SAAS,CAACE,UAA7B;IACA,MAAM4C,QAAQ,GAAG9C,SAAS,CAAC8C,QAA3B,CAf8B,CAgB9B;;IACA,MAAMd,KAAK,GAAGF,IAAI,CAACiB,KAAL,CAAY/D,QAAQ,CAACyB,MAAD,CAAR,GAAmBP,UAApB,GAAkCH,UAA7C,CAAd;IACA,MAAMoC,MAAM,GAAGL,IAAI,CAACiB,KAAL,CAAYjE,SAAS,CAAC2B,MAAD,CAAT,GAAoBP,UAArB,GAAmCH,UAA9C,CAAf,CAlB8B,CAoB9B;;IACAvB,gBAAgB,CACd,KAAKwE,cADS,EAEdrD,UAAU,CAACsD,IAAX,CAAgB,CAAhB,IAAqB,CAFP,EAGdtD,UAAU,CAACsD,IAAX,CAAgB,CAAhB,IAAqB,CAHP,EAId,IAAIlD,UAJU,EAKd,IAAIA,UALU,EAMd+C,QANc,EAOd,CAACd,KAAD,GAAS,CAPK,EAQd,CAACG,MAAD,GAAU,CARI,CAAhB;IAUA1D,WAAW,CAAC,KAAKyE,qBAAN,EAA6B,KAAKF,cAAlC,CAAX;IAEA,MAAMG,eAAe,GAAGxE,iBAAiB,CAAC,KAAKqE,cAAN,CAAzC;IAEA,KAAKI,YAAL,CAAkBd,MAAlB,EAA0Ba,eAA1B,EAA2C,KAAKE,aAAL,CAAmB1D,UAAnB,CAA3C;IAEA,MAAM2D,OAAO,GAAG,KAAKA,OAArB;IACA,MAAMC,MAAM,GAAGD,OAAO,CAACC,MAAvB;;IAEA,IAAIA,MAAM,CAACvB,KAAP,IAAgBA,KAAhB,IAAyBuB,MAAM,CAACpB,MAAP,IAAiBA,MAA9C,EAAsD;MACpDoB,MAAM,CAACvB,KAAP,GAAeA,KAAf;MACAuB,MAAM,CAACpB,MAAP,GAAgBA,MAAhB;IACD,CAHD,MAGO,IAAI,CAAC,KAAKqB,eAAV,EAA2B;MAChCF,OAAO,CAACG,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBzB,KAAxB,EAA+BG,MAA/B;IACD,CA7C6B,CA+C9B;;;IACA,IAAIuB,OAAO,GAAG,KAAd;IACA,IAAIC,MAAM,GAAG,IAAb;;IACA,IAAI/D,UAAU,CAACa,MAAf,EAAuB;MACrB,MAAMe,WAAW,GAAGpC,cAAc,CAChCQ,UAAU,CAACa,MADqB,EAEhCT,SAAS,CAACW,UAFsB,CAAlC;MAIAgD,MAAM,GAAGzE,gBAAgB,CAACsC,WAAD,EAAc7B,UAAU,CAACc,MAAzB,CAAzB;MACAiD,OAAO,GAAGC,MAAM,IAAI,CAAC9E,cAAc,CAAC2C,WAAD,EAAc7B,UAAU,CAACc,MAAzB,CAAnC;;MACA,IAAIiD,OAAJ,EAAa;QACX,KAAKE,aAAL,CAAmBN,OAAnB,EAA4B3D,UAA5B,EAAwC6B,WAAxC;MACD;IACF;;IAED,MAAMG,GAAG,GAAGb,KAAK,CAACrB,QAAN,EAAZ;IAEA,MAAMoE,SAAS,GAAGrF,gBAAgB,CAChC,KAAKsF,aAD2B,EAEhC9B,KAAK,GAAG,CAFwB,EAGhCG,MAAM,GAAG,CAHuB,EAIhCU,KAJgC,EAKhCA,KALgC,EAMhC,CANgC,EAO/BJ,eAAe,IAAIf,WAAW,CAAC,CAAD,CAAX,GAAiBiB,UAAU,CAAC,CAAD,CAA/B,CAAhB,GAAuDJ,eAPvB,EAQ/BE,eAAe,IAAIE,UAAU,CAAC,CAAD,CAAV,GAAgBjB,WAAW,CAAC,CAAD,CAA/B,CAAhB,GAAuDa,eARvB,CAAlC;IAWA,KAAKwB,kBAAL,GAA2BxB,eAAe,GAAGxC,UAAnB,GAAiC0C,eAA3D;IAEA,MAAMuB,EAAE,GAAGrC,GAAG,CAACK,KAAJ,GAAY6B,SAAS,CAAC,CAAD,CAAhC;IACA,MAAMI,EAAE,GAAGtC,GAAG,CAACQ,MAAJ,GAAa0B,SAAS,CAAC,CAAD,CAAjC;;IAEA,IAAI,CAAC,KAAKzD,QAAL,GAAgBC,SAAhB,GAA4B6D,cAA5B,EAAL,EAAmD;MACjDZ,OAAO,CAACa,qBAAR,GAAgC,KAAhC;IACD;;IAED,KAAKC,SAAL,CAAed,OAAf,EAAwB3D,UAAxB;;IACA,IAAIgE,MAAM,IAAIK,EAAE,IAAI,GAAhB,IAAuBC,EAAE,IAAI,GAAjC,EAAsC;MACpC,MAAMI,EAAE,GAAGR,SAAS,CAAC,CAAD,CAApB;MACA,MAAMS,EAAE,GAAGT,SAAS,CAAC,CAAD,CAApB;MACA,MAAMU,OAAO,GAAG3E,UAAU,CAAC2E,OAA3B;MACA,IAAIC,aAAJ;;MACA,IAAID,OAAO,KAAK,CAAhB,EAAmB;QACjBC,aAAa,GAAGlB,OAAO,CAACmB,WAAxB;QACAnB,OAAO,CAACmB,WAAR,GAAsBF,OAAtB;MACD;;MACDjB,OAAO,CAACoB,SAAR,CAAkB/C,GAAlB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAACA,GAAG,CAACK,KAAlC,EAAyC,CAACL,GAAG,CAACQ,MAA9C,EAAsDkC,EAAtD,EAA0DC,EAA1D,EAA8DN,EAA9D,EAAkEC,EAAlE;;MACA,IAAIM,OAAO,KAAK,CAAhB,EAAmB;QACjBjB,OAAO,CAACmB,WAAR,GAAsBD,aAAtB;MACD;IACF;;IACD,KAAKG,UAAL,CAAgBrB,OAAhB,EAAyB3D,UAAzB;;IAEA,IAAI+D,OAAJ,EAAa;MACXJ,OAAO,CAACsB,OAAR;IACD;;IACDtB,OAAO,CAACa,qBAAR,GAAgC,IAAhC;;IAEA,IAAIhB,eAAe,KAAKI,MAAM,CAACsB,KAAP,CAAahB,SAArC,EAAgD;MAC9CN,MAAM,CAACsB,KAAP,CAAahB,SAAb,GAAyBV,eAAzB;IACD;;IAED,OAAO,KAAK2B,SAAZ;EACD;;AA1OwD;;AA6O3D,eAAezF,wBAAf"},"metadata":{},"sourceType":"module"}