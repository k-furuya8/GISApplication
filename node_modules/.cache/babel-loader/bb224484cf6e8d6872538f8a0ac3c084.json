{"ast":null,"code":"/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { apply as applyTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, containsCoordinate, getIntersection, isEmpty } from '../../extent.js';\nimport { create as createMat4, fromTransform as mat4FromTransform } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\nexport const Uniforms = {\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution',\n  // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX',\n  // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY',\n  // map y coordinate of top edge of texture\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom'\n};\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord'\n};\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\n\nconst attributeDescriptions = [{\n  name: Attributes.TEXTURE_COORD,\n  size: 2,\n  type: AttributeType.FLOAT\n}];\n/**\n * @type {Object<string, boolean>}\n */\n\nconst empty = {};\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\n\nfunction depthForZ(z) {\n  return 2 * (1 - 1 / (z + 1)) - 1;\n}\n/**\n * Add a tile texture to the lookup.\n * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\n\n\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n  if (!(z in tileTexturesByZ)) {\n    tileTexturesByZ[z] = [];\n  }\n\n  tileTexturesByZ[z].push(tileTexture);\n}\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\n\n\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n\n  const source =\n  /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n\n  return extent;\n}\n\nfunction getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLLayerRenderer<LayerType>}\n * @api\n */\n\n\nclass WebGLTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms\n    });\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n\n    this.renderComplete = false;\n    /**\n     * This transform converts texture coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    this.tileTransform_ = createTransform();\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.tempMat4_ = createMat4();\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n\n    this.tempSize_ = [0, 0];\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n\n    this.program_;\n    /**\n     * @private\n     */\n\n    this.vertexShader_ = options.vertexShader;\n    /**\n     * @private\n     */\n\n    this.fragmentShader_ = options.fragmentShader;\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n     * @private\n     */\n\n    this.tileTextureCache_ = new LRUCache(cacheSize);\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n\n    this.paletteTextures_ = options.paletteTextures || [];\n    /**\n     * @private\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n\n    this.frameState_ = null;\n  }\n  /**\n   * @param {Options} options Options.\n   */\n\n\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms\n    });\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    this.helper.flushBufferData(this.indices_);\n  }\n  /**\n   * @param {import(\"../../webgl/TileTexture\").TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n\n\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n\n    return source.getState() === 'ready';\n  }\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.\n   */\n\n\n  enqueueTiles(frameState, extent, initialZ, tileTexturesByZ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileTextureCache = this.tileTextureCache_;\n    const minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());\n\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n          /** @type {TileTexture} */\n\n          let tileTexture;\n          /** @type {import(\"../../webgl/TileTexture\").TileType} */\n\n          let tile;\n\n          if (tileTextureCache.containsKey(cacheKey)) {\n            tileTexture = tileTextureCache.get(cacheKey);\n            tile = tileTexture.tile;\n          }\n\n          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n\n            if (!tileTexture) {\n              tileTexture = new TileTexture({\n                tile: tile,\n                grid: tileGrid,\n                helper: this.helper,\n                gutter: gutter\n              });\n              tileTextureCache.set(cacheKey, tileTexture);\n            } else {\n              if (this.isDrawableTile_(tile)) {\n                tileTexture.setTile(tile);\n              } else {\n                const interimTile =\n                /** @type {import(\"../../webgl/TileTexture\").TileType} */\n                tile.getInterimTile();\n                tileTexture.setTile(interimTile);\n              }\n            }\n          }\n\n          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  renderFrame(frameState) {\n    this.frameState_ = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    /**\n     * @type {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>}\n     */\n\n    const tileTexturesByZ = {};\n\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n\n    const alphaLookup = {};\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false; // look for cached tiles to use if a target tile is not ready\n\n    const tileTextures = tileTexturesByZ[z];\n\n    for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n      const tileTexture = tileTextures[i];\n      const tile = tileTexture.tile;\n      const tileCoord = tile.tileCoord;\n\n      if (tileTexture.loaded) {\n        const alpha = tile.getAlpha(uid, time);\n\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n\n      this.renderComplete = false; // first look for child tiles (at z + 1)\n\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);\n\n      if (coveredByChildren) {\n        continue;\n      } // next look for parent tiles\n\n\n      const minZoom = tileGrid.getMinZoom();\n\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState, !blend);\n    const zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      const tileResolution = tileGrid.getResolution(tileZ);\n      const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      const tileOrigin = tileGrid.getOrigin(tileZ);\n      const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n      const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n      const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n      const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n      const tileScale = viewState.resolution / tileResolution;\n      const depth = depthForZ(tileZ);\n      const tileTextures = tileTexturesByZ[tileZ];\n\n      for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n        const tileTexture = tileTextures[i];\n\n        if (!tileTexture.loaded) {\n          continue;\n        }\n\n        const tile = tileTexture.tile;\n        const tileCoord = tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        const tileCenterI = tileCoord[1];\n        const tileCenterJ = tileCoord[2];\n        resetTransform(this.tileTransform_);\n        scaleTransform(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));\n        rotateTransform(this.tileTransform_, viewState.rotation);\n        scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n        translateTransform(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);\n        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4_, this.tileTransform_));\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n        let textureSlot = 0;\n\n        while (textureSlot < tileTexture.textures.length) {\n          const textureProperty = 'TEXTURE' + textureSlot;\n          const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);\n          ++textureSlot;\n        }\n\n        for (let paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {\n          const paletteTexture = this.paletteTextures_[paletteIndex];\n          gl.activeTexture(gl['TEXTURE' + textureSlot]);\n          const texture = paletteTexture.getTexture(gl);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);\n          ++textureSlot;\n        }\n\n        const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);\n        let gutterExtent = extent;\n\n        if (gutter > 0) {\n          gutterExtent = tileGrid.getTileCoordExtent(tileCoord);\n          getIntersection(gutterExtent, extent, gutterExtent);\n        }\n\n        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n    const tileTextureCache = this.tileTextureCache_;\n\n    while (tileTextureCache.canExpireCache()) {\n      const tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    } // TODO: let the renderers manage their own cache instead of managing the source cache\n\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n\n\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n\n\n  getData(pixel) {\n    const gl = this.helper.getGL();\n\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n\n    if (layerExtent) {\n      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {\n        return null;\n      }\n    } // determine last source suitable for rendering at coordinate\n\n\n    const sources = layer.getSources(boundingExtent([coordinate]), viewState.resolution);\n    let i, source, tileGrid;\n\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n\n        if (source.getWrapX()) {\n          break;\n        }\n\n        const gridExtent = tileGrid.getExtent();\n\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileTextureCache_;\n\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n\n      const tileTexture = tileTextureCache.get(cacheKey);\n\n      if (!tileTexture.loaded) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n      const col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];\n      const row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];\n      return tileTexture.getPixelData(col, row);\n    }\n\n    return null;\n  }\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n   * tile textures by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n\n\n  findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileTextureCache = this.tileTextureCache_;\n    const source = this.getLayer().getRenderSource();\n\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n\n        if (tileTextureCache.containsKey(cacheKey)) {\n          const tileTexture = tileTextureCache.get(cacheKey);\n\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n\n    return covered;\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      const tileTextureCache = this.tileTextureCache_;\n      tileTextureCache.forEach(tileTexture => tileTexture.dispose());\n      tileTextureCache.clear();\n    }\n\n    super.removeHelper();\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    const helper = this.helper;\n\n    if (helper) {\n      const gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n\n    super.disposeInternal();\n    delete this.indices_;\n    delete this.tileTextureCache_;\n    delete this.frameState_;\n  }\n\n}\n\nexport default WebGLTileLayerRenderer;","map":{"version":3,"names":["LRUCache","TileRange","TileState","TileTexture","WebGLArrayBuffer","WebGLLayerRenderer","AttributeType","ELEMENT_ARRAY_BUFFER","STATIC_DRAW","apply","applyTransform","create","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","translate","translateTransform","boundingExtent","containsCoordinate","getIntersection","isEmpty","createMat4","fromTransform","mat4FromTransform","createOrUpdate","createTileCoord","getKey","getTileCoordKey","fromUserExtent","getUid","numberSafeCompareFunction","toSize","Uniforms","TILE_TEXTURE_ARRAY","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","RENDER_EXTENT","RESOLUTION","ZOOM","Attributes","TEXTURE_COORD","attributeDescriptions","name","size","type","FLOAT","empty","depthForZ","z","addTileTextureToLookup","tileTexturesByZ","tileTexture","push","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","WebGLTileLayerRenderer","constructor","tileLayer","options","uniforms","renderComplete","tileTransform_","tempMat4_","tempTileRange_","tempTileCoord_","tempSize_","program_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","indices_","fromArray","cacheSize","undefined","tileTextureCache_","paletteTextures_","paletteTextures","frameState_","helper","getProgram","afterHelperCreated","flushBufferData","isDrawableTile_","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrameInternal","enqueueTiles","initialZ","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","tileTextureCache","minZ","Math","max","getPreload","getMinZoom","tileRange","getTileRangeForExtentAndZ","tileResolution","getResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","pixelRatio","grid","set","setTile","interimTile","getInterimTile","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","renderFrame","gl","getGL","preRender","getZForResolution","resolution","zDirection","nextExtent","targetZ","nextResolution","alphaLookup","uid","time","blend","tileTextures","i","ii","length","loaded","alpha","getAlpha","endTransition","tileCoordKey","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","useProgram","prepareDraw","zs","Object","keys","map","Number","sort","centerX","center","centerY","j","jj","tileZ","tileSize","getTileSize","tileOrigin","getOrigin","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","depth","tileCenterI","tileCenterJ","rotation","setUniformMatrixValue","bindBuffer","coords","enableAttributes","textureSlot","textures","textureProperty","uniformName","activeTexture","bindTexture","TEXTURE_2D","uniform1i","getUniformLocation","paletteIndex","paletteTexture","texture","getTexture","animate","setUniformFloatValue","gutterExtent","getTileCoordExtent","setUniformFloatVec4","zoom","drawElements","getSize","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","postRender","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","sources","getSources","getTileCoordForCoordAndZ","col","row","getPixelData","altZ","getTileRangeForTileCoordAndZ","covered","removeHelper","forEach","clear","disposeInternal","deleteProgram","deleteBuffer"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/renderer/webgl/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n  isEmpty,\n} from '../../extent.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 2 * (1 - 1 / (z + 1)) - 1;\n}\n\n/**\n * Add a tile texture to the lookup.\n * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n  if (!(z in tileTexturesByZ)) {\n    tileTexturesByZ[z] = [];\n  }\n  tileTexturesByZ[z].push(tileTexture);\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection)\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nfunction getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLLayerRenderer<LayerType>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts texture coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.tempMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n     * @private\n     */\n    this.tileTextureCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    /**\n     * @private\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState_ = null;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  /**\n   * @param {import(\"../../webgl/TileTexture\").TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.\n   */\n  enqueueTiles(frameState, extent, initialZ, tileTexturesByZ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const tileTextureCache = this.tileTextureCache_;\n    const minZ = Math.max(\n      initialZ - tileLayer.getPreload(),\n      tileGrid.getMinZoom(),\n      tileLayer.getMinZoom()\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileTexture} */\n          let tileTexture;\n\n          /** @type {import(\"../../webgl/TileTexture\").TileType} */\n          let tile;\n\n          if (tileTextureCache.containsKey(cacheKey)) {\n            tileTexture = tileTextureCache.get(cacheKey);\n            tile = tileTexture.tile;\n          }\n          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection\n            );\n            if (!tileTexture) {\n              tileTexture = new TileTexture({\n                tile: tile,\n                grid: tileGrid,\n                helper: this.helper,\n                gutter: gutter,\n              });\n              tileTextureCache.set(cacheKey, tileTexture);\n            } else {\n              if (this.isDrawableTile_(tile)) {\n                tileTexture.setTile(tile);\n              } else {\n                const interimTile =\n                  /** @type {import(\"../../webgl/TileTexture\").TileType} */ (\n                    tile.getInterimTile()\n                  );\n                tileTexture.setTile(interimTile);\n              }\n            }\n          }\n\n          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState_ = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    /**\n     * @type {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>}\n     */\n    const tileTexturesByZ = {};\n\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    const tileTextures = tileTexturesByZ[z];\n    for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n      const tileTexture = tileTextures[i];\n      const tile = tileTexture.tile;\n      const tileCoord = tile.tileCoord;\n\n      if (tileTexture.loaded) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileTexturesByZ\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileTexturesByZ\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState, !blend);\n\n    const zs = Object.keys(tileTexturesByZ)\n      .map(Number)\n      .sort(numberSafeCompareFunction);\n\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      const tileResolution = tileGrid.getResolution(tileZ);\n      const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      const tileOrigin = tileGrid.getOrigin(tileZ);\n\n      const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n      const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n      const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n      const centerI =\n        (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      const centerJ =\n        (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n      const tileScale = viewState.resolution / tileResolution;\n\n      const depth = depthForZ(tileZ);\n      const tileTextures = tileTexturesByZ[tileZ];\n      for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n        const tileTexture = tileTextures[i];\n        if (!tileTexture.loaded) {\n          continue;\n        }\n        const tile = tileTexture.tile;\n        const tileCoord = tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n\n        const tileCenterI = tileCoord[1];\n        const tileCenterJ = tileCoord[2];\n\n        resetTransform(this.tileTransform_);\n        scaleTransform(\n          this.tileTransform_,\n          2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n          -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter)\n        );\n        rotateTransform(this.tileTransform_, viewState.rotation);\n        scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n        translateTransform(\n          this.tileTransform_,\n          (tileSize[0] * (tileCenterI - centerI) - gutter) /\n            tileWidthWithGutter,\n          (tileSize[1] * (tileCenterJ - centerJ) - gutter) /\n            tileHeightWithGutter\n        );\n\n        this.helper.setUniformMatrixValue(\n          Uniforms.TILE_TRANSFORM,\n          mat4FromTransform(this.tempMat4_, this.tileTransform_)\n        );\n\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n\n        let textureSlot = 0;\n        while (textureSlot < tileTexture.textures.length) {\n          const textureProperty = 'TEXTURE' + textureSlot;\n          const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n          gl.uniform1i(\n            this.helper.getUniformLocation(uniformName),\n            textureSlot\n          );\n          ++textureSlot;\n        }\n\n        for (\n          let paletteIndex = 0;\n          paletteIndex < this.paletteTextures_.length;\n          ++paletteIndex\n        ) {\n          const paletteTexture = this.paletteTextures_[paletteIndex];\n          gl.activeTexture(gl['TEXTURE' + textureSlot]);\n          const texture = paletteTexture.getTexture(gl);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.uniform1i(\n            this.helper.getUniformLocation(paletteTexture.name),\n            textureSlot\n          );\n          ++textureSlot;\n        }\n\n        const alpha =\n          tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_PIXEL_WIDTH,\n          tileWidthWithGutter\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_PIXEL_HEIGHT,\n          tileHeightWithGutter\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_RESOLUTION,\n          tileResolution\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_ORIGIN_X,\n          tileOrigin[0] +\n            tileCenterI * tileSize[0] * tileResolution -\n            gutter * tileResolution\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_ORIGIN_Y,\n          tileOrigin[1] -\n            tileCenterJ * tileSize[1] * tileResolution +\n            gutter * tileResolution\n        );\n        let gutterExtent = extent;\n        if (gutter > 0) {\n          gutterExtent = tileGrid.getTileCoordExtent(tileCoord);\n          getIntersection(gutterExtent, extent, gutterExtent);\n        }\n        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n        this.helper.setUniformFloatValue(\n          Uniforms.RESOLUTION,\n          viewState.resolution\n        );\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileTextureCache = this.tileTextureCache_;\n    while (tileTextureCache.canExpireCache()) {\n      const tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileTextureCache_;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n   * tile textures by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileTextureCache = this.tileTextureCache_;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileTextureCache.containsKey(cacheKey)) {\n          const tileTexture = tileTextureCache.get(cacheKey);\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      const tileTextureCache = this.tileTextureCache_;\n      tileTextureCache.forEach((tileTexture) => tileTexture.dispose());\n      tileTextureCache.clear();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n\n      helper.deleteBuffer(this.indices_);\n    }\n\n    super.disposeInternal();\n\n    delete this.indices_;\n    delete this.tileTextureCache_;\n    delete this.frameState_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}