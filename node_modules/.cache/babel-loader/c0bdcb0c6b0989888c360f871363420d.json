{"ast":null,"code":"/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport { apply as applyTransform } from '../../transform.js';\nimport { clamp } from '../../math.js';\nconst tmpArray_ = [];\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n\nconst bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\n\n\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1]; // read custom numerical attributes on the feature\n\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride; // push vertices for each of the four quad corners (first standard then custom attributes)\n\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\n\nexport function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, instructionsTransform, invertInstructionsTransform) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride; // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n\n  const p0 = [instructions[segmentStartIndex + 0], instructions[segmentStartIndex + 1]];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]]; // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return Math.round(joinAngle1 * anglePrecision) + Math.round(joinAngle2 * anglePrecision) * shift + vertexNumber * shift * shift;\n  } // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n\n\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB]; // this angle can be clockwise or anticlockwise; hence the computation afterwards\n\n    const angle = lenA === 0 || lenB === 0 ? 0 : Math.acos(clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n  let angle0 = 0;\n  let angle1 = 0; // add vertices and adapt offsets for P0 in case of join\n\n  if (joinBefore) {\n    // B for before\n    const pB = [instructions[beforeSegmentIndex], instructions[beforeSegmentIndex + 1]];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  } // adapt offsets for P1 in case of join\n\n\n  if (joinAfter) {\n    // A for after\n    const pA = [instructions[afterSegmentIndex], instructions[afterSegmentIndex + 1]];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  } // add main segment triangles\n\n\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(0, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(1, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(2, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(3, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);\n}\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\n\nexport function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesCount) {\n  const instructionsPerVertex = 2; // x, y\n\n  const attributesPerVertex = 2 + customAttributesCount;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesCount);\n  instructionsIndex += customAttributesCount;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n\n  const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex); // pushing to vertices and indices!! this is where the magic happens\n\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\n\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\n\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\n\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}","map":{"version":3,"names":["earcut","apply","applyTransform","clamp","tmpArray_","bufferPositions_","vertexPosition","indexPosition","writePointVertex","buffer","pos","x","y","index","writePointFeatureToBuffers","instructions","elementIndex","vertexBuffer","indexBuffer","customAttributesCount","bufferPositions","baseVertexAttrsCount","baseInstructionsCount","stride","customAttrs","length","i","vPos","iPos","baseIndex","set","writeLineSegmentToBuffers","segmentStartIndex","segmentEndIndex","beforeSegmentIndex","afterSegmentIndex","vertexArray","indexArray","customAttributes","instructionsTransform","invertInstructionsTransform","p0","p1","p0world","p1world","computeVertexParameters","vertexNumber","joinAngle1","joinAngle2","shift","anglePrecision","Math","round","angleBetween","pA","pB","lenA","sqrt","tangentA","orthoA","lenB","tangentB","angle","acos","isClockwise","PI","joinBefore","joinAfter","angle0","angle1","pBworld","pAworld","push","writePolygonTrianglesToBuffers","polygonStartIndex","instructionsPerVertex","attributesPerVertex","instructionsIndex","slice","ringsCount","verticesCount","holes","Array","flatCoords","result","getBlankImageData","canvas","document","createElement","image","getContext","createImageData","data","colorEncodeId","id","array","radix","divide","floor","colorDecodeId","color","mult"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/render/webgl/utils.js"],"sourcesContent":["/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesCount,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  instructionsTransform,\n  invertInstructionsTransform\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return (\n      Math.round(joinAngle1 * anglePrecision) +\n      Math.round(joinAngle2 * anglePrecision) * shift +\n      vertexNumber * shift * shift\n    );\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(0, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(1, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(2, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(3, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesCount\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesCount;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesCount\n  );\n  instructionsIndex += customAttributesCount;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAAQC,KAAK,IAAIC,cAAjB,QAAsC,oBAAtC;AACA,SAAQC,KAAR,QAAoB,eAApB;AAEA,MAAMC,SAAS,GAAG,EAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAG;EAACC,cAAc,EAAE,CAAjB;EAAoBC,aAAa,EAAE;AAAnC,CAAzB;;AAEA,SAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,GAAlC,EAAuCC,CAAvC,EAA0CC,CAA1C,EAA6CC,KAA7C,EAAoD;EAClDJ,MAAM,CAACC,GAAG,GAAG,CAAP,CAAN,GAAkBC,CAAlB;EACAF,MAAM,CAACC,GAAG,GAAG,CAAP,CAAN,GAAkBE,CAAlB;EACAH,MAAM,CAACC,GAAG,GAAG,CAAP,CAAN,GAAkBG,KAAlB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,0BAAT,CACLC,YADK,EAELC,YAFK,EAGLC,YAHK,EAILC,WAJK,EAKLC,qBALK,EAMLC,eANK,EAOL;EACA;EACA,MAAMC,oBAAoB,GAAG,CAA7B;EACA,MAAMC,qBAAqB,GAAG,CAA9B;EACA,MAAMC,MAAM,GAAGF,oBAAoB,GAAGF,qBAAtC;EAEA,MAAMR,CAAC,GAAGI,YAAY,CAACC,YAAY,GAAG,CAAhB,CAAtB;EACA,MAAMJ,CAAC,GAAGG,YAAY,CAACC,YAAY,GAAG,CAAhB,CAAtB,CAPA,CASA;;EACA,MAAMQ,WAAW,GAAGpB,SAApB;EACAoB,WAAW,CAACC,MAAZ,GAAqBN,qBAArB;;EACA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,WAAW,CAACC,MAAhC,EAAwCC,CAAC,EAAzC,EAA6C;IAC3CF,WAAW,CAACE,CAAD,CAAX,GAAiBX,YAAY,CAACC,YAAY,GAAGM,qBAAf,GAAuCI,CAAxC,CAA7B;EACD;;EAED,IAAIC,IAAI,GAAGP,eAAe,GAAGA,eAAe,CAACd,cAAnB,GAAoC,CAA9D;EACA,IAAIsB,IAAI,GAAGR,eAAe,GAAGA,eAAe,CAACb,aAAnB,GAAmC,CAA7D;EACA,MAAMsB,SAAS,GAAGF,IAAI,GAAGJ,MAAzB,CAlBA,CAoBA;;EACAf,gBAAgB,CAACS,YAAD,EAAeU,IAAf,EAAqBhB,CAArB,EAAwBC,CAAxB,EAA2B,CAA3B,CAAhB;EACAY,WAAW,CAACC,MAAZ,IACER,YAAY,CAACa,GAAb,CAAiBN,WAAjB,EAA8BG,IAAI,GAAGN,oBAArC,CADF;EAEAM,IAAI,IAAIJ,MAAR;EAEAf,gBAAgB,CAACS,YAAD,EAAeU,IAAf,EAAqBhB,CAArB,EAAwBC,CAAxB,EAA2B,CAA3B,CAAhB;EACAY,WAAW,CAACC,MAAZ,IACER,YAAY,CAACa,GAAb,CAAiBN,WAAjB,EAA8BG,IAAI,GAAGN,oBAArC,CADF;EAEAM,IAAI,IAAIJ,MAAR;EAEAf,gBAAgB,CAACS,YAAD,EAAeU,IAAf,EAAqBhB,CAArB,EAAwBC,CAAxB,EAA2B,CAA3B,CAAhB;EACAY,WAAW,CAACC,MAAZ,IACER,YAAY,CAACa,GAAb,CAAiBN,WAAjB,EAA8BG,IAAI,GAAGN,oBAArC,CADF;EAEAM,IAAI,IAAIJ,MAAR;EAEAf,gBAAgB,CAACS,YAAD,EAAeU,IAAf,EAAqBhB,CAArB,EAAwBC,CAAxB,EAA2B,CAA3B,CAAhB;EACAY,WAAW,CAACC,MAAZ,IACER,YAAY,CAACa,GAAb,CAAiBN,WAAjB,EAA8BG,IAAI,GAAGN,oBAArC,CADF;EAEAM,IAAI,IAAIJ,MAAR;EAEAL,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAtB;EACAX,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAS,GAAG,CAAlC;EACAX,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAS,GAAG,CAAlC;EACAX,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAS,GAAG,CAAlC;EACAX,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAS,GAAG,CAAlC;EACAX,WAAW,CAACU,IAAI,EAAL,CAAX,GAAsBC,SAAS,GAAG,CAAlC;EAEAxB,gBAAgB,CAACC,cAAjB,GAAkCqB,IAAlC;EACAtB,gBAAgB,CAACE,aAAjB,GAAiCqB,IAAjC;EAEA,OAAOvB,gBAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS0B,yBAAT,CACLhB,YADK,EAELiB,iBAFK,EAGLC,eAHK,EAILC,kBAJK,EAKLC,iBALK,EAMLC,WANK,EAOLC,UAPK,EAQLC,gBARK,EASLC,qBATK,EAULC,2BAVK,EAWL;EACA;EACA,MAAMnB,oBAAoB,GAAG,CAA7B,CAFA,CAEgC;;EAChC,MAAME,MAAM,GAAGF,oBAAoB,GAAGiB,gBAAgB,CAACb,MAAvD;EACA,MAAMI,SAAS,GAAGO,WAAW,CAACX,MAAZ,GAAqBF,MAAvC,CAJA,CAMA;EACA;EACA;;EACA,MAAMkB,EAAE,GAAG,CACT1B,YAAY,CAACiB,iBAAiB,GAAG,CAArB,CADH,EAETjB,YAAY,CAACiB,iBAAiB,GAAG,CAArB,CAFH,CAAX;EAIA,MAAMU,EAAE,GAAG,CAAC3B,YAAY,CAACkB,eAAD,CAAb,EAAgClB,YAAY,CAACkB,eAAe,GAAG,CAAnB,CAA5C,CAAX,CAbA,CAeA;EACA;;EACA,MAAMU,OAAO,GAAGzC,cAAc,CAACsC,2BAAD,EAA8B,CAAC,GAAGC,EAAJ,CAA9B,CAA9B;EACA,MAAMG,OAAO,GAAG1C,cAAc,CAACsC,2BAAD,EAA8B,CAAC,GAAGE,EAAJ,CAA9B,CAA9B;;EAEA,SAASG,uBAAT,CAAiCC,YAAjC,EAA+CC,UAA/C,EAA2DC,UAA3D,EAAuE;IACrE,MAAMC,KAAK,GAAG,KAAd;IACA,MAAMC,cAAc,GAAG,IAAvB;IACA,OACEC,IAAI,CAACC,KAAL,CAAWL,UAAU,GAAGG,cAAxB,IACAC,IAAI,CAACC,KAAL,CAAWJ,UAAU,GAAGE,cAAxB,IAA0CD,KAD1C,GAEAH,YAAY,GAAGG,KAAf,GAAuBA,KAHzB;EAKD,CA5BD,CA8BA;EACA;;;EACA,SAASI,YAAT,CAAsBZ,EAAtB,EAA0Ba,EAA1B,EAA8BC,EAA9B,EAAkC;IAChC,MAAMC,IAAI,GAAGL,IAAI,CAACM,IAAL,CACX,CAACH,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAAX,KAAmBa,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAA7B,IAAoC,CAACa,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAAX,KAAmBa,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAA7B,CADzB,CAAb;IAGA,MAAMiB,QAAQ,GAAG,CAAC,CAACJ,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAAX,IAAkBe,IAAnB,EAAyB,CAACF,EAAE,CAAC,CAAD,CAAF,GAAQb,EAAE,CAAC,CAAD,CAAX,IAAkBe,IAA3C,CAAjB;IACA,MAAMG,MAAM,GAAG,CAAC,CAACD,QAAQ,CAAC,CAAD,CAAV,EAAeA,QAAQ,CAAC,CAAD,CAAvB,CAAf;IACA,MAAME,IAAI,GAAGT,IAAI,CAACM,IAAL,CACX,CAACF,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAAX,KAAmBc,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAA7B,IAAoC,CAACc,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAAX,KAAmBc,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAA7B,CADzB,CAAb;IAGA,MAAMoB,QAAQ,GAAG,CAAC,CAACN,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAAX,IAAkBmB,IAAnB,EAAyB,CAACL,EAAE,CAAC,CAAD,CAAF,GAAQd,EAAE,CAAC,CAAD,CAAX,IAAkBmB,IAA3C,CAAjB,CATgC,CAWhC;;IACA,MAAME,KAAK,GACTN,IAAI,KAAK,CAAT,IAAcI,IAAI,KAAK,CAAvB,GACI,CADJ,GAEIT,IAAI,CAACY,IAAL,CACE5D,KAAK,CAAC0D,QAAQ,CAAC,CAAD,CAAR,GAAcH,QAAQ,CAAC,CAAD,CAAtB,GAA4BG,QAAQ,CAAC,CAAD,CAAR,GAAcH,QAAQ,CAAC,CAAD,CAAnD,EAAwD,CAAC,CAAzD,EAA4D,CAA5D,CADP,CAHN;IAMA,MAAMM,WAAW,GAAGH,QAAQ,CAAC,CAAD,CAAR,GAAcF,MAAM,CAAC,CAAD,CAApB,GAA0BE,QAAQ,CAAC,CAAD,CAAR,GAAcF,MAAM,CAAC,CAAD,CAA9C,GAAoD,CAAxE;IACA,OAAO,CAACK,WAAD,GAAeb,IAAI,CAACc,EAAL,GAAU,CAAV,GAAcH,KAA7B,GAAqCA,KAA5C;EACD;;EAED,MAAMI,UAAU,GAAGhC,kBAAkB,KAAK,IAA1C;EACA,MAAMiC,SAAS,GAAGhC,iBAAiB,KAAK,IAAxC;EAEA,IAAIiC,MAAM,GAAG,CAAb;EACA,IAAIC,MAAM,GAAG,CAAb,CA1DA,CA4DA;;EACA,IAAIH,UAAJ,EAAgB;IACd;IACA,MAAMX,EAAE,GAAG,CACTxC,YAAY,CAACmB,kBAAD,CADH,EAETnB,YAAY,CAACmB,kBAAkB,GAAG,CAAtB,CAFH,CAAX;IAIA,MAAMoC,OAAO,GAAGpE,cAAc,CAACsC,2BAAD,EAA8B,CAAC,GAAGe,EAAJ,CAA9B,CAA9B;IACAa,MAAM,GAAGf,YAAY,CAACV,OAAD,EAAUC,OAAV,EAAmB0B,OAAnB,CAArB;EACD,CArED,CAsEA;;;EACA,IAAIH,SAAJ,EAAe;IACb;IACA,MAAMb,EAAE,GAAG,CACTvC,YAAY,CAACoB,iBAAD,CADH,EAETpB,YAAY,CAACoB,iBAAiB,GAAG,CAArB,CAFH,CAAX;IAIA,MAAMoC,OAAO,GAAGrE,cAAc,CAACsC,2BAAD,EAA8B,CAAC,GAAGc,EAAJ,CAA9B,CAA9B;IACAe,MAAM,GAAGhB,YAAY,CAACT,OAAD,EAAUD,OAAV,EAAmB4B,OAAnB,CAArB;EACD,CA/ED,CAiFA;;;EACAnC,WAAW,CAACoC,IAAZ,CACE/B,EAAE,CAAC,CAAD,CADJ,EAEEA,EAAE,CAAC,CAAD,CAFJ,EAGEC,EAAE,CAAC,CAAD,CAHJ,EAIEA,EAAE,CAAC,CAAD,CAJJ,EAKEG,uBAAuB,CAAC,CAAD,EAAIuB,MAAJ,EAAYC,MAAZ,CALzB;EAOAjC,WAAW,CAACoC,IAAZ,CAAiB,GAAGlC,gBAApB;EAEAF,WAAW,CAACoC,IAAZ,CACE/B,EAAE,CAAC,CAAD,CADJ,EAEEA,EAAE,CAAC,CAAD,CAFJ,EAGEC,EAAE,CAAC,CAAD,CAHJ,EAIEA,EAAE,CAAC,CAAD,CAJJ,EAKEG,uBAAuB,CAAC,CAAD,EAAIuB,MAAJ,EAAYC,MAAZ,CALzB;EAOAjC,WAAW,CAACoC,IAAZ,CAAiB,GAAGlC,gBAApB;EAEAF,WAAW,CAACoC,IAAZ,CACE/B,EAAE,CAAC,CAAD,CADJ,EAEEA,EAAE,CAAC,CAAD,CAFJ,EAGEC,EAAE,CAAC,CAAD,CAHJ,EAIEA,EAAE,CAAC,CAAD,CAJJ,EAKEG,uBAAuB,CAAC,CAAD,EAAIuB,MAAJ,EAAYC,MAAZ,CALzB;EAOAjC,WAAW,CAACoC,IAAZ,CAAiB,GAAGlC,gBAApB;EAEAF,WAAW,CAACoC,IAAZ,CACE/B,EAAE,CAAC,CAAD,CADJ,EAEEA,EAAE,CAAC,CAAD,CAFJ,EAGEC,EAAE,CAAC,CAAD,CAHJ,EAIEA,EAAE,CAAC,CAAD,CAJJ,EAKEG,uBAAuB,CAAC,CAAD,EAAIuB,MAAJ,EAAYC,MAAZ,CALzB;EAOAjC,WAAW,CAACoC,IAAZ,CAAiB,GAAGlC,gBAApB;EAEAD,UAAU,CAACmC,IAAX,CACE3C,SADF,EAEEA,SAAS,GAAG,CAFd,EAGEA,SAAS,GAAG,CAHd,EAIEA,SAAS,GAAG,CAJd,EAKEA,SAAS,GAAG,CALd,EAMEA,SAAS,GAAG,CANd;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS4C,8BAAT,CACL1D,YADK,EAEL2D,iBAFK,EAGLtC,WAHK,EAILC,UAJK,EAKLlB,qBALK,EAML;EACA,MAAMwD,qBAAqB,GAAG,CAA9B,CADA,CACiC;;EACjC,MAAMC,mBAAmB,GAAG,IAAIzD,qBAAhC;EACA,IAAI0D,iBAAiB,GAAGH,iBAAxB;EACA,MAAMpC,gBAAgB,GAAGvB,YAAY,CAAC+D,KAAb,CACvBD,iBADuB,EAEvBA,iBAAiB,GAAG1D,qBAFG,CAAzB;EAIA0D,iBAAiB,IAAI1D,qBAArB;EACA,MAAM4D,UAAU,GAAGhE,YAAY,CAAC8D,iBAAiB,EAAlB,CAA/B;EACA,IAAIG,aAAa,GAAG,CAApB;EACA,MAAMC,KAAK,GAAG,IAAIC,KAAJ,CAAUH,UAAU,GAAG,CAAvB,CAAd;;EACA,KAAK,IAAIrD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,UAApB,EAAgCrD,CAAC,EAAjC,EAAqC;IACnCsD,aAAa,IAAIjE,YAAY,CAAC8D,iBAAiB,EAAlB,CAA7B;;IACA,IAAInD,CAAC,GAAGqD,UAAU,GAAG,CAArB,EAAwB;MACtBE,KAAK,CAACvD,CAAD,CAAL,GAAWsD,aAAX;IACD;EACF;;EACD,MAAMG,UAAU,GAAGpE,YAAY,CAAC+D,KAAb,CACjBD,iBADiB,EAEjBA,iBAAiB,GAAGG,aAAa,GAAGL,qBAFnB,CAAnB,CAlBA,CAuBA;;EACA,MAAMS,MAAM,GAAGpF,MAAM,CAACmF,UAAD,EAAaF,KAAb,EAAoBN,qBAApB,CAArB;;EACA,KAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0D,MAAM,CAAC3D,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;IACtCW,UAAU,CAACmC,IAAX,CAAgBY,MAAM,CAAC1D,CAAD,CAAN,GAAYU,WAAW,CAACX,MAAZ,GAAqBmD,mBAAjD;EACD;;EACD,KAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyD,UAAU,CAAC1D,MAA/B,EAAuCC,CAAC,IAAI,CAA5C,EAA+C;IAC7CU,WAAW,CAACoC,IAAZ,CAAiBW,UAAU,CAACzD,CAAD,CAA3B,EAAgCyD,UAAU,CAACzD,CAAC,GAAG,CAAL,CAA1C,EAAmD,GAAGY,gBAAtD;EACD;;EAED,OAAOuC,iBAAiB,GAAGG,aAAa,GAAGL,qBAA3C;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASU,iBAAT,GAA6B;EAClC,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAf;EACA,MAAMC,KAAK,GAAGH,MAAM,CAACI,UAAP,CAAkB,IAAlB,EAAwBC,eAAxB,CAAwC,CAAxC,EAA2C,CAA3C,CAAd;EACAF,KAAK,CAACG,IAAN,CAAW,CAAX,IAAgB,GAAhB;EACAH,KAAK,CAACG,IAAN,CAAW,CAAX,IAAgB,GAAhB;EACAH,KAAK,CAACG,IAAN,CAAW,CAAX,IAAgB,GAAhB;EACAH,KAAK,CAACG,IAAN,CAAW,CAAX,IAAgB,GAAhB;EACA,OAAOH,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,aAAT,CAAuBC,EAAvB,EAA2BC,KAA3B,EAAkC;EACvCA,KAAK,GAAGA,KAAK,IAAI,EAAjB;EACA,MAAMC,KAAK,GAAG,GAAd;EACA,MAAMC,MAAM,GAAGD,KAAK,GAAG,CAAvB;EACAD,KAAK,CAAC,CAAD,CAAL,GAAW5C,IAAI,CAAC+C,KAAL,CAAWJ,EAAE,GAAGE,KAAL,GAAaA,KAAb,GAAqBA,KAAhC,IAAyCC,MAApD;EACAF,KAAK,CAAC,CAAD,CAAL,GAAY5C,IAAI,CAAC+C,KAAL,CAAWJ,EAAE,GAAGE,KAAL,GAAaA,KAAxB,IAAiCA,KAAlC,GAA2CC,MAAtD;EACAF,KAAK,CAAC,CAAD,CAAL,GAAY5C,IAAI,CAAC+C,KAAL,CAAWJ,EAAE,GAAGE,KAAhB,IAAyBA,KAA1B,GAAmCC,MAA9C;EACAF,KAAK,CAAC,CAAD,CAAL,GAAYD,EAAE,GAAGE,KAAN,GAAeC,MAA1B;EACA,OAAOF,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,aAAT,CAAuBC,KAAvB,EAA8B;EACnC,IAAIN,EAAE,GAAG,CAAT;EACA,MAAME,KAAK,GAAG,GAAd;EACA,MAAMK,IAAI,GAAGL,KAAK,GAAG,CAArB;EACAF,EAAE,IAAI3C,IAAI,CAACC,KAAL,CAAWgD,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAX,GAAmBA,KAAnB,GAA2BA,KAA3B,GAAmCK,IAA9C,CAAN;EACAP,EAAE,IAAI3C,IAAI,CAACC,KAAL,CAAWgD,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAX,GAAmBA,KAAnB,GAA2BK,IAAtC,CAAN;EACAP,EAAE,IAAI3C,IAAI,CAACC,KAAL,CAAWgD,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAX,GAAmBK,IAA9B,CAAN;EACAP,EAAE,IAAI3C,IAAI,CAACC,KAAL,CAAWgD,KAAK,CAAC,CAAD,CAAL,GAAWC,IAAtB,CAAN;EACA,OAAOP,EAAP;AACD"},"metadata":{},"sourceType":"module"}