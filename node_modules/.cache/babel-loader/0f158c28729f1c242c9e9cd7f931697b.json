{"ast":null,"code":"/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport { FLOAT, UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, getContext } from '../webgl.js';\nimport { clear } from '../obj.js';\nimport { compose as composeTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform } from '../transform.js';\nimport { create, fromTransform } from '../vec/mat4.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\n\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31\n};\n/**\n * Names of uniforms made available to all shaders.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\n\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n  SIZE_PX: 'u_sizePx',\n  PIXEL_RATIO: 'u_pixelRatio'\n};\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\n\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT\n};\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {HTMLCanvasElement} canvas Canvas element.\n * @property {number} users The count of users of this canvas.\n */\n\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\n\nconst canvasCache = {};\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\n\nfunction getSharedCanvasCacheKey(key) {\n  return 'shared/' + key;\n}\n\nlet uniqueCanvasCacheKeyCount = 0;\n/**\n * @return {string} The unique cache key.\n */\n\nfunction getUniqueCanvasCacheKey() {\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\n/**\n * @param {string} key The cache key for the canvas.\n * @return {HTMLCanvasElement} The canvas.\n */\n\n\nfunction getCanvas(key) {\n  let cacheItem = canvasCache[key];\n\n  if (!cacheItem) {\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.left = '0';\n    cacheItem = {\n      users: 0,\n      canvas\n    };\n    canvasCache[key] = cacheItem;\n  }\n\n  cacheItem.users += 1;\n  return cacheItem.canvas;\n}\n/**\n * @param {string} key The cache key for the canvas.\n */\n\n\nfunction releaseCanvas(key) {\n  const cacheItem = canvasCache[key];\n\n  if (!cacheItem) {\n    return;\n  }\n\n  cacheItem.users -= 1;\n\n  if (cacheItem.users > 0) {\n    return;\n  }\n\n  const canvas = cacheItem.canvas;\n  const gl = getContext(canvas);\n  const extension = gl.getExtension('WEBGL_lose_context');\n\n  if (extension) {\n    extension.loseContext();\n  }\n\n  delete canvasCache[key];\n}\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program, frameState);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n */\n\n\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n    /** @private */\n\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n    /** @private */\n\n    this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this);\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = getCanvas(this.canvasCacheKey_);\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n\n    this.gl_ = getContext(this.canvas_);\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n\n    this.bufferCache_ = {};\n    /**\n     * @private\n     * @type {Object<string, Object>}\n     */\n\n    this.extensionCache_ = {};\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n\n    this.currentProgram_ = null;\n    this.canvas_.addEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n    this.canvas_.addEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n\n    this.offsetRotateMatrix_ = createTransform();\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n\n    this.offsetScaleMatrix_ = createTransform();\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.tmpMat4_ = create();\n    /**\n     * @private\n     * @type {Object<string, WebGLUniformLocation>}\n     */\n\n    this.uniformLocations_ = {};\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n\n    this.attribLocations_ = {};\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n\n    this.uniforms_ = [];\n\n    if (options.uniforms) {\n      this.setUniforms(options.uniforms);\n    }\n\n    const gl = this.getGL();\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n\n    this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {\n      return new WebGLPostProcessingPass({\n        webGlContext: gl,\n        scaleRatio: options.scaleRatio,\n        vertexShader: options.vertexShader,\n        fragmentShader: options.fragmentShader,\n        uniforms: options.uniforms\n      });\n    }) : [new WebGLPostProcessingPass({\n      webGlContext: gl\n    })];\n    /**\n     * @type {string|null}\n     * @private\n     */\n\n    this.shaderCompileErrors_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.startTime_ = Date.now();\n  }\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n\n\n  setUniforms(uniforms) {\n    this.uniforms_ = [];\n\n    for (const name in uniforms) {\n      this.uniforms_.push({\n        name: name,\n        value: uniforms[name]\n      });\n    }\n\n    this.uniformLocations_ = {};\n  }\n  /**\n   * @param {string} canvasCacheKey The canvas cache key.\n   * @return {boolean} The provided key matches the one this helper was constructed with.\n   */\n\n\n  canvasCacheKeyMatches(canvasCacheKey) {\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n  }\n  /**\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\n   * Extensions are cached after they are enabled for the first time.\n   * @param {string} name The extension name.\n   * @return {Object|null} The extension or null if not supported.\n   */\n\n\n  getExtension(name) {\n    if (name in this.extensionCache_) {\n      return this.extensionCache_[name];\n    }\n\n    const extension = this.gl_.getExtension(name);\n    this.extensionCache_[name] = extension;\n    return extension;\n  }\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n\n\n  bindBuffer(buffer) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n\n\n  flushBufferData(buffer) {\n    const gl = this.getGL();\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n\n\n  deleteBuffer(buf) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n\n    delete this.bufferCache_[bufferKey];\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n    this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n    releaseCanvas(this.canvasCacheKey_);\n    delete this.gl_;\n    delete this.canvas_;\n  }\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   */\n\n\n  prepareDraw(frameState, disableAlphaBlend) {\n    const gl = this.getGL();\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px'; // loop backwards in post processes list\n\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n  }\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   */\n\n\n  prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend) {\n    const gl = this.getGL();\n    const size = renderTarget.getSize();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n  }\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   */\n\n\n  drawElements(start, end) {\n    const gl = this.getGL();\n    this.getExtension('OES_element_index_uint');\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n\n\n  finalizeDraw(frameState, preCompose, postCompose) {\n    // apply post processes using the next one as target\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n      if (i === ii - 1) {\n        this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);\n      } else {\n        this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);\n      }\n    }\n  }\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  getCanvas() {\n    return this.canvas_;\n  }\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n\n\n  getGL() {\n    return this.gl_;\n  }\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n    scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n    const offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n\n    if (rotation !== 0) {\n      rotateTransform(offsetRotateMatrix, -rotation);\n    }\n\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\n    this.setUniformFloatVec2(DefaultUniform.SIZE_PX, [size[0], size[1]]);\n  }\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach(function (uniform) {\n      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type\n\n      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.prevValue = undefined;\n          uniform.texture = gl.createTexture();\n        }\n\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const imageReady = !(value instanceof HTMLImageElement) ||\n        /** @type {HTMLImageElement} */\n        value.complete;\n\n        if (imageReady && uniform.prevValue !== value) {\n          uniform.prevValue = value;\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        } // fill texture slots by increasing index\n\n\n        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n      } else if (Array.isArray(value) && value.length === 6) {\n        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));\n      } else if (Array.isArray(value) && value.length <= 4) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);\n            return;\n\n          case 3:\n            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n            return;\n\n          case 4:\n            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n            return;\n\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\n      }\n    }.bind(this));\n  }\n  /**\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\n   * in the program will be set based on the current frame state and the helper configuration.\n   * @param {WebGLProgram} program Program.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  useProgram(program, frameState) {\n    const gl = this.getGL();\n    gl.useProgram(program);\n    this.currentProgram_ = program;\n    this.uniformLocations_ = {};\n    this.attribLocations_ = {};\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n\n\n  compileShader(source, type) {\n    const gl = this.getGL();\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n  /**\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   */\n\n\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.getGL();\n    const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n    const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      const message = `Fragment shader compliation failed: ${gl.getShaderInfoLog(fragmentShader)}`;\n      throw new Error(message);\n    }\n\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`;\n      throw new Error(message);\n    }\n\n    gl.deleteShader(vertexShader);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const message = `GL program linking failed: ${gl.getShaderInfoLog(vertexShader)}`;\n      throw new Error(message);\n    }\n\n    return program;\n  }\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   */\n\n\n  getUniformLocation(name) {\n    if (this.uniformLocations_[name] === undefined) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);\n    }\n\n    return this.uniformLocations_[name];\n  }\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   */\n\n\n  getAttributeLocation(name) {\n    if (this.attribLocations_[name] === undefined) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);\n    }\n\n    return this.attribLocations_[name];\n  }\n  /**\n   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   */\n\n\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n    resetTransform(transform);\n    composeTransform(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n    return transform;\n  }\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   */\n\n\n  setUniformFloatValue(uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  }\n  /**\n   * Give a value for a vec2 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n\n\n  setUniformFloatVec2(uniform, value) {\n    this.getGL().uniform2fv(this.getUniformLocation(uniform), value);\n  }\n  /**\n   * Give a value for a vec4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n\n\n  setUniformFloatVec4(uniform, value) {\n    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);\n  }\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   */\n\n\n  setUniformMatrixValue(uniform, value) {\n    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n  }\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n\n\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName); // the attribute has not been found in the shaders; do not enable it\n\n    if (location < 0) {\n      return;\n    }\n\n    this.getGL().enableVertexAttribArray(location);\n    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);\n  }\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   */\n\n\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n  /**\n   * WebGL context was lost\n   * @private\n   */\n\n\n  handleWebGLContextLost() {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n  }\n  /**\n   * WebGL context was restored\n   * @private\n   */\n\n\n  handleWebGLContextRestored() {}\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   */\n\n\n  createTexture(size, data, texture) {\n    const gl = this.getGL();\n    texture = texture || gl.createTexture(); // set params & size\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    if (data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    return texture;\n  }\n\n}\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n */\n\n\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n\n  return stride;\n}\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\n\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;","map":{"version":3,"names":["ContextEventType","Disposable","WebGLPostProcessingPass","FLOAT","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_SHORT","getContext","clear","compose","composeTransform","create","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","fromTransform","getUid","ShaderType","FRAGMENT_SHADER","VERTEX_SHADER","DefaultUniform","PROJECTION_MATRIX","OFFSET_SCALE_MATRIX","OFFSET_ROTATION_MATRIX","TIME","ZOOM","RESOLUTION","SIZE_PX","PIXEL_RATIO","AttributeType","canvasCache","getSharedCanvasCacheKey","key","uniqueCanvasCacheKeyCount","getUniqueCanvasCacheKey","getCanvas","cacheItem","canvas","document","createElement","style","position","left","users","releaseCanvas","gl","extension","getExtension","loseContext","WebGLHelper","constructor","options","boundHandleWebGLContextLost_","handleWebGLContextLost","bind","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvasCacheKey_","canvasCacheKey","canvas_","gl_","bufferCache_","extensionCache_","currentProgram_","addEventListener","LOST","RESTORED","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","uniformLocations_","attribLocations_","uniforms_","uniforms","setUniforms","getGL","postProcessPasses_","postProcesses","map","webGlContext","scaleRatio","vertexShader","fragmentShader","shaderCompileErrors_","startTime_","Date","now","name","push","value","canvasCacheKeyMatches","bindBuffer","buffer","bufferKey","bufferCache","webGlBuffer","createBuffer","getType","flushBufferData","bufferData","getArray","getUsage","deleteBuffer","buf","bufferCacheEntry","isContextLost","disposeInternal","removeEventListener","prepareDraw","frameState","disableAlphaBlend","size","pixelRatio","width","height","i","length","init","bindTexture","TEXTURE_2D","clearColor","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ZERO","ONE_MINUS_SRC_ALPHA","prepareDrawToRenderTarget","renderTarget","getSize","bindFramebuffer","FRAMEBUFFER","getFramebuffer","viewport","getTexture","drawElements","start","end","elementType","elementSize","numItems","offsetInBytes","TRIANGLES","finalizeDraw","preCompose","postCompose","ii","apply","applyFrameState","rotation","viewState","offsetScaleMatrix","offsetRotateMatrix","setUniformMatrixValue","setUniformFloatValue","zoom","resolution","setUniformFloatVec2","applyUniforms","textureSlot","forEach","uniform","HTMLCanvasElement","HTMLImageElement","ImageData","texture","prevValue","undefined","createTexture","activeTexture","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","imageReady","complete","texImage2D","RGBA","uniform1i","getUniformLocation","Array","isArray","uniform2f","uniform3f","uniform4f","uniform1f","useProgram","program","compileShader","source","type","shader","createShader","shaderSource","getProgram","fragmentShaderSource","vertexShaderSource","createProgram","attachShader","linkProgram","getShaderParameter","COMPILE_STATUS","message","getShaderInfoLog","Error","deleteShader","getProgramParameter","LINK_STATUS","getAttributeLocation","getAttribLocation","makeProjectionTransform","transform","center","uniform2fv","setUniformFloatVec4","uniform4fv","uniformMatrix4fv","enableAttributeArray_","attribName","stride","offset","location","enableVertexAttribArray","vertexAttribPointer","enableAttributes","attributes","computeAttributesStride","attr","getByteSizeFromType","data","level","internalFormat","border","format","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","Float32Array"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/webgl/Helper.js"],"sourcesContent":["/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport {\n  FLOAT,\n  UNSIGNED_BYTE,\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  getContext,\n} from '../webgl.js';\nimport {clear} from '../obj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n} from '../transform.js';\nimport {create, fromTransform} from '../vec/mat4.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n};\n\n/**\n * Names of uniforms made available to all shaders.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n  SIZE_PX: 'u_sizePx',\n  PIXEL_RATIO: 'u_pixelRatio',\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT,\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {HTMLCanvasElement} canvas Canvas element.\n * @property {number} users The count of users of this canvas.\n */\n\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\nconst canvasCache = {};\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\nfunction getSharedCanvasCacheKey(key) {\n  return 'shared/' + key;\n}\n\nlet uniqueCanvasCacheKeyCount = 0;\n\n/**\n * @return {string} The unique cache key.\n */\nfunction getUniqueCanvasCacheKey() {\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {HTMLCanvasElement} The canvas.\n */\nfunction getCanvas(key) {\n  let cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.left = '0';\n    cacheItem = {users: 0, canvas};\n    canvasCache[key] = cacheItem;\n  }\n\n  cacheItem.users += 1;\n  return cacheItem.canvas;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n */\nfunction releaseCanvas(key) {\n  const cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    return;\n  }\n\n  cacheItem.users -= 1;\n  if (cacheItem.users > 0) {\n    return;\n  }\n\n  const canvas = cacheItem.canvas;\n  const gl = getContext(canvas);\n  const extension = gl.getExtension('WEBGL_lose_context');\n  if (extension) {\n    extension.loseContext();\n  }\n\n  delete canvasCache[key];\n}\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program, frameState);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n */\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    /** @private */\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n\n    /** @private */\n    this.boundHandleWebGLContextRestored_ =\n      this.handleWebGLContextRestored.bind(this);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.canvasCacheKey_ = options.canvasCacheKey\n      ? getSharedCanvasCacheKey(options.canvasCacheKey)\n      : getUniqueCanvasCacheKey();\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = getCanvas(this.canvasCacheKey_);\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = getContext(this.canvas_);\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object>}\n     */\n    this.extensionCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n\n    this.canvas_.addEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.addEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object<string, WebGLUniformLocation>}\n     */\n    this.uniformLocations_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.attribLocations_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    if (options.uniforms) {\n      this.setUniforms(options.uniforms);\n    }\n\n    const gl = this.getGL();\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    this.postProcessPasses_ = options.postProcesses\n      ? options.postProcesses.map(function (options) {\n          return new WebGLPostProcessingPass({\n            webGlContext: gl,\n            scaleRatio: options.scaleRatio,\n            vertexShader: options.vertexShader,\n            fragmentShader: options.fragmentShader,\n            uniforms: options.uniforms,\n          });\n        })\n      : [new WebGLPostProcessingPass({webGlContext: gl})];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startTime_ = Date.now();\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  setUniforms(uniforms) {\n    this.uniforms_ = [];\n    for (const name in uniforms) {\n      this.uniforms_.push({\n        name: name,\n        value: uniforms[name],\n      });\n    }\n    this.uniformLocations_ = {};\n  }\n\n  /**\n   * @param {string} canvasCacheKey The canvas cache key.\n   * @return {boolean} The provided key matches the one this helper was constructed with.\n   */\n  canvasCacheKeyMatches(canvasCacheKey) {\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n  }\n\n  /**\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\n   * Extensions are cached after they are enabled for the first time.\n   * @param {string} name The extension name.\n   * @return {Object|null} The extension or null if not supported.\n   */\n  getExtension(name) {\n    if (name in this.extensionCache_) {\n      return this.extensionCache_[name];\n    }\n    const extension = this.gl_.getExtension(name);\n    this.extensionCache_[name] = extension;\n    return extension;\n  }\n\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  bindBuffer(buffer) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer,\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  flushBufferData(buffer) {\n    const gl = this.getGL();\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  deleteBuffer(buf) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.canvas_.removeEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.removeEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    releaseCanvas(this.canvasCacheKey_);\n\n    delete this.gl_;\n    delete this.canvas_;\n  }\n\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   */\n  prepareDraw(frameState, disableAlphaBlend) {\n    const gl = this.getGL();\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n\n    // loop backwards in post processes list\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n  }\n\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   */\n  prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend) {\n    const gl = this.getGL();\n    const size = renderTarget.getSize();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n  }\n\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   */\n  drawElements(start, end) {\n    const gl = this.getGL();\n    this.getExtension('OES_element_index_uint');\n\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n  finalizeDraw(frameState, preCompose, postCompose) {\n    // apply post processes using the next one as target\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n      if (i === ii - 1) {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          null,\n          preCompose,\n          postCompose\n        );\n      } else {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          this.postProcessPasses_[i + 1]\n        );\n      }\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getCanvas() {\n    return this.canvas_;\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n    scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n\n    const offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      rotateTransform(offsetRotateMatrix, -rotation);\n    }\n\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_SCALE_MATRIX,\n      fromTransform(this.tmpMat4_, offsetScaleMatrix)\n    );\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_ROTATION_MATRIX,\n      fromTransform(this.tmpMat4_, offsetRotateMatrix)\n    );\n\n    this.setUniformFloatValue(\n      DefaultUniform.TIME,\n      (Date.now() - this.startTime_) * 0.001\n    );\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(\n      DefaultUniform.RESOLUTION,\n      frameState.viewState.resolution\n    );\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\n    this.setUniformFloatVec2(DefaultUniform.SIZE_PX, [size[0], size[1]]);\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach(\n      function (uniform) {\n        value =\n          typeof uniform.value === 'function'\n            ? uniform.value(frameState)\n            : uniform.value;\n\n        // apply value based on type\n        if (\n          value instanceof HTMLCanvasElement ||\n          value instanceof HTMLImageElement ||\n          value instanceof ImageData\n        ) {\n          // create a texture & put data\n          if (!uniform.texture) {\n            uniform.prevValue = undefined;\n            uniform.texture = gl.createTexture();\n          }\n          gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n          gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n          const imageReady =\n            !(value instanceof HTMLImageElement) ||\n            /** @type {HTMLImageElement} */ (value).complete;\n          if (imageReady && uniform.prevValue !== value) {\n            uniform.prevValue = value;\n            gl.texImage2D(\n              gl.TEXTURE_2D,\n              0,\n              gl.RGBA,\n              gl.RGBA,\n              gl.UNSIGNED_BYTE,\n              value\n            );\n          }\n\n          // fill texture slots by increasing index\n          gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n        } else if (Array.isArray(value) && value.length === 6) {\n          this.setUniformMatrixValue(\n            uniform.name,\n            fromTransform(this.tmpMat4_, value)\n          );\n        } else if (Array.isArray(value) && value.length <= 4) {\n          switch (value.length) {\n            case 2:\n              gl.uniform2f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1]\n              );\n              return;\n            case 3:\n              gl.uniform3f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2]\n              );\n              return;\n            case 4:\n              gl.uniform4f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2],\n                value[3]\n              );\n              return;\n            default:\n              return;\n          }\n        } else if (typeof value === 'number') {\n          gl.uniform1f(this.getUniformLocation(uniform.name), value);\n        }\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\n   * in the program will be set based on the current frame state and the helper configuration.\n   * @param {WebGLProgram} program Program.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  useProgram(program, frameState) {\n    const gl = this.getGL();\n    gl.useProgram(program);\n    this.currentProgram_ = program;\n    this.uniformLocations_ = {};\n    this.attribLocations_ = {};\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  compileShader(source, type) {\n    const gl = this.getGL();\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  /**\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   */\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.getGL();\n\n    const fragmentShader = this.compileShader(\n      fragmentShaderSource,\n      gl.FRAGMENT_SHADER\n    );\n\n    const vertexShader = this.compileShader(\n      vertexShaderSource,\n      gl.VERTEX_SHADER\n    );\n\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      const message = `Fragment shader compliation failed: ${gl.getShaderInfoLog(\n        fragmentShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(vertexShader);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const message = `GL program linking failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n\n    return program;\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   */\n  getUniformLocation(name) {\n    if (this.uniformLocations_[name] === undefined) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.uniformLocations_[name];\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   */\n  getAttributeLocation(name) {\n    if (this.attribLocations_[name] === undefined) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.attribLocations_[name];\n  }\n\n  /**\n   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   */\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n\n    resetTransform(transform);\n    composeTransform(\n      transform,\n      0,\n      0,\n      2 / (resolution * size[0]),\n      2 / (resolution * size[1]),\n      -rotation,\n      -center[0],\n      -center[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   */\n  setUniformFloatValue(uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec2 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec2(uniform, value) {\n    this.getGL().uniform2fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec4(uniform, value) {\n    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   */\n  setUniformMatrixValue(uniform, value) {\n    this.getGL().uniformMatrix4fv(\n      this.getUniformLocation(uniform),\n      false,\n      value\n    );\n  }\n\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.getGL().enableVertexAttribArray(location);\n    this.getGL().vertexAttribPointer(\n      location,\n      size,\n      type,\n      false,\n      stride,\n      offset\n    );\n  }\n\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   */\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(\n        attr.name,\n        attr.size,\n        attr.type || FLOAT,\n        stride,\n        offset\n      );\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n\n  /**\n   * WebGL context was lost\n   * @private\n   */\n  handleWebGLContextLost() {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n  }\n\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  handleWebGLContextRestored() {}\n\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   */\n  createTexture(size, data, texture) {\n    const gl = this.getGL();\n    texture = texture || gl.createTexture();\n\n    // set params & size\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\n    } else {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        size[0],\n        size[1],\n        border,\n        format,\n        type,\n        null\n      );\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return texture;\n  }\n}\n\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n */\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;\n"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiB,WAAN,SAA0BpD,UAA1B,CAAqC;EACnC;AACF;AACA;EACEqD,WAAW,CAACC,OAAD,EAAU;IACnB;IACAA,OAAO,GAAGA,OAAO,IAAI,EAArB;IAEA;;IACA,KAAKC,4BAAL,GAAoC,KAAKC,sBAAL,CAA4BC,IAA5B,CAAiC,IAAjC,CAApC;IAEA;;IACA,KAAKC,gCAAL,GACE,KAAKC,0BAAL,CAAgCF,IAAhC,CAAqC,IAArC,CADF;IAGA;AACJ;AACA;AACA;;IACI,KAAKG,eAAL,GAAuBN,OAAO,CAACO,cAAR,GACnB3B,uBAAuB,CAACoB,OAAO,CAACO,cAAT,CADJ,GAEnBxB,uBAAuB,EAF3B;IAIA;AACJ;AACA;AACA;;IACI,KAAKyB,OAAL,GAAexB,SAAS,CAAC,KAAKsB,eAAN,CAAxB;IAEA;AACJ;AACA;AACA;;IACI,KAAKG,GAAL,GAAWzD,UAAU,CAAC,KAAKwD,OAAN,CAArB;IAEA;AACJ;AACA;AACA;;IACI,KAAKE,YAAL,GAAoB,EAApB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,eAAL,GAAuB,EAAvB;IAEA;AACJ;AACA;AACA;;IA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"},"metadata":{},"sourceType":"module"}