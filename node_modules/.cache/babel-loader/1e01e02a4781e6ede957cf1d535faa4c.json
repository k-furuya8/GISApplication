{"ast":null,"code":"/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\n\nconst DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\n * @type {Array<number>}\n * @private\n */\n\nconst INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 30 / 60, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\n\nclass Graticule extends VectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const baseOptions = Object.assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    super(baseOptions);\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n    this.projection_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxLat_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxLon_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.minLat_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.minLon_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxX_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxY_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.minX_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.minY_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n\n    this.meridians_ = [];\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n\n    this.parallels_ = [];\n    /**\n     * @type {Stroke}\n     * @private\n     */\n\n    this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n\n    this.fromLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n\n    this.toLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.projectionCenterLonLat_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.bottomLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.bottomRight_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.topLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.topRight_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n\n    this.meridiansLabels_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n\n    this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(this, 'EW') : options.lonLabelFormatter;\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n\n      this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(this, 'NS') : options.latLabelFormatter;\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n\n      this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n\n      this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\n       * @type {Style}\n       * @private\n       */\n\n      this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n\n      this.lonLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(this);\n      /**\n       * @type {Style}\n       * @private\n       */\n\n\n      this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n\n      this.latLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(this);\n\n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\n    }\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n\n    this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS; // use a source with a custom loader for lines & text\n\n    this.setSource(new VectorSource({\n      loader: this.loaderFunction.bind(this),\n      strategy: this.strategyFunction.bind(this),\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n\n    this.featurePool_ = [];\n    /**\n     * @type {Style}\n     * @private\n     */\n\n    this.lineStyle_ = new Style({\n      stroke: this.strokeStyle_\n    });\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n\n    this.loadedExtent_ = null;\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n\n    this.renderedExtent_ = null;\n    /**\n     * @type {?number}\n     * @private\n     */\n\n    this.renderedResolution_ = null;\n    this.setRenderOrder(null);\n  }\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n\n\n  strategyFunction(extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    let realWorldExtent = extent.slice();\n\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n\n    if (this.loadedExtent_) {\n      if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n\n    return [realWorldExtent];\n  }\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n\n\n  loaderFunction(extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    const source = this.getSource(); // only consider the intersection between our own extent & the requested one\n\n    const layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    const renderExtent = getIntersection(layerExtent, extent);\n\n    if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {\n      return;\n    }\n\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution; // bail out if nothing to render\n\n    if (isEmpty(renderExtent)) {\n      return;\n    } // update projection info\n\n\n    const center = getCenter(renderExtent);\n    const squaredTolerance = resolution * resolution / 4;\n    const updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance); // first make sure we have enough features in the pool\n\n    let featureCount = this.meridians_.length + this.parallels_.length;\n\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    let feature;\n\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    const featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    let poolIndex = 0; // add features for the lines & labels\n\n    let i, l;\n\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  }\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n\n\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    const lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        const text = this.lonLabelFormatter_(lon);\n\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n\n      this.meridians_[index++] = lineString;\n    }\n\n    return index;\n  }\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n\n\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    const lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        const text = this.latLabelFormatter_(lat);\n\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n\n      this.parallels_[index++] = lineString;\n    }\n\n    return index;\n  }\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n\n\n  drawLabels_(event) {\n    const rotation = event.frameState.viewState.rotation;\n    const resolution = event.frameState.viewState.resolution;\n    const size = event.frameState.size;\n    const extent = event.frameState.extent;\n    const rotationCenter = getCenter(extent);\n    let rotationExtent = extent;\n\n    if (rotation) {\n      const unrotatedWidth = size[0] * resolution;\n      const unrotatedHeight = size[1] * resolution;\n      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n    }\n\n    let startWorld = 0;\n    let endWorld = 0;\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      const inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n\n    const vectorContext = getVectorContext(event);\n\n    for (let world = startWorld; world <= endWorld; ++world) {\n      let poolIndex = this.meridians_.length + this.parallels_.length;\n      let feature, index, l, textPoint;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          const lineString = this.meridians_[index];\n\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            const clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n\n      if (this.parallelsLabels_) {\n        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            const lineString = this.parallels_[index];\n\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              const clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n\n\n  createGraticule_(extent, center, resolution, squaredTolerance) {\n    const interval = this.getInterval_(resolution);\n\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n\n      return;\n    }\n\n    let wrapX = false;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    } // Constrain the center to fit into the extent available to the graticule\n\n\n    const validCenterP = [clamp(center[0], this.minX_, this.maxX_), clamp(center[1], this.minY_, this.maxY_)]; // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\n\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    const maxLines = this.maxLines_;\n    let cnt, idx, lat, lon; // Limit the extent to fit into the extent available to the graticule\n\n    let validExtentP = extent;\n\n    if (!wrapX) {\n      validExtentP = [clamp(extent[0], this.minX_, this.maxX_), clamp(extent[1], this.minY_, this.maxY_), clamp(extent[2], this.minX_, this.maxX_), clamp(extent[3], this.minY_, this.maxY_)];\n    } // Transform the extent to get the lon lat ranges for the edges of the extent\n\n\n    const validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n    let maxLat = validExtent[3];\n    let maxLon = validExtent[2];\n    let minLat = validExtent[1];\n    let minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      } // The transformed center may also extend the lon lat ranges used for rendering\n\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    } // Create meridians\n\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n\n    this.meridians_.length = idx;\n\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    } // Create parallels\n\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    this.parallels_.length = idx;\n\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  }\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n\n\n  getInterval_(resolution) {\n    const centerLon = this.projectionCenterLonLat_[0];\n    const centerLat = this.projectionCenterLonLat_[1];\n    let interval = -1;\n    const target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n\n    const p1 = [];\n    /** @type {Array<number>} **/\n\n    const p2 = [];\n\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      const delta = clamp(this.intervals_[i] / 2, 0, 90); // Don't attempt to transform latitudes beyond the poles!\n\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n\n      if (dist <= target) {\n        break;\n      }\n\n      interval = this.intervals_[i];\n    }\n\n    return interval;\n  }\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n\n\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n    const flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    let lineString = this.meridians_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  }\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n\n\n  getMeridianPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let bottom = 1;\n    let top = flatCoordinates.length - 1;\n\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    const lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    const coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n    const coordinate = [coordinate0, lat];\n    const point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n\n\n  getMeridians() {\n    return this.meridians_;\n  }\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n\n\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n    const flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    let lineString = this.parallels_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  }\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n\n\n  getParallelPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let left = 0;\n    let right = flatCoordinates.length - 2;\n\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    const lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    const coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n    const coordinate = [lon, coordinate1];\n    const point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n\n\n  getParallels() {\n    return this.parallels_;\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  updateProjectionInfo_(projection) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n    const worldExtent = projection.getWorldExtent();\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0]; // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\n\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      const split = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n\n      this.toLonLatTransform_ = function (coordinates, output, dimension) {\n        dimension = dimension || 2;\n        const lonLatCoordinates = toLonLatTransform(coordinates, output, dimension);\n\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n\n        return lonLatCoordinates;\n      };\n    } // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    const worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3]; // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]); // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  }\n\n}\n\nexport default Graticule;","map":{"version":3,"names":["Collection","EventType","Feature","Fill","LineString","Point","Stroke","Style","Text","VectorLayer","VectorSource","applyTransform","approximatelyEquals","containsCoordinate","containsExtent","equals","getCenter","getIntersection","getWidth","intersects","isEmpty","wrapX","wrapExtentX","clamp","degreesToStringHDMS","equivalent","equivalentProjection","get","getProjection","getTransform","getVectorContext","meridian","parallel","DEFAULT_STROKE_STYLE","color","INTERVALS","Graticule","constructor","options","baseOptions","Object","assign","updateWhileAnimating","updateWhileInteracting","renderBuffer","maxLines","strokeStyle","targetSize","showLabels","lonLabelFormatter","latLabelFormatter","lonLabelPosition","latLabelPosition","lonLabelStyle","latLabelStyle","intervals","projection_","maxLat_","Infinity","maxLon_","minLat_","minLon_","maxX_","maxY_","minX_","minY_","targetSize_","undefined","maxLines_","meridians_","parallels_","strokeStyle_","fromLonLatTransform_","toLonLatTransform_","projectionCenterLonLat_","bottomLeft_","bottomRight_","topLeft_","topRight_","meridiansLabels_","parallelsLabels_","lonLabelFormatter_","bind","latLabelFormatter_","lonLabelPosition_","latLabelPosition_","lonLabelStyleBase_","text","clone","font","textBaseline","fill","stroke","width","lonLabelStyle_","feature","label","getText","setText","latLabelStyleBase_","textAlign","latLabelStyle_","addEventListener","POSTRENDER","drawLabels_","intervals_","setSource","loader","loaderFunction","strategy","strategyFunction","features","overlaps","useSpatialIndex","featurePool_","lineStyle_","loadedExtent_","renderedExtent_","renderedResolution_","setRenderOrder","extent","resolution","realWorldExtent","slice","getSource","getWrapX","removeLoadedExtent","projection","source","layerExtent","getExtent","renderExtent","center","squaredTolerance","updateProjectionInfo","updateProjectionInfo_","createGraticule_","featureCount","length","push","featuresColl","getFeaturesCollection","clear","poolIndex","i","l","setGeometry","setStyle","addMeridian_","lon","minLat","maxLat","index","lineString","getMeridian_","geom","addParallel_","lat","minLon","maxLon","getParallel_","event","rotation","frameState","viewState","size","rotationCenter","rotationExtent","unrotatedWidth","unrotatedHeight","startWorld","endWorld","labelsAtStart","projectionExtent","worldWidth","canWrapX","Math","floor","ceil","inverted","abs","PI","vectorContext","world","textPoint","getMeridianPoint_","translate","rotate","set","drawFeature","getParallelPoint_","interval","getInterval_","validCenterP","centerLonLat","isNaN","centerLon","centerLat","cnt","idx","validExtentP","validExtent","max","min","target","pow","p1","p2","ii","delta","clampedLat","dist","flatCoordinates","setFlatCoordinates","changed","getFlatCoordinates","bottom","top","clampedBottom","clampedTop","coordinate0","coordinate","point","setCoordinates","getMeridians","left","right","clampedLeft","clampedRight","coordinate1","getParallels","epsg4326Projection","worldExtent","getWorldExtent","toLonLatTransform","split","coordinates","output","dimension","lonLatCoordinates","worldExtentP"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/layer/Graticule.js"],"sourcesContent":["/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  applyTransform,\n  approximatelyEquals,\n  containsCoordinate,\n  containsExtent,\n  equals,\n  getCenter,\n  getIntersection,\n  getWidth,\n  intersects,\n  isEmpty,\n  wrapX as wrapExtentX,\n} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {degreesToStringHDMS} from '../coordinate.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n} from '../proj.js';\nimport {getVectorContext} from '../render.js';\nimport {meridian, parallel} from '../geom/flat/geodesic.js';\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nconst DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)',\n});\n\n/**\n * @type {Array<number>}\n * @private\n */\nconst INTERVALS = [\n  90,\n  45,\n  30,\n  20,\n  10,\n  5,\n  2,\n  1,\n  30 / 60,\n  20 / 60,\n  10 / 60,\n  5 / 60,\n  2 / 60,\n  1 / 60,\n  30 / 3600,\n  20 / 3600,\n  10 / 3600,\n  5 / 3600,\n  2 / 3600,\n  1 / 3600,\n];\n\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nclass Graticule extends VectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign(\n      {\n        updateWhileAnimating: true,\n        updateWhileInteracting: true,\n        renderBuffer: 0,\n      },\n      options\n    );\n\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    super(baseOptions);\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLat_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLon_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLat_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLon_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxX_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxY_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minX_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minY_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.targetSize_ =\n      options.targetSize !== undefined ? options.targetSize : 100;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.meridians_ = [];\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.parallels_ = [];\n\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    this.strokeStyle_ =\n      options.strokeStyle !== undefined\n        ? options.strokeStyle\n        : DEFAULT_STROKE_STYLE;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.fromLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.toLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.projectionCenterLonLat_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomRight_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topRight_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.meridiansLabels_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ =\n        options.lonLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'EW')\n          : options.lonLabelFormatter;\n\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      this.latLabelFormatter_ =\n        options.latLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'NS')\n          : options.latLabelFormatter;\n\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      this.lonLabelPosition_ =\n        options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      this.latLabelPosition_ =\n        options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.lonLabelStyleBase_ = new Style({\n        text:\n          options.lonLabelStyle !== undefined\n            ? options.lonLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textBaseline: 'bottom',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.lonLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(this);\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.latLabelStyleBase_ = new Style({\n        text:\n          options.latLabelStyle !== undefined\n            ? options.latLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textAlign: 'right',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.latLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(this);\n\n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\n    }\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.intervals_ =\n      options.intervals !== undefined ? options.intervals : INTERVALS;\n\n    // use a source with a custom loader for lines & text\n    this.setSource(\n      new VectorSource({\n        loader: this.loaderFunction.bind(this),\n        strategy: this.strategyFunction.bind(this),\n        features: new Collection(),\n        overlaps: false,\n        useSpatialIndex: false,\n        wrapX: options.wrapX,\n      })\n    );\n\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    this.featurePool_ = [];\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.lineStyle_ = new Style({\n      stroke: this.strokeStyle_,\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.loadedExtent_ = null;\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.renderedResolution_ = null;\n\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  strategyFunction(extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    let realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (\n        approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)\n      ) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  }\n\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  loaderFunction(extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    const source = this.getSource();\n\n    // only consider the intersection between our own extent & the requested one\n    const layerExtent = this.getExtent() || [\n      -Infinity,\n      -Infinity,\n      Infinity,\n      Infinity,\n    ];\n    const renderExtent = getIntersection(layerExtent, extent);\n\n    if (\n      this.renderedExtent_ &&\n      equals(this.renderedExtent_, renderExtent) &&\n      this.renderedResolution_ === resolution\n    ) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution;\n\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n\n    // update projection info\n    const center = getCenter(renderExtent);\n    const squaredTolerance = (resolution * resolution) / 4;\n\n    const updateProjectionInfo =\n      !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n\n    // first make sure we have enough features in the pool\n    let featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    let feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    const featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    let poolIndex = 0;\n\n    // add features for the lines & labels\n    let i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    const lineString = this.getMeridian_(\n      lon,\n      minLat,\n      maxLat,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        const text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    const lineString = this.getParallel_(\n      lat,\n      minLon,\n      maxLon,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        const text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  drawLabels_(event) {\n    const rotation = event.frameState.viewState.rotation;\n    const resolution = event.frameState.viewState.resolution;\n    const size = event.frameState.size;\n    const extent = event.frameState.extent;\n    const rotationCenter = getCenter(extent);\n    let rotationExtent = extent;\n    if (rotation) {\n      const unrotatedWidth = size[0] * resolution;\n      const unrotatedHeight = size[1] * resolution;\n      rotationExtent = [\n        rotationCenter[0] - unrotatedWidth / 2,\n        rotationCenter[1] - unrotatedHeight / 2,\n        rotationCenter[0] + unrotatedWidth / 2,\n        rotationCenter[1] + unrotatedHeight / 2,\n      ];\n    }\n\n    let startWorld = 0;\n    let endWorld = 0;\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      const inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    const vectorContext = getVectorContext(event);\n\n    for (let world = startWorld; world <= endWorld; ++world) {\n      let poolIndex = this.meridians_.length + this.parallels_.length;\n      let feature, index, l, textPoint;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          const lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            const clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (\n          (world === startWorld && labelsAtStart) ||\n          (world === endWorld && !labelsAtStart)\n        ) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            const lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              const clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  createGraticule_(extent, center, resolution, squaredTolerance) {\n    const interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n\n    let wrapX = false;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n\n    // Constrain the center to fit into the extent available to the graticule\n\n    const validCenterP = [\n      clamp(center[0], this.minX_, this.maxX_),\n      clamp(center[1], this.minY_, this.maxY_),\n    ];\n\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    const maxLines = this.maxLines_;\n    let cnt, idx, lat, lon;\n\n    // Limit the extent to fit into the extent available to the graticule\n\n    let validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [\n        clamp(extent[0], this.minX_, this.maxX_),\n        clamp(extent[1], this.minY_, this.maxY_),\n        clamp(extent[2], this.minX_, this.maxX_),\n        clamp(extent[3], this.minY_, this.maxY_),\n      ];\n    }\n\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n\n    const validExtent = applyTransform(\n      validExtentP,\n      this.toLonLatTransform_,\n      undefined,\n      8\n    );\n\n    let maxLat = validExtent[3];\n    let maxLon = validExtent[2];\n    let minLat = validExtent[1];\n    let minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n\n      // The transformed center may also extend the lon lat ranges used for rendering\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n\n    // Create meridians\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n\n    // Create parallels\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  getInterval_(resolution) {\n    const centerLon = this.projectionCenterLonLat_[0];\n    const centerLat = this.projectionCenterLonLat_[1];\n    let interval = -1;\n    const target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    const p1 = [];\n    /** @type {Array<number>} **/\n    const p2 = [];\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      const delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n    const flatCoordinates = meridian(\n      lon,\n      minLat,\n      maxLat,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  getMeridianPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let bottom = 1;\n    let top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    const lat = clamp(\n      extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\n      clampedBottom,\n      clampedTop\n    );\n    const coordinate0 =\n      flatCoordinates[bottom - 1] +\n      ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n        (lat - flatCoordinates[bottom])) /\n        (flatCoordinates[top] - flatCoordinates[bottom]);\n    const coordinate = [coordinate0, lat];\n    const point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  getMeridians() {\n    return this.meridians_;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n    const flatCoordinates = parallel(\n      lat,\n      minLon,\n      maxLon,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, 'XY');\n    } else {\n      lineString.setFlatCoordinates('XY', flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  getParallelPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let left = 0;\n    let right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    const lon = clamp(\n      extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\n      clampedLeft,\n      clampedRight\n    );\n    const coordinate1 =\n      flatCoordinates[left + 1] +\n      ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n        (lon - flatCoordinates[left])) /\n        (flatCoordinates[right] - flatCoordinates[left]);\n    const coordinate = [lon, coordinate1];\n    const point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  getParallels() {\n    return this.parallels_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateProjectionInfo_(projection) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const worldExtent = projection.getWorldExtent();\n\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      const split = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, output, dimension) {\n        dimension = dimension || 2;\n        const lonLatCoordinates = toLonLatTransform(\n          coordinates,\n          output,\n          dimension\n        );\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    const worldExtentP = applyTransform(\n      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],\n      this.fromLonLatTransform_,\n      undefined,\n      8\n    );\n\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\n      getCenter(projection.getExtent())\n    );\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  }\n}\n\nexport default Graticule;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,kBAAvB;AACA,OAAOC,SAAP,MAAsB,wBAAtB;AACA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,WAAP,MAAwB,aAAxB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SACEC,cADF,EAEEC,mBAFF,EAGEC,kBAHF,EAIEC,cAJF,EAKEC,MALF,EAMEC,SANF,EAOEC,eAPF,EAQEC,QARF,EASEC,UATF,EAUEC,OAVF,EAWEC,KAAK,IAAIC,WAXX,QAYO,cAZP;AAaA,SAAQC,KAAR,QAAoB,YAApB;AACA,SAAQC,mBAAR,QAAkC,kBAAlC;AACA,SACEC,UAAU,IAAIC,oBADhB,EAEEC,GAAG,IAAIC,aAFT,EAGEC,YAHF,QAIO,YAJP;AAKA,SAAQC,gBAAR,QAA+B,cAA/B;AACA,SAAQC,QAAR,EAAkBC,QAAlB,QAAiC,0BAAjC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,oBAAoB,GAAG,IAAI3B,MAAJ,CAAW;EACtC4B,KAAK,EAAE;AAD+B,CAAX,CAA7B;AAIA;AACA;AACA;AACA;;AACA,MAAMC,SAAS,GAAG,CAChB,EADgB,EAEhB,EAFgB,EAGhB,EAHgB,EAIhB,EAJgB,EAKhB,EALgB,EAMhB,CANgB,EAOhB,CAPgB,EAQhB,CARgB,EAShB,KAAK,EATW,EAUhB,KAAK,EAVW,EAWhB,KAAK,EAXW,EAYhB,IAAI,EAZY,EAahB,IAAI,EAbY,EAchB,IAAI,EAdY,EAehB,KAAK,IAfW,EAgBhB,KAAK,IAhBW,EAiBhB,KAAK,IAjBW,EAkBhB,IAAI,IAlBY,EAmBhB,IAAI,IAnBY,EAoBhB,IAAI,IApBY,CAAlB;AAuBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,SAAwB3B,WAAxB,CAAoC;EAClC;AACF;AACA;EACE4B,WAAW,CAACC,OAAD,EAAU;IACnBA,OAAO,GAAGA,OAAO,GAAGA,OAAH,GAAa,EAA9B;IAEA,MAAMC,WAAW,GAAGC,MAAM,CAACC,MAAP,CAClB;MACEC,oBAAoB,EAAE,IADxB;MAEEC,sBAAsB,EAAE,IAF1B;MAGEC,YAAY,EAAE;IAHhB,CADkB,EAMlBN,OANkB,CAApB;IASA,OAAOC,WAAW,CAACM,QAAnB;IACA,OAAON,WAAW,CAACO,WAAnB;IACA,OAAOP,WAAW,CAACQ,UAAnB;IACA,OAAOR,WAAW,CAACS,UAAnB;IACA,OAAOT,WAAW,CAACU,iBAAnB;IACA,OAAOV,WAAW,CAACW,iBAAnB;IACA,OAAOX,WAAW,CAACY,gBAAnB;IACA,OAAOZ,WAAW,CAACa,gBAAnB;IACA,OAAOb,WAAW,CAACc,aAAnB;IACA,OAAOd,WAAW,CAACe,aAAnB;IACA,OAAOf,WAAW,CAACgB,SAAnB;IACA,MAAMhB,WAAN;IAEA;AACJ;AACA;;IACI,KAAKiB,WAAL,GAAmB,IAAnB;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,OAAL,GAAeC,QAAf;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,OAAL,GAA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"},"metadata":{},"sourceType":"module"}