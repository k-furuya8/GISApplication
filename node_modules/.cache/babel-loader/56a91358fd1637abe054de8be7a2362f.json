{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, fromString, isStringColor } from '../color.js';\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\n\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\n\nexport const Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\n\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n\n    return ValueTypes.STRING;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n\n  const valueArr =\n  /** @type {Array<*>} */\n  value;\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n\n    return ValueTypes.NUMBER_ARRAY;\n  }\n\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(`Expected an expression operator but received: ${JSON.stringify(valueArr)}`);\n  }\n\n  const operator = Operators[valueArr[0]];\n\n  if (operator === undefined) {\n    throw new Error(`Unrecognized expression operator: ${JSON.stringify(valueArr)}`);\n  }\n\n  return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\n\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\n\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\n\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\n\nexport function colorToGlsl(color) {\n  const array = asArray(color).slice();\n\n  if (array.length < 4) {\n    array.push(1);\n  }\n\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\n\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n\n  return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\n\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\n\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n\n    if (operator === undefined) {\n      throw new Error(`Unrecognized expression operator: ${JSON.stringify(value)}`);\n    }\n\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n\n  const valueType = getValueType(value);\n\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(\n    /** @type {number} */\n    value);\n  }\n\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  }\n\n  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl(\n    /** @type {Array<number> | string} */\n    value);\n  }\n\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(\n    /** @type {Array<number>} */\n    value);\n  }\n\n  throw new Error(`Unexpected expression ${value} (expected type ${typeHint})`);\n}\n\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(`A numeric value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\n\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\n\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(`A string value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\n\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(`A boolean value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\n\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(`Exactly ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\n\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(`At least ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\n\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(`At most ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\n\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(`An even amount of arguments was expected, got ${args} instead`);\n  }\n}\n\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected, got ${args} instead`);\n  }\n}\n\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(args)}`);\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n\n    if (!context.attributes.includes(value)) {\n      context.attributes.push(value);\n    }\n\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\n\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n\n    if (!context.variables.includes(value)) {\n      context.variables.push(value);\n    }\n\n    return uniformNameForVariable(value);\n  }\n};\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures'; // ['palette', index, colors]\n\nOperators['palette'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n\n      let color;\n\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error('The second argument of palette must be an array of strings or colors');\n        }\n\n        const length = candidate.length;\n\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(`Expected palette color to have 3 or 4 values, got ${length}`);\n          }\n\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n};\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  }\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} * ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} + ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  }\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['floor'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['round'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  }\n};\nOperators['ceil'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})` : `atan(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(context, args[1])})`;\n  }\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2); // find common type\n\n      let type = ValueTypes.ANY;\n\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n\n      if (type === ValueTypes.NONE) {\n        throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(args)} instead`);\n      } // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n\n\n      type &= ~ValueTypes.COLOR;\n      return `(${expressionToGlsl(context, args[0], type)} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    }\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0])})`;\n  }\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n\n      let result = '';\n      result = args.map(arg => expressionToGlsl(context, arg)).join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    }\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  }\n};\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const array =\n    /** @type {Array<number>} */\n    args;\n\n    if (args.length === 3) {\n      array.push(1);\n    }\n\n    const parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6); // validate interpolation type\n\n    const type = args[0];\n    let interpolation;\n\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n\n      case 'exponential':\n        interpolation = type[1];\n        break;\n\n      default:\n        interpolation = null;\n    }\n\n    if (!interpolation) {\n      throw new Error(`Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(type)}`);\n    } // compute input/output types\n\n\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    const input = expressionToGlsl(context, args[1]);\n    const exponent = numberToGlsl(interpolation);\n    let result = '';\n\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i]);\n      const output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2]);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = `mix(${output1}, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${exponent}))`;\n    }\n\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    const input = expressionToGlsl(context, args[0]);\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n\n    return result;\n  }\n};","map":{"version":3,"names":["PaletteTexture","Uniforms","asArray","fromString","isStringColor","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","Operators","getValueType","value","Array","isArray","Error","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","Math","log2","numberToGlsl","s","toString","includes","arrayToGlsl","array","map","join","colorToGlsl","color","push","c","i","getStringNumberEquivalent","context","string","stringLiteralsMap","Object","keys","stringToGlsl","expressionToGlsl","typeHint","toGlsl","assertNumber","assertNumbers","values","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","assertUniqueInferredType","types","attributes","prefix","inFragmentShader","uniformNameForVariable","variableName","variables","PALETTE_TEXTURE_ARRAY","index","colors","numColors","palette","Uint8Array","candidate","offset","paletteTextures","paletteName","paletteTexture","GET_BAND_VALUE_FUNC","band","functions","ifBlocks","bandCount","colorIndex","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","bandExpression","xOffsetExpression","yOffsetExpression","min","max","getEqualOperator","type","getDecisionOperator","result","arg","parsedArgs","val","interpolation","outputType","input","exponent","stop1","output1","stop2","output2","fallback","match","output","condition"],"sources":["C:/Users/81806/Documents/work/GIS_APP/gis_app1/node_modules/ol/style/expressions.js"],"sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray, fromString, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(\n    array.map(function (c, i) {\n      return i < 3 ? c / 255 : c;\n    })\n  );\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(\n      context.stringLiteralsMap\n    ).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n\n  const valueType = getValueType(value);\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  }\n\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if (\n    (valueType & ValueTypes.STRING) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.STRING)\n  ) {\n    return stringToGlsl(context, value.toString());\n  }\n\n  if (\n    (valueType & ValueTypes.COLOR) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.COLOR)\n  ) {\n    return colorToGlsl(/** @type {Array<number> | string} */ (value));\n  }\n\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (value));\n  }\n\n  throw new Error(`Unexpected expression ${value} (expected type ${typeHint})`);\n}\n\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Could not infer only one type from the following expression: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.attributes.includes(value)) {\n      context.attributes.push(value);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  },\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.variables.includes(value)) {\n      context.variables.push(value);\n    }\n    return uniformNameForVariable(value);\n  },\n};\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\n            'The second argument of palette must be an array of strings or colors'\n          );\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(\n              `Expected palette color to have 3 or 4 values, got ${length}`\n            );\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n};\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  },\n};\n\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\n\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\n\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} * ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} + ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\n\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['floor'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['round'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  },\n};\n\nOperators['ceil'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2\n      ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n          context,\n          args[1]\n        )})`\n      : `atan(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\n\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = '';\n      result = args\n        .map((arg) => expressionToGlsl(context, arg))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\n\nOperators['any'] = getDecisionOperator('||');\n\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const array = /** @type {Array<number>} */ (args);\n    if (args.length === 3) {\n      array.push(1);\n    }\n    const parsedArgs = args.map(function (val, i) {\n      return (\n        expressionToGlsl(context, val, ValueTypes.NUMBER) +\n        (i < 3 ? ' / 255.0' : '')\n      );\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[1]);\n    const exponent = numberToGlsl(interpolation);\n\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i]);\n      const output1 =\n        result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2]);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = `mix(${output1}, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${exponent}))`;\n    }\n    return result;\n  },\n};\n\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[0]);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,4BAA3B;AACA,SAAQC,QAAR,QAAuB,gCAAvB;AACA,SAAQC,OAAR,EAAiBC,UAAjB,EAA6BC,aAA7B,QAAiD,aAAjD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,UAAU,GAAG;EACxBC,MAAM,EAAE,OADgB;EAExBC,MAAM,EAAE,OAFgB;EAGxBC,KAAK,EAAE,OAHiB;EAIxBC,OAAO,EAAE,OAJe;EAKxBC,YAAY,EAAE,OALU;EAMxBC,GAAG,EAAE,OANmB;EAOxBC,IAAI,EAAE;AAPkB,CAAnB;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAG,EAAlB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;EAClC,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAOV,UAAU,CAACC,MAAlB;EACD;;EACD,IAAI,OAAOS,KAAP,KAAiB,SAArB,EAAgC;IAC9B,OAAOV,UAAU,CAACI,OAAlB;EACD;;EACD,IAAI,OAAOM,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAIX,aAAa,CAACW,KAAD,CAAjB,EAA0B;MACxB,O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"},"metadata":{},"sourceType":"module"}